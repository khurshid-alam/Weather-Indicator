#!/usr/bin/python
# -*- coding: utf-8 -*-
### BEGIN LICENSE
# Copyright (C) 2010 Sebastian MacDonald Sebas310@gmail.com
# Copyright (C) 2010 Mehdi Rejraji mehd36@gmail.com
# Copyright (C) 2011 Vadim Rutkovsky roignac@gmail.com
# Copyright (C) 2013 Joshua Tasker jtasker@gmail.com
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3, as published
# by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.
### END LICENSE

from gi.repository import Gio, GLib, Gtk, Gdk, Notify, GObject, GdkPixbuf
from gi.repository import AppIndicator3 as AppIndicator

import sys, os, shutil, tempfile

import urllib2, urllib
from urllib import urlencode
import re
import locale
from xml.dom.minidom import parseString
import datetime
#import dbus
import time
import traceback
import types
from math import exp
import commands, threading
import logging, logging.handlers
import pywapi
import Queue

from indicator_weather.helpers import utf8

import gettext
from gettext import gettext as _
from gettext import ngettext as __
gettext.textdomain('indicator-weather')

# Add project root directory (enable symlink, and trunk execution).
PROJECT_ROOT_DIRECTORY = os.path.abspath(
    os.path.dirname(os.path.dirname(os.path.realpath(sys.argv[0]))))

if (os.path.exists(os.path.join(PROJECT_ROOT_DIRECTORY, 'indicator_weather'))
    and PROJECT_ROOT_DIRECTORY not in sys.path):
    sys.path.insert(0, PROJECT_ROOT_DIRECTORY)
    os.putenv('PYTHONPATH', PROJECT_ROOT_DIRECTORY) # for subprocesses

VERSION = "13.05.26 'Rainy 3'"

from indicator_weather.helpers import *

INFO_TYPE            = 'type'
INFO_SETTING         = 'setting'

class Settings:
    """ Class to read/write settings """
    db = None
    BASE_KEY             = 'apps.indicators.weather'
    WEATHER_KEY          = 'weather'
    LOCATIONS_KEY        = 'locations'
    INDICATOR_DISPLAY    = 'show_label'
    RELATIVE_DISPLAY     = 'show_relative'
    WIND_DISPLAY         = 'show_wind'
    SUNTIMES_DISPLAY     = 'show_suntimes'
    NOTIFICATIONS        = 'notif'
    WEATHER_SOURCE       = 'data_source'
    REFRESH_RATE         = 'refresh_rate'
    METRIC_SYSTEM        = 'unit'
    WIND_UNIT            = 'wind'
    HEAT_ESTIMATE        = 'heat'
    CHILL_ESTIMATE       = 'chill'
    PLACECHOSEN          = 'placechosen'
    PLACES               = 'places'

    # info dict
    # INFO_TYPE    : Python type
    # INFO_SETTING : dconf setting name
    INFO = {
        INDICATOR_DISPLAY : {
            INFO_TYPE : types.IntType,
            INFO_SETTING : 'indicator-display'
            },
        RELATIVE_DISPLAY : {
            INFO_TYPE : types.BooleanType,
            INFO_SETTING : 'relative-display'
            },
        WIND_DISPLAY : {
            INFO_TYPE : types.BooleanType,
            INFO_SETTING : 'wind-display'
            },
        SUNTIMES_DISPLAY : {
            INFO_TYPE : types.BooleanType,
            INFO_SETTING : 'suntimes-display'
            },
        NOTIFICATIONS : {
            INFO_TYPE : types.StringType,
            INFO_SETTING : 'notifications'
            },
        WEATHER_SOURCE : {
            INFO_TYPE : types.StringType,
            INFO_SETTING : 'weather-source'
            },
        REFRESH_RATE : {
            INFO_TYPE : types.IntType,
            INFO_SETTING : 'refresh-rate'
            },
        METRIC_SYSTEM : {
            INFO_TYPE : types.StringType,
            INFO_SETTING : 'metric-system'
            },
        WIND_UNIT : {
            INFO_TYPE : types.StringType,
            INFO_SETTING : 'wind-unit'
            },
        HEAT_ESTIMATE: {
            INFO_TYPE : types.StringType,
            INFO_SETTING : 'heat-estimate'
            },
        CHILL_ESTIMATE: {
            INFO_TYPE : types.StringType,
            INFO_SETTING : 'chill-estimate'
            },
        PLACECHOSEN : {
            INFO_TYPE : types.IntType,
            INFO_SETTING: 'placechosen'
            },
        PLACES : {
            INFO_TYPE : types.ListType,
            INFO_SETTING: 'places'
            },
    }

    def prepare_settings_store(self):
        """ Open the DB """
        log.debug("Settings: preparing settings store")
        try:
            self.db = Gio.Settings.new(self.BASE_KEY)
        except Exception as e:
            log.debug("Settings: exception occurred while "
                      "opening settings:\n %s" % str(e))

##    def check_autostart(self):
##        """ Make sure autostart file is installed. Inspired by GTG. """
##        autostart_dir = os.path.join(os.path.expanduser("~"),
##                                     ".config/autostart/")
##        autostart_file = "indicator-weather.desktop"
##        autostart_path = os.path.join(autostart_dir, autostart_file)
##        if not os.path.isfile(autostart_path):
##            #Look for the desktop file
##            desktop_file_path = None
##            desktop_file_directories = ["/usr/share/applications",
##                                        "/usr/local/share/applications"]
##            this_directory = os.path.dirname(os.path.abspath(__file__))
##            for path in desktop_file_directories:
##                fullpath = os.path.normpath(os.path.join(this_directory, path,
##                                                         autostart_file))
##                if os.path.isfile(fullpath):
##                    desktop_file_path = fullpath
##                    break
##            # If we have found the desktop file, we make a link to in in
##            # autostart_path.
##            if desktop_file_path:
##                if not os.path.exists(autostart_dir):
##                    os.mkdir(autostart_dir)
##                if os.path.isdir(autostart_dir):
##                    log.debug("Installing autostart file.")
##                    os.symlink(desktop_file_path, autostart_path)

    def get_value(self, setting, return_id = False):
        """ Get a value of the specified setting """
        log.debug("Settings: getting value for %s" % setting)
        setting_name = Settings.INFO[setting][INFO_SETTING]
        try:
            setting_type = Settings.INFO[setting][INFO_TYPE]
            get_func = {
                types.IntType:     self.db.get_int,
                types.StringType:  self.db.get_string,
                types.BooleanType: self.db.get_boolean,
                types.ListType:    self.db.get_string,
                types.DictType:    self.db.get_string,
                types.NoneType:    self.db.get_value,
                }[setting_type]
            return get_func(setting_name)
        except:
            log.debug("Settings: can't find value for %s" % setting)
            return None

    
    def set_value(self, setting, value):
        """ Set a value for the specified setting """
        value = '' if value is None else value
        value = str(value) if type(value) is types.ListType else value
        log.debug("Settings: setting '%s'='%s'" % (setting, value))

        setting_name = Settings.INFO[setting][INFO_SETTING]
        try:
            setting_type = Settings.INFO[setting][INFO_TYPE]
            set_func = {
                types.IntType:     self.db.set_int,
                types.StringType:  self.db.set_string,
                types.BooleanType: self.db.set_boolean,
                types.ListType:    self.db.set_string,
                types.DictType:    self.db.set_string,
                types.NoneType:    self.db.set_value,
                }[setting_type]
            set_func(setting_name, value)
        except:
            log.debug( \
                "Settings: schema for '%s' not found, aborting" % setting)

    def get_weather(self, location_code, return_id = False):
        """Get cached weather by location code.
        If return_id is True, only document id is returned,
        otherwise full weather data is returned.
        
        """
        log.debug("Settings: getting cached weather for %s" %
                  location_code)
        try:
            cached_weather_string = self.db.get_string(self.WEATHER_KEY)
            cached_weather = {} if cached_weather_string == ''\
                else eval(cached_weather_string)
            if location_code in cached_weather.keys():
                return str(cached_weather[location_code])
            else:
                log.debug(\
                    "Settings: can't find value for %s" % location_code)
                return None
        except:
            log.debug("Settings: can't find %s setting" % self.WEATHER_KEY)
            return None

    def save_weather(self, weather, location_code):
        """ Save weather info in cache for specific location """
        record = {
##            "label"      : weather.get_temperature(needs_rounding=True),
            "label"      : weather.get_temperature_string(),
            "condition"  : weather.get_condition_label(),
            "icon"       : weather.get_icon_name(),
            "temper"     : weather.get_temperature_label(),
            "feelslike"  : weather.get_relative_label(),
            "humidity"   : weather.get_humidity_label(),
            "wind"       : weather.get_wind_label(),
            "sunrise"    : weather.get_sunrise_label(),
            "sunset"     : weather.get_sunset_label()
        }
        log.debug("Settings: setting '%s'='%s'" % (location_code, record))

        try:
            cached_weather_string = self.db.get_string(self.WEATHER_KEY)
            cached_weather = {} if cached_weather_string == ''\
                else eval(cached_weather_string)
            cached_weather[location_code] = record
            cached_weather_string = str(cached_weather)
            self.db.set_string(self.WEATHER_KEY, cached_weather_string)
        except:
            log.debug(
                "Settings: schema for '%s' not found, aborting" %
                self.WEATHER_KEY
                )

    def get_location_details(self, location_code, return_id = False):
        """ Get location details by location code
        If return_id is True, only document id is returned,
        otherwise - full location data is returned
        
        """
        try:
            locations_string = self.db.get_string(self.LOCATIONS_KEY)
            locations = {} if locations_string == ''\
                else eval(locations_string)
            if location_code in locations.keys():
                return str(locations[location_code])
            else:
                log.debug(
                    "Settings: can't find value for %s" % location_code
                    )
                return None
        except:
            log.debug("Settings: can't find location details for %s" %
                      location_code)
            return None

    def save_location_details(self, location_details, location_code):
        """ Save location details """
        log.debug("Settings: setting '%s'='%s'" %
                  (location_code, location_details))
        try:
            locations_string = self.db.get_string(self.LOCATIONS_KEY)
            locations = {} if locations_string == ''\
                else eval(locations_string)
            locations[location_code] = location_details
            locations_string = str(locations)
            self.db.set_string(self.LOCATIONS_KEY, locations_string)
        except:
            pass

class UnitSystem:
    """ Class with available measurement unit systems """
    SI = 1
    IMPERIAL = 2

class WindUnits:
    """ Class for available wind unit systems """
    MPS = 1
    MPH = 2
    BEAUFORT = 3
    KPH = 4
    KNOTS = 5

class WeatherDataSource:
    """ Class for available weather data sources """
    YAHOO = 1
    WEATHER_COM = 2

class RelativeFormula:
    """ Class for relative temperature formulas """
    HEATINDEX = 1
    HUMIDEX = 2
    WINDCHILL = 3
    APPARENT = 4
    
class Location:
    """ Data object to store location details """

    def __init__(self, metric_system, wind_unit, heat_index,
                 chill_index, location_details = None):
        """ Initialize an object with a label """
        self.metric_system = metric_system
        self.wind_unit = wind_unit
        self.heat_index = heat_index
        self.chill_index = chill_index
        self.location_details = location_details

    def convert_coordinate_for_google(self, value):
        """ Convert coordinate for google """
        value = float(value) * 1e6
        return int(round(value))

    def prepare_location(self, geonames_details):
        """ Get necessary location details by its GeoNames details """
        self.location_details = {}
        self.location_details['full name'] = geonames_details[0]
        self.location_details['latitude'] = geonames_details[2]
        self.location_details['longitude'] = geonames_details[3]
        self.prepare_location_for_google(geonames_details)
        self.prepare_location_for_yahoo(geonames_details)
        self.prepare_location_for_weather_com(geonames_details)
        #TODO: Get noaa id from geonames service
        self.location_details['noaa id'] = "woot"

        # check mandatory attributes
        if not hasattr(self, 'location_code') or \
           'latitude' not in self.location_details or \
           'longitude' not in self.location_details:
            return False

        # check that we have at least one supported data source
        if 'google id' not in self.location_details and \
           'yahoo id' not in self.location_details and \
           'weather-com id' not in self.location_details:
            log.error(("Location '%s'" %
                       self.location_details['full name'])) + \
                "is not supported by current data sources"
            return False

        return True

    def prepare_location_for_google(self, geonames_details):
        """ Format latitude and longitude for Google needs """
        try:
            lat = self.convert_coordinate_for_google(geonames_details[2])
            lon = self.convert_coordinate_for_google(geonames_details[3])
            self.location_details['google id'] = ",,,%s,%s" % (lat, lon)

        except Exception, e:
            log.error(e)

    def prepare_location_for_yahoo(self, geonames_details):
        """ Get location details in English for Yahoo """
        baseurl = 'http://api.geonames.org/getJSON'
        params = {'geonameId': geonames_details[1], 'username': 'indicatorweather'}
        url = '?'.join((baseurl, urlencode(params)))
        log.debug("Location: Get GeoNames location details, url %s" % url)
        try:
            city = eval(urllib2.urlopen(url).read())
            if 'adminName1' in city:
                displayed_city_name = "%s, %s, %s" % (city['name'], city['adminName1'], city['countryName'])
            elif 'name' in city:
                displayed_city_name = "%s, %s" % (city['name'], city['countryName'])
            else:
                log.error("Location: Cannot find GeoNames info for code %s Full Response:\n %s" % (geonames_details[1], str(city)))
                return

            # Get YAHOO WOEID by english name of location
            woeid_result = pywapi.get_woeid_from_yahoo(displayed_city_name)            
            if 'error' in woeid_result:
                log.error("Location: Yahoo woeid return error. Full response:\n %s" % woeid_result['error'])
                return
            else:
                # only look at the the first woeid result
                woeid = woeid_result[0][0]
                self.location_code = woeid
                log.debug("Location: woeid is %s" % woeid)

                # Get old Yahoo id by woeid
                url = 'http://weather.yahooapis.com/forecastrss?w=%s' % woeid
                log.debug("Location: Get Yahoo RSS ID, url %s" % url)
                f = urllib2.urlopen(url)
                s=f.read()
                parsed = parseString(s)
                #TODO: Add a try-catch for empty guid_value
                guid = parsed.getElementsByTagName("guid")
                if len(guid) > 0:
                    guid_value = guid[0].firstChild.nodeValue
                    p = re.compile('([^_]*)_')
                    m = p.match(guid_value)
                    if m:
                        self.location_details['yahoo id'] = m.group(1)
                        log.debug("Location: yahoo id is %s" % self.location_details['yahoo id'])
                    else:
                        log.error("Location: Can't find yahoo id via woeid. Full response:\n %s" % guid_value)
                        return
                else:
                    log.error("Location: Can't guid in yahoo RSS response. Full response:\n %s" % s)
                    return

        except urllib2.URLError:
            log.error("Location: error reaching url '%s'" % url)

        except Exception, e:
            log.error(e)

    def prepare_location_for_weather_com(self, geonames_details):
        """ Get location details in English for Weather.com """
        baseurl = 'http://api.geonames.org/getJSON'
        params = {'geonameId': geonames_details[1], 'username': 'indicatorweather'}
        url = '?'.join((baseurl, urlencode(params)))
        log.debug("Location: Get GeoNames location details, url %s" % url)
        try:
            city = eval(urllib2.urlopen(url).read())
            if 'adminName1' in city:
                displayed_city_name = "%s, %s, %s" % (city['name'], city['adminName1'], city['countryName'])
            elif 'name' in city:
                displayed_city_name = "%s, %s" % (city['name'], city['countryName'])
            else:
                log.error("Location: Cannot find GeoNames info for code %s Full Response:\n %s" % (geonames_details[1], str(city)))
                return
    
            # Get Weather.com Location ID by English name of location
            locid_result = pywapi.get_loc_id_from_weather_com(displayed_city_name)
            if 'error' in locid_result:
                log.error("Location: Weather.com locid return error. Full response:\n %s" % locid_result['error'])
                return
            elif locid_result['count'] == 0:
                # no matches returned
                log.debug("Location: Weather.com returned 0 results "
                          "for %s" % displayed_city_name)
                return
            else:
                # only look at the the first locid result
                locid = locid_result[0][0]
                self.location_details['weather-com id'] = locid
                log.debug("Location: locid is %s" % locid)
    
        except urllib2.URLError:
            log.error("Location: error reaching url '%s'" % url)
    
        except Exception, e:
            log.error(e)

    def export_location_details(self):
        """ Return location code and location details """
        return (self.location_code, self.location_details)

    def update_weather_data(self, source):
        """ Get fresh weather data and store it to weather object """
        valid_source = None
        loc_ids = {}

        SOURCES = {
            WeatherDataSource.WEATHER_COM : ("weather-com id", "Weather.com"),
            WeatherDataSource.YAHOO : ("yahoo id", "Yahoo")
        }

        # gather existing source keys
        for source_id in SOURCES.keys():
            if SOURCES[source_id][0] in self.location_details:
                loc_ids[source_id] = SOURCES[source_id][0]

        # try with the default source
        if source in loc_ids:
            valid_source = source
            log.debug(("Location: default weather source '%s' " +
                       "chosen for '%s'") % (SOURCES[valid_source][1],
                       self.location_details['label']))

        # try with the first alternative
        elif len(loc_ids.keys()):
            valid_source = loc_ids.keys()[0]
            log.debug(("Location: non default weather source '%s' " +
                       "chosen for '%s'") % (SOURCES[valid_source][1],
                       self.location_details['label']))

        if valid_source is None:
            log.error(("Location: no valid weather source can be " +
                       "chosen for '%s'") % (
                       self.location_details['label']))
            self.weather = None
        else:
            self.weather = Weather(
                self.location_details[loc_ids[valid_source]],
                valid_source, self.metric_system, self.wind_unit,
                self.heat_index, self.chill_index,
                self.location_details['latitude'],
                self.location_details['longitude'])


class Forecast:
    """ Class to get forecast information """

    def __init__ (self, units, location_id, locale):
        """Initialize a class with metric system, wind units,
        location code and current user locale
        
        """
        self.metric_system = units
        self.location_id = location_id
        self.locale = locale

    def prepare_forecast_data(self):
        """ Get and store forecast data. For now using Weather.com only. """
        # TODO: Implement for NOAA
        self.daysofweek = []
        self.icons = []
        self.conditions = []
        self.error_message = None
        try:
            log.debug("Forecast: units set to %s" % self.metric_system)
            # Check units, default to imperial
            if self.metric_system == UnitSystem.SI:
                self.unitsystem = 'metric'
            elif self.metric_system == UnitSystem.IMPERIAL:
                self.unitsystem = 'imperial'
            else:
                self.unitsystem = 'imperial'

            self.forecast = pywapi.get_weather_from_weather_com(self.location_id, self.unitsystem)

            for forecast in self.forecast['forecasts']:
                self.daysofweek.append(forecast["day_of_week"])

                # Yahoo forecast icon URL is "http://l.yimg.com/a/i/us/we/52/<code>.gif"
                self.icons.append(forecast["day"]["icon"])
                self.conditions.append(forecast["day"]["brief_text"])

            self.error_message = None

        except urllib2.URLError:
            log.error("Forecast: error reading forecast for %s" % self.location_id)
        except KeyError:
            log.error("Forecast: returned empty forecast for %s" % self.location_id)
            self.error_message = _('Unknown error occurred while picking up weather data')

    def get_forecast_data(self):
        """ Parse high and low values for forecast data """
        self.highdata = []
        self.lowdata = []

        # Since we are now using Weather.com, forecast will always be in correct units
        for forecast in self.forecast['forecasts']:
            self.highdata.append(forecast["high"])
            self.lowdata.append(forecast["low"])

        return (self.highdata, self.lowdata)

    def get_forecast_daysofweek(self):
        """ Parse a list of days of week with forecast data """
        return self.daysofweek

    def get_forecast_icons(self):
        """ Parse icons for forecast data """
        return self.icons

    def get_forecast_conditions(self):
        """ Parse conditions for forecast data """
        return self.conditions

class Weather:
    """Data object to parse weather data with unit conversion """

##    #Available conditions by google icon
##    #Format: Google icon name: (day icon, night icon, is a severe weather condition)
##    #Reference: http://www.blindmotion.com/2009/03/google-weather-api-images/
##    _GoogleConditions = {
##        "sunny"            : ( "weather-clear",      "weather-clear-night",      False),
##        "mostly_sunny"     : ( "weather-clear",      "weather-clear-night",      False),
##        "partlycloudy"     : ( "weather-few-clouds", "weather-few-clouds-night", False),
##        "partly_cloudy"    : ( "weather-few-clouds", "weather-few-clouds-night", False),
##        "windy"            : ( "weather-few-clouds", "weather-few-clouds-night", False),
##        "cloudy"           : ( "weather-clouds",     "weather-clouds-night",     False),
##        "mostlycloudy"     : ( "weather-overcast",   "weather-overcast",         False),
##        "mostly_cloudy"    : ( "weather-overcast",   "weather-overcast",         False),
##        "overcast"         : ( "weather-overcast",   "weather-overcast",         False),
##        "rain"             : ( "weather-showers",    "weather-showers",          False),
##        "chanceofrain"     : ( "weather-showers",    "weather-showers",          False),
##        "chance_of_rain"   : ( "weather-showers",    "weather-showers",          False),
##        "heavyrain"        : ( "weather-showers",    "weather-showers",          False),
##        "drizzle"          : ( "weather-showers",    "weather-showers",          False),
##        "sleet"            : ( "weather-snow",       "weather-snow",             False),
##        "rain_snow"        : ( "weather-snow",       "weather-snow",             False),
##        "rainsnow"         : ( "weather-snow",       "weather-snow",             False),
##        "snow"             : ( "weather-snow",       "weather-snow",             False),
##        "chanceofsnow"     : ( "weather-snow",       "weather-snow",             False),
##        "chance_of_snow"   : ( "weather-snow",       "weather-snow",             False),
##        "heavysnow"        : ( "weather-snow",       "weather-snow",             False),
##        "icy"              : ( "weather-snow",       "weather-snow",             False),
##        "snowflurries"     : ( "weather-snow",       "weather-snow",             False),
##        "flurries"         : ( "weather-snow",       "weather-snow",             False),
##        "dust"             : ( "weather-fog",        "weather-fog",              False),
##        "fog"              : ( "weather-fog",        "weather-fog",              False),
##        "smoke"            : ( "weather-fog",        "weather-fog",              False),
##        "haze"             : ( "weather-fog",        "weather-fog",              False),
##        "mist"             : ( "weather-fog",        "weather-fog",              False),
##        "thunderstorm"     : ( "weather-storm",      "weather-storm",            True),
##        "chance_of_storm"  : ( "weather-storm",      "weather-storm",            True),
##        "thunderstorms"    : ( "weather-storm",      "weather-storm",            True),
##        "scatteredshowers" : ( "weather-showers-scattered", "weather-showers-scattered", True),
##        "scatteredthunderstorms" : ( "weather-storm",       "weather-storm",             True),
##    }

    # Available conditions by yahoo condition code
    # Format: condition code: (day icon, night icon, is a severe weather condition, localized condition name)
    _YahooConditions = {
        '0' : ("weather-storm",             "weather-storm",            True,  _("Tornado")),
        '1' : ("weather-storm",             "weather-storm",            True,  _("Tropical storm")),
        '2' : ("weather-storm",             "weather-storm",            True,  _("Hurricane")),
        '3' : ("weather-storm",             "weather-storm",            True,  _("Severe thunderstorms")),
        '4' : ("weather-storm",             "weather-storm",            True,  _("Thunderstorms")),
        '5' : ("weather-snow",              "weather-snow",             False, _("Mixed rain and snow")),
        # Use American meaning of sleet - see http://en.wikipedia.org/wiki/Sleet
        '6' : ("weather-showers",           "weather-showers",          False, _("Mixed rain and sleet")),
        '7' : ("weather-snow",              "weather-snow",             False, _("Mixed snow and sleet")),
        '8' : ("weather-showers",           "weather-showers",          False, _("Freezing drizzle")),
        '9' : ("weather-showers",           "weather-showers",          False, _("Drizzle")),
        '10': ("weather-snow",              "weather-snow",             False, _("Freezing rain")),
        '11': ("weather-showers",           "weather-showers",          False, _("Showers")),
        '12': ("weather-showers",           "weather-showers",          False, _("Showers")),
        '13': ("weather-snow",              "weather-snow",             False, _("Snow flurries")),
        '14': ("weather-snow",              "weather-snow",             False, _("Light snow showers")),
        '15': ("weather-snow",              "weather-snow",             False, _("Blowing snow")),
        '16': ("weather-snow",              "weather-snow",             False, _("Snow")),
        '17': ("weather-showers",           "weather-showers",          False, _("Hail")),
        '18': ("weather-snow",              "weather-snow",             False, _("Sleet")),
        '19': ("weather-fog",               "weather-fog",              False, _("Dust")),
        '20': ("weather-fog",               "weather-fog",              False, _("Foggy")),
        '21': ("weather-fog",               "weather-fog",              False, _("Haze")),
        '22': ("weather-fog",               "weather-fog",              False, _("Smoky")),
        '23': ("weather-clear",             "weather-clear-night",      False, _("Blustery")),
        '24': ("weather-clear",             "weather-clear-night",      False, _("Windy")),
        '25': ("weather-clear",             "weather-clear-night",      False, _("Cold")),
        '26': ("weather-clouds",            "weather-clouds-night",     False, _("Cloudy")),
        '27': ("weather-clouds",            "weather-clouds-night",     False, _("Mostly cloudy")),
        '28': ("weather-clouds",            "weather-clouds-night",     False, _("Mostly cloudy")),
        '29': ("weather-few-clouds",        "weather-few-clouds-night", False, _("Partly cloudy")),
        '30': ("weather-few-clouds",        "weather-few-clouds-night", False, _("Partly cloudy")),
        '31': ("weather-clear",             "weather-clear-night",      False, _("Clear")),
        '32': ("weather-clear",             "weather-clear-night",      False, _("Sunny")),
        '33': ("weather-clear",             "weather-clear-night",      False, _("Fair")),
        '34': ("weather-clear",             "weather-clear-night",      False, _("Fair")),
        '35': ("weather-showers-scattered", "weather-showers-scattered",False, _("Mixed rain and hail")),
        '36': ("weather-clear",             "weather-clear-night",      False, _("Hot")),
        '37': ("weather-storm",             "weather-storm",            True,  _("Isolated thunderstorms")),
        '38': ("weather-storm",             "weather-storm",            True,  _("Scattered thunderstorms")),
        '39': ("weather-storm",             "weather-storm",            True,  _("Scattered thunderstorms")),
        '40': ("weather-showers-scattered", "weather-showers-scattered",False, _("Scattered showers")),
        '41': ("weather-snow",              "weather-snow",             False, _("Heavy snow")),
        '42': ("weather-snow",              "weather-snow",             False, _("Scattered snow showers")),
        '43': ("weather-snow",              "weather-snow",             False, _("Heavy snow")),
        '44': ("weather-few-clouds",        "weather-few-clouds-night", False, _("Partly cloudy")),
        '45': ("weather-storm",             "weather-storm",            True,  _("Thundershowers")),
        '46': ("weather-snow",              "weather-snow",             False, _("Snow showers")),
        '47': ("weather-storm",             "weather-storm",            True,  _("Isolated thundershowers")),
        '3200': (False,                     False,                      False, _("Unknown condition"))
    }

    # Available conditions by Weather.com condition code; same as Yahoo
    _WeathercomConditions = _YahooConditions
    
    def __init__(self, location_id, weather_datasource, metric_system,
                 wind_unit, heat_index, chill_index, lat, lon):
        """ Initialize and get fresh weather data """
        self.__weather_datasource = weather_datasource
        self.__metric_system = metric_system
        self._wind_unit = wind_unit
        self.__current_condition = None
        self.__heat_index = heat_index
        self.__chill_index = chill_index
        self.__lat = lat
        self.__lon = lon

        if self.__metric_system == UnitSystem.SI:
            unit_system = 'metric'
        elif self.__metric_system == UnitSystem.IMPERIAL:
            unit_system = 'imperial'
        else:
            unit_system = 'imperial'
                
        # Get data from Weather.com
        if self.__weather_datasource == WeatherDataSource.WEATHER_COM:
            self.__report = pywapi.get_weather_from_weather_com(
                                                    location_id, unit_system)
            ##self.__localized_report = self.__report
            log.debug("Weather: checking Weather.com report for "
                      "weather condition and icon name")
            if 'current_conditions' not in self.__report.keys():
                icon_name = ""
                log.error("Weather: could not get Weather.com "
                          "weather condition from report")
                log.error("Weather: got data '%s'" % str(self.__report))
                self.__current_condition = (False, False, False, _("Unknown condition"))

            elif 'icon' in self.__report['current_conditions'].keys():
                icon_name = self.__report['current_conditions']['icon']
                self.__current_condition = self._WeathercomConditions.get(icon_name)

            else:
                icon_name = ""
                log.error("Weather: could not get icon name from Weather.com report")
                log.error("Weather: got data '%s'" % str(self.__report['current_conditions']))
                self.__current_condition = (False, False, False, _("Unknown condition"))
            
        # Get data from Yahoo
        if self.__weather_datasource == WeatherDataSource.YAHOO:
            self.__report = pywapi.get_weather_from_yahoo(location_id, unit_system)
            ##self.__localized_report = self.__report
            log.debug("Weather: checking Yahoo report for "
                      "weather condition and icon name")
            if 'condition' not in self.__report.keys():
                icon_name = ""
                log.error("Weather: could not get Yahoo weather condition from report")
                log.error("Weather: got data '%s'" % str(self.__report))
                self.__current_condition = (False, False, False, _("Unknown condition"))

            elif 'code' in self.__report['condition'].keys():
                icon_name = self.__report['condition']['code']
                self.__current_condition = self._YahooConditions.get(icon_name)

            else:
                icon_name = ""
                log.error("Weather: could not get icon name from Yahoo report")
                log.error("Weather: got data '%s'" % str(self.__report['condition']))
                self.__current_condition = (False, False, False, utf8(_("Unknown condition")))

        log.debug("Weather: current condition: '%s', '%s'" % (icon_name, str(self.__current_condition)))
        #Prepare sunrise/sunset data
        self.get_sun_data()

    def get_sun_data(self):
        """ Get sunrise/sunset times and calculate whether it is night already """
        self.__night = False
        self.__sunrise_t = None
        self.__sunset_t = None
        # Grab local datetime and the daylight saving status (1/0)
        # from earthtools.org
        url = 'http://www.earthtools.org/timezone-1.1/%s/%s' % \
            (self.__lat, self.__lon)
        try:
            f = urllib2.urlopen(url)
            s = f.read()
            parsed = parseString(s)
            localtime = parsed.getElementsByTagName(
                "isotime")[0].firstChild.nodeValue
            dst = parsed.getElementsByTagName(
                "dst")[0].firstChild.nodeValue
            # strip timezone info
            localtime = datetime.datetime.strptime(localtime.rsplit(' ',1)[0],
                                                   '%Y-%m-%d %H:%M:%S')
            dst = 1 if dst == "True" else 0

        except urllib2.URLError:
            log.error("Weather: error reaching url '%s'" % url)
            return

        # Grab sunrise/sunset from earthtools.org
        url = 'http://www.earthtools.org/sun/%s/%s/%s/%s/99/%s' % \
            (self.__lat, self.__lon, localtime.day, localtime.month, dst)
        try:
            log.debug("Weather: get_sun_data: getting sunrise/sunset data")
            f = urllib2.urlopen(url)
            s=f.read()
            parsed = parseString(s)
            sunrise = parsed.getElementsByTagName("morning")[0].getElementsByTagName("sunrise")[0].firstChild.nodeValue
            sunset  = parsed.getElementsByTagName("evening")[0].getElementsByTagName("sunset")[0].firstChild.nodeValue
            self.__sunrise_t = datetime.datetime.strptime(sunrise, '%H:%M:%S').time()
            self.__sunset_t = datetime.datetime.strptime(sunset, '%H:%M:%S').time()
        except urllib2.URLError:
            log.error("Weather: error reaching url '%s'" % url)
            return

        # Calculate, whether it is night or day
        if localtime.time()<self.__sunrise_t or localtime.time()>self.__sunset_t:
            self.__night = True
        else:
            self.__night = False
        log.debug("Weather: got localtime " +
                  "%s, dst %s, sunrise '%s', sunset '%s', night = %s" % (
                      localtime, dst, self.__sunrise_t, self.__sunset_t, self.__night))

    def condition_is_severe(self):
        """ Return True if weather condition is severe """
        if self.__current_condition != None:
            log.debug("Weather: got severe condition '%s'" % self.__current_condition[2])
            return self.__current_condition[2]
        else:
            log.error("Weather: condition is not set while condition severity check")
            return False

    def get_icon_name(self):
        """ Get icon name associated with current condition """
        if self.__current_condition != None:
            if self.__night:
                log.debug("Weather: night, show '%s' icon" % self.__current_condition[1])
                return self.__current_condition[1]
            else:
                log.debug("Weather: day, show '%s' icon" % self.__current_condition[0])
                return self.__current_condition[0]
        else:
            log.error("Weather: return 'offline' icon due to empty condition")
            return False

    def get_condition_label(self):
        """ Get text of current condition """
        if self.__weather_datasource == WeatherDataSource.WEATHER_COM:
            condition = self.__report['current_conditions']['text']
        if self.__weather_datasource == WeatherDataSource.YAHOO:
            condition = self.__current_condition[3]
        return condition

    def get_humidity_label(self):
        """ Get text string for current humidity """
        humidity = "%s: ---%%" % (_("Humidity"))
        if self.__weather_datasource == WeatherDataSource.WEATHER_COM \
           and 'humidity' in self.__report['current_conditions']:
            humidity = "%s: %s%%" % (_("Humidity"), self.__report['current_conditions']['humidity'])
        if self.__weather_datasource == WeatherDataSource.YAHOO \
           and 'humidity' in self.__report['atmosphere']:
            humidity = "%s: %s%%" % (_("Humidity"), self.__report['atmosphere']['humidity'])
        return humidity

    def get_dew_point_label(self):
        """ Get dew point, which is used in humidex calculation """
        #TODO: Update with NOAA
        _value = "---"
        _unit = ""        
        if self.__weather_datasource == WeatherDataSource.YAHOO:
            # Not returned by Yahoo
            return None
        if self.__weather_datasource == WeatherDataSource.WEATHER_COM:
            _value = self.__report['current_conditions']['dewpoint']
            _unit = self.__report['units']['temperature']
        return u"%s: %s °%s" % (_("Dewpoint"), _value, _unit)

    def get_pressure_label(self):
        """ Get text string for current air pressure """
        _value = "---"
        _unit = ""
        if self.__weather_datasource == WeatherDataSource.WEATHER_COM \
           and 'barometer' in self.__report['current_conditions'].keys() \
           and 'pressure' in self.__report['units'].keys():
            _value = self.__report['current_conditions']['barometer']['reading']
            _unit = self.__report['units']['pressure']
        if self.__weather_datasource == WeatherDataSource.YAHOO \
           and 'pressure' in self.__report['atmosphere'].keys() \
           and 'pressure' in self.__report['units'].keys():
            _value = self.__report['atmosphere']['pressure']
            _unit = self.__report['units']['pressure']
        return "%s: %s %s" % (_("Pressure"), _value, _unit)

##    def get_temperature(self, needs_rounding = False):
    def get_temperature(self):
        """ Get temperature value and units string """
        _value = None
        _unit = ""
        if (self.__weather_datasource == WeatherDataSource.WEATHER_COM and
            'temperature' in self.__report['current_conditions'].keys() and
            'temperature' in self.__report['units'].keys()):
            if ((self.__metric_system == UnitSystem.SI and
                    self.__report['units']['temperature'] == u"C") or
               (self.__metric_system == UnitSystem.IMPERIAL and
                    self.__report['units']['temperature' ] == u"F")):
                _value = self.__report['current_conditions']['temperature']
                _unit = u"°%s" % self.__report['units']['temperature']
        if (self.__weather_datasource == WeatherDataSource.YAHOO and
            'temp' in self.__report['condition'].keys() and
            'temperature' in self.__report['units'].keys()):
            if ((self.__metric_system == UnitSystem.SI and
                    self.__report['units']['temperature'] == u"C") or
               (self.__metric_system == UnitSystem.IMPERIAL and
                    self.__report['units']['temperature'] == u"F")):
                _value = self.__report['condition']['temp']
                _unit = u"°%s" % self.__report['units']['temperature']
##        # round the value if required
##        if needs_rounding and _value != "---":
##            _value = NumberFormatter.format_float(locale.atof(_value), 0)
        return (_value, _unit)

    def get_temperature_string(self):
        """ Get temperature with units value - doesn't include 'Temperature' string """
        (_value, _unit) = self.get_temperature()
        if _value is None:
            _value = "---"
            _unit = ""
        return (u"%s %s" % (_value, _unit))

    def get_temperature_label(self):
        """ Get text string for current temperature label """
        return u"%s: %s" % (_("Temperature"), self.get_temperature_string())

    def get_relative_string(self):
        """ Get relative temperature with units value - doesn't include 'Feels Like' string """        
        # try relative heat
        if self.__heat_index == RelativeFormula.HUMIDEX:
            (_value, _unit) = self.get_humidex()
        if self.__heat_index == RelativeFormula.HEATINDEX:
            (_value, _unit) = self.get_heat_index()
        if _value is not None:
            return (u"%s %s" % (_value, _unit))
        # try relative chill
        if self.__chill_index == RelativeFormula.WINDCHILL:
            (_value, _unit) = self.get_wind_chill()
        if self.__chill_index == RelativeFormula.APPARENT:
            (_value, _unit) = self.get_apparent_temp()
        if _value is not None:
            return (u"%s %s" % (_value, _unit))
        # use current temperature
        return self.get_temperature_string()

    def get_relative_label(self):
        """ Get text string for relative temperature ("feels like") label """
        return "%s: %s" % (_("Feels Like"), self.get_relative_string())
    
    def get_humidex(self):
        """ Calculate humidex and get value and units
        
        The standard Humidex formula used by Environment Canada is:
        
        humidex = (air temperature) + h
        
        h = (0.5555)*(e - 10.0);
        e = vapour pressure in hPa (mbar), given by:
        e = 6.11 * exp [5417.7530 * ( (1/273.16) - (1/dewpoint) ) ]
        where dewpoint is expressed in Kelvins
        (temperature in K = temperature in °C + 273.1)
        and 5417.7530 is a rounded constant based on the molecular weight
        of water, latent heat of evaporation, and the universal gas constant.
        
        """
        #TODO: Update with NOAA data
        if self.__weather_datasource == WeatherDataSource.YAHOO:
            # Empty for Yahoo
            return (None, "")
        if self.__weather_datasource == WeatherDataSource.WEATHER_COM:
            if self.__report['units']['temperature'] == "F":
                # Humidex is calculated in C
                dew_point_f = float(self.__report['current_conditions']['dewpoint'])
                temp_f = float(self.__report['current_conditions']['temperature'])
                dew_point_c = ((dew_point_f - 32.0) * 5.0/9.0)
                temp_c = ((temp_f - 32.0) * 5.0/9.0)
            else:
                dew_point_c = float(self.__report['current_conditions']['dewpoint'])
                temp_c = float(self.__report['current_conditions']['temperature'])
            vapour_pressure = 6.11 * exp(5417.7530 * ( (1/273.16) - (1/(dew_point_c+273.16))))
            humidex = temp_c + (0.5555)*(vapour_pressure  - 10.0)
            # Humidex is meaningless if it is lower than temperature
            if humidex < temp_c:
                #return (u"%s: N/A" % _("Humidex"))
                return (None, "")
            if self.__report['units']['temperature'] == "F":
                humidex_f = (humidex*9.0/5.0) + 32.0
                # Humidex is unitless (represents Celsius) so in F show units
                #return (u"%s: %s°F" % (_("Humidex"), NumberFormatter.format_float(humidex_f, 1))).replace(".0", "")    
                #return (NumberFormatter.format_float(humidex_f, 1).replace(".0", ""), u"°F")
                return (int(round(humidex_f)), u"°F")
            else:
                #return ("%s: %.1f" % (_("Humidex"), humidex)).replace(".0", "")
                #return (u"%s: %s" % (_("Humidex"), NumberFormatter.format_float(humidex, 1))).replace(".0", "")
                #return (NumberFormatter.format_float(humidex, 1).replace(".0", ""), u"°C")
                return (int(round(humidex)), u"°C")

    def get_heat_index(self):
        """ Calculate heat index and get value and units
        
        The formula below approximates the heat index in degrees
        Fahrenheit, to within ±1.3 °F. It is the result of a
        multivariate fit (temperature equal to or greater than
        80°F and relative humidity equal to or greater than 40%)
        to a model of the human body.
       
        Heat Index = c_1 + (c_2 * T) + (c_3 * R) + (c_4 * T * R) +
                      (c_5 * T^2) + (c_6 * R^2) + (c_7 * T^2 * R) +
                      (c_8 * T * R^2) + (c_9 * T^2 * R^2) 
        where:
          T = ambient dry-bulb temperature (in degrees Fahrenheit)
          R = relative humidity (percentage value between 0 and 100)

        """
        #TODO: Update with NOAA data
        _value = None

        if self.__weather_datasource == WeatherDataSource.YAHOO:
            log.debug("Weather: get_heat_index: weather_datasource is Yahoo, "
                      "checking temp and humidity")
            if self.__report['units']['temperature'] == "C":
                units = 'metric'
            elif self.__report['units']['temperature'] == "F":     # else here?
                units = 'imperial'
            T = float(self.__report['condition']['temp'])
            R = float(self.__report['atmosphere']['humidity'])
            _value = pywapi.heat_index(T, R, units)

        if self.__weather_datasource == WeatherDataSource.WEATHER_COM:
            log.debug("Weather: get_heat_index: weather_datasource is "
                      "Weather.com, checking temp and humidity")
            if self.__report['units']['temperature'] == "C":
                units = 'metric'
            elif self.__report['units']['temperature'] == "F":  # else here?
                units = 'imperial'
            T = float(self.__report['current_conditions']['temperature'])
            R = float(self.__report['current_conditions']['humidity'])
            _value = pywapi.heat_index(T, R, units)

        # Heat Index is only valid for temp >= 80°F and humidity >= 40%)
        if _value is None:
            return (_value, "")
        if units == 'metric':
            #return (u"%s: %s°C" % (_("Heat Index"), NumberFormatter.format_float(heat_index, 1))).replace(".0", "")    
            #return (NumberFormatter.format_float(_value, 1).replace(".0", ""), u"°C")
            return (int(round(_value)), u"°C")
            
        elif units == 'imperial': # else here?
            #return (u"%s: %s°F" % (_("Heat Index"), NumberFormatter.format_float(heat_index, 1))).replace(".0", "")
            #return (NumberFormatter.format_float(_value, 1).replace(".0", ""), u"°F")
            return (int(round(_value)), u"°F")

    def get_wind_chill(self):
        """ Calculate wind chill index and get text string for label
        
        The standard Wind Chill formula used by Environment Canada,
        the 2001 JAG/TI Wind Chill Equivalent Temperature Index, is:

            T_wc = 13.12 + 0.6215 * T_a -
                        11.37 * V^0.16 +
                        0.3965 * T_a * V^0.16
        where:
          T_wc is the wind chill index based on Celsius
          T_a is the air temperature in °C
          V is the wind speed in km/h, at 10 m (standard anemometer height)

        The equivalent formula in US customary units is:
        
            T_wc = 35.74 + 0.6215 * T_a -
                        35.75 * V^0.16 +
                        0.4275 * T_a * V^0.16
        
        where:
          T_wc is the wind chill index based on Fahrenheit
          T_a is the air temperature °F
          V is the wind speed in mph

        Windchill temperature is defined only for temperatures above
        -45 °C (-50 °F) and below 10 °C (50 °F) and wind speeds
        above 4.8 km/h (3.0 mph). Bright sunshine may increase the
        wind chill temperature by 6 to 10 °C (10 to 18 °F). 

        """
        #TODO: Update with NOAA data
        _value = None

        if self.__report['units']['temperature'] == "C":
            units = 'metric'
        elif self.__report['units']['temperature'] == "F":     # else here?
            units = 'imperial'

        if self.__weather_datasource == WeatherDataSource.YAHOO:
            log.debug("Weather: get_wind_chill: weather_datasource is "
                      "Yahoo, checking temp and humidity")
            T_a = float(self.__report['condition']['temp'])
            V = float(self.__report['wind']['speed'])
            if T_a <= -50 or T_a >= 50 or V <= 3.0:
                return (_value, "")
                
        if self.__weather_datasource == WeatherDataSource.WEATHER_COM:
            log.debug("Weather: get_wind_chill: weather_datasource is "
                      "Weather.com, checking temp and humidity")
            T_a = float(self.__report['current_conditions']['temperature'])
            wind_speed = self.__report['current_conditions']['wind']['speed']
            V = (0.0 if wind_speed == 'calm' else float(wind_speed))
            if T_a <= -45 or T_a >= 10 or V <= 4.8:
                return (_value, "")
        
        if units == 'metric':
            _value = 13.12 + 0.6215 * T_a - 11.37 * pow(V, 0.16) + 0.3965 * T_a * pow(V, 0.16)
            return (int(round(_value)), u"°C")
        elif units == 'imperial':
            _value = 35.74 + 0.6215 * T_a - 35.75 * pow(V, 0.16) + 0.4275 * T_a * pow(V, 0.16)
            return (int(round(_value)), u"°F")

        if _value is None:
            return (_value, "")
                    
    def get_apparent_temp(self):
        """ Calculate Australian apparent temperature and get text string for label

        The standard formula for cooler temperatures used by the Australian 
        Bureau of Meteorology, the Australian Apparent Temperature, is:

            AT = T_a + 0.33e - 0.70ws - 4.00
        
        Where:
            T_a = Dry bulb temperature (°C)
            e = Water vapour pressure (hPa)
            ws = Wind speed (m/s) at an elevation of 10 meters
        
        The vapour pressure can be calculated from the temperature and
        relative humidity using the equation:
        
            e = (rh / 100) * 6.105 * exp^[(17.27 * T_a) / (237.7 + T_a)]
        
        Where:
            T_a = Dry bulb temperature (°C)
            rh = Relative humidity [%]
            exp^ represents the exponential function
        
        The Australian chill formula is only defined for temperatures
        at or below 20°C (68°F) and wind speeds above 4.8 km/h (3.0 mph).

        """
        #TODO: Update with NOAA data
        _value = None

        if self.__report['units']['temperature'] == "C":
            units = 'metric'
        elif self.__report['units']['temperature'] == "F":     # else here?
            units = 'imperial'

        if self.__weather_datasource == WeatherDataSource.YAHOO:
            log.debug("Weather: get_wind_chill: weather_datasource is "
                      "Yahoo, checking temp and humidity")
            T_a = float(self.__report['condition']['temp'])
            rh = float(self.__report['atmosphere']['humidity'])
            ws = float(self.__report['wind']['speed'])
        if self.__weather_datasource == WeatherDataSource.WEATHER_COM:
            log.debug("Weather: get_wind_chill: weather_datasource is "
                      "Weather.com, checking temp and humidity") 
            T_a = float(self.__report['current_conditions']['temperature'])
            rh = float(self.__report['current_conditions']['humidity'])
            ws = float(self.__report['current_conditions']['wind']['speed'])
        
        # calculated in °C, so need to convert from °F
        if units == 'imperial':
            T_a = ((T_a - 32.0) * 5.0/9.0)

        e = (rh / 100) * 6.105 * exp((17.27 * T_a) / (237.7 + T_a))
        _value = T_a + 0.33 * e - 0.70 * ws - 4.00

        # Now convert back to °F
        if units == 'imperial':
            _value = (_value*9.0/5.0) + 32.0
            return (int(round(_value)), u"°F")
        if units == 'metric':    
            return (int(round(_value)), u"°C")

        if _value is None:
            return (_value, "")
        
    def get_wind_label(self):
        """ Get text string for current wind speed and direction """
        if self.__weather_datasource == WeatherDataSource.WEATHER_COM:
            # Create a wind_info structure from Weather.com data
            wind_direction = u"%s (%s°)" % (self.__report['current_conditions']['wind']['text'],
                                            self.__report['current_conditions']['wind']['direction'])
            wind_speed = self.__report['current_conditions']['wind']['speed']
            wind_units = self.__report['units']['speed']
            if wind_speed == "calm":
                wind_speed = 0
                ##wind_direction = wind_direction.replace("CALM","Calm")
            wind_info = [_("Wind") + ":", wind_direction, wind_speed, wind_units]
        if self.__weather_datasource == WeatherDataSource.YAHOO:
            # Create a wind_info structure from Yahoo data
            wind_direction = u"%s (%s°)" % (_(pywapi.get_wind_direction(self.__report['wind']['direction'])), self.__report['wind']['direction'])
            wind_speed = self.__report['wind']['speed']
            wind_units = self.__report['units']['speed']
            wind_info = [_("Wind") + ":", wind_direction, wind_speed, wind_units]

        try:
            _value = float(wind_speed)
        except ValueError as e:
            log.error("Could not parse '%s' as wind speed." % str(wind_speed))
            _value = -1.0

        # Parse Wind_direction - convert to selected scale
        if wind_units == "mph":
            if (self._wind_unit == WindUnits.MPH):
                _unit  = __("mph", "mph", _value)
            if (self._wind_unit == WindUnits.MPS):
                _value *= 0.44704
                _unit  = __("m/s", "m/s", _value)
            if (self._wind_unit == WindUnits.BEAUFORT):
                if _value >= 0.0:
                    _value = pywapi.wind_beaufort_scale(_value, WindUnits.MPH)
                _unit  = ""
            if (self._wind_unit == WindUnits.KPH):
                _value *= 1.609344
                _unit  = __("km/h", "km/h", _value)
            if (self._wind_unit == WindUnits.KNOTS):
                _value *= 0.868976241900648
                _unit  = __("knot", "knots", _value)
        elif wind_units == "km/h":
            if (self._wind_unit == WindUnits.MPH):
                _value *= 0.621371
                _unit  = __("mph", "mph", _value)
            if (self._wind_unit == WindUnits.MPS):
                _value *= 0.277778
                _unit  = __("m/s", "m/s", _value)
            if (self._wind_unit == WindUnits.BEAUFORT):
                if _value >= 0.0:
                    _value = pywapi.wind_beaufort_scale(_value, WindUnits.KPH)
                _unit  = ""
            if (self._wind_unit == WindUnits.KPH):
                _unit  = __("km/h", "km/h", _value)
            if (self._wind_unit == WindUnits.KNOTS):
                _value *= 0.539957
                _unit  = __("knot", "knots", _value)
        else:
            log.error("Could not parse '%s' as wind units." % wind_units)
            _value = -1.0
            
        # Join wind_info data in a label
        wind_info[len(wind_info)-1] = _unit
        wind_info[len(wind_info)-2] = \
            NumberFormatter.format_float(_value, 1)
        if _value < 0.0:
            wind_info[1:] = ["", "N\A", ""]
        if _value == 0.0:
            wind_info[1:] = [_("Calm"), "", ""]
        return "%s %s %s %s" % (wind_info[0], wind_info[1], \
                                wind_info[2], wind_info[3])

    def get_sunrise_label(self):
        """ Get text string for sunrise time """
        return "%s: %s" % (utf8(_("Sunrise")), TimeFormatter.format_time(self.__sunrise_t))

    def get_sunset_label(self):
        """ Get text string for sunset time """
        return "%s: %s" % (utf8(_("Sunset")), TimeFormatter.format_time(self.__sunset_t))


class indicator_weather(threading.Thread):
    """ Indicator class """
    last_update_time = None

    # Settings values
    # Formats: setting value, object name (for preferences dialog), value assigned (optional)
    metric_systems = { 'S': ('si',       UnitSystem.SI),
                       'I': ('imperial', UnitSystem.IMPERIAL)}

    weather_sources = { 'Y': ('yahoo',  WeatherDataSource.YAHOO),
                        'W': ('weather-com', WeatherDataSource.WEATHER_COM)}

    notifications = {'N': 'nonotif',
                     'O': 'notifsevere',
                     'A': 'notifall'}

    wind_systems = {'mps':      ("mps",      WindUnits.MPS),
                    'mph':      ("mph",      WindUnits.MPH),
                    'kph':      ("kph",      WindUnits.KPH),
                    'beaufort': ("beaufort", WindUnits.BEAUFORT),
                    'knots':    ("knots",    WindUnits.KNOTS)}

    heat_estimates = {'heatindex': ("heatindex", RelativeFormula.HEATINDEX),
                      'humidex':   ("humidex",   RelativeFormula.HUMIDEX)}
    
    chill_estimates = {'windchill': ("wctindex", RelativeFormula.WINDCHILL),
                       'apparent':  ("aatindex", RelativeFormula.APPARENT)}
    
    def __init__(self):
        """ Initializing and reading previously-saved settings """
        log.debug("Indicator: creating")
        threading.Thread.__init__(self)
        self.main_icon = os.path.join
        self.winder = AppIndicator.Indicator.new("indicator-weather", "weather-indicator", AppIndicator.IndicatorCategory.OTHER)
        
        self.queue = Queue.Queue()
        
        self.menu_update_lock = threading.Lock()
        self.status_update_lock = threading.Lock()

        self.status_update_lock.acquire(True)
        self.winder.set_status(AppIndicator.IndicatorStatus.ACTIVE)
        self.winder.set_attention_icon("weather-indicator-error")
        self.status_update_lock.release()
        
        self.refreshed_minutes_ago = -1
        self.places_changed = False
        monitor_upower(self.on_system_sleep, self.on_system_resume, log)

        log.debug("Indicator: reading settings")
        self.settings = Settings()
        #self.settings.check_autostart()
        self.settings.prepare_settings_store()
        self.rate  = self.settings.get_value("refresh_rate")
        self.unit  = self.settings.get_value("unit")
        self.notif = self.settings.get_value("notif")
        self.wind  = self.settings.get_value("wind")
        self.heat = self.settings.get_value("heat")
        self.chill = self.settings.get_value("chill")
        self.source = self.settings.get_value("data_source")
        self.placechosen = self.settings.get_value("placechosen")
        self.places = utf8(self.settings.get_value("places"))
        self.show_label = self.settings.get_value("show_label")
        self.show_relative = self.settings.get_value("show_relative")
        self.show_wind = self.settings.get_value("show_wind")
        self.show_suntimes = self.settings.get_value("show_suntimes")
        
        log.debug("Preferences: got settings: rate=%s, unit=%s, notif=%s, "
                  "wind=%s, placechosen=%s, places=%s, heat=%s, chill=%s" %
                  (self.rate, self.unit, self.notif, self.wind, 
                   self.placechosen, self.places, self.heat, self.chill))

        #Setting default values
        self.metric_system = UnitSystem.SI
        self.wind_unit = WindUnits.MPH
        self.place = None
        self.menu = None
        self.condition = None
        self.icon = None
        self.heat_index = RelativeFormula.HUMIDEX
        self.chill_index = RelativeFormula.WINDCHILL
        
        #Parsing settings
        # Metric system
        if self.unit in (False, None):
            default_value = 'S'
            log.debug("Indicator: could not parse unit, "
                      "setting to %s" % default_value)
            self.settings.set_value("unit", default_value)
            self.unit = default_value
        self.metric_system = self.metric_systems[self.unit][1]

        # Notification
        if self.notif in (False, None):
            default_value = 'N'
            log.debug("Indicator: could not parse notif, "
                      "setting to %s" % default_value)
            self.settings.set_value("notif", default_value)
            self.notif = default_value
        Notify.init("weather-indicator")    
        
        # Wind units
        if self.wind in (False, None):
            default_value = 'mph'
            log.debug("Indicator: could not parse wind, "
                      "setting to %s" % default_value)
            self.settings.set_value("wind", default_value)
            self.wind = default_value
        self.wind_unit = self.wind_systems[self.wind][1]

        # Heat estimate formula
        if self.heat in (False, None):
            default_value = 'humidex'
            log.debug("Indicator: could not parse heat, "
                      "setting to %s" % default_value)
            self.settings.set_value("heat", default_value)
            self.heat = default_value
        self.heat_index = self.heat_estimates[self.heat][1]
            
        # Chill estimate formula
        if self.chill in (False, None):
            default_value = 'windchill'
            log.debug("Indicator: could not parse chill, "
                      "setting to %s" % default_value)
            self.settings.set_value("chill", default_value)
            self.chill = default_value
        self.chill_index = self.chill_estimates[self.chill][1]

        # Show label in indicator?
        if self.show_label == 1:
            self.show_label = True
            self.label_guide = "100 ˚C"    # Guide for width of label
        else:
            self.show_label = False
            self.label_guide = " "

        # Show relative temperature in dropdown?
        if self.show_relative == 1:
            self.show_relative = True
        else:
            self.show_relative = False
            
        # Show windspeed & direction in dropdown?
        if self.show_wind == 1:
            self.show_wind = True
        else:
            self.show_wind = False
            
        # Show sunrise & sunset times in dropdown?
        if self.show_suntimes == 1:
            self.show_suntimes = True
        else:
            self.show_suntimes = False
            
        # Weather source
        if self.source in (False, None, 'G'):   # If set to Google, reset it
            default_value = 'Y'
            log.debug("Indicator: could not parse data source, "
                      "setting to %s" % default_value)
            self.settings.set_value("data_source", default_value)
            self.source = default_value
        self.weather_source = self.weather_sources[self.source][1]

        # Rate
        if self.rate in (False, None):
            default_value = 15
            log.debug("Indicator: could not parse rate, "
                      "setting to %s" % str(default_value))
            self.settings.set_value("refresh_rate", default_value)
            self.rate = default_value

        # Place chosen
        if self.placechosen == None:
            log.debug("Indicator: could not parse placechosen, setting to 0")
            self.settings.set_value("placechosen", 0)
            self.placechosen = 0
        else:
            self.placechosen = int(self.placechosen)

        # Places list
        self.menu_update_lock.acquire(True)
        if self.places in (False, None, '', '[]', "['']"):
            log.debug("Indicator: could not parse places")
            self.menu_noplace()
            self.menu_update_lock.release()
        else:
            self.places = eval(self.places)
            if self.placechosen >= len(self.places):
                self.placechosen = 0
            self.place = self.places[self.placechosen]
            self.location_details = self.settings.get_location_details(self.place[0])
            if self.location_details in (False, None, '', '[]', "['']"):
                log.debug("Indicator: could not parse current location details")
                self.menu_noplace()
                self.menu_update_lock.release()
            else:
                self.location_details = eval(self.location_details)
##                self.menu_normal()
                self.menu_update_lock.release()
                self.update_weather()

    def update_label(self, label):
        """ Set the label of the indicator """
        if (hasattr(self.winder, 'set_label')):
            log.debug(u"Indicator: update_label: setting label to '%s'" % label)
            self.previous_label_value = label
            self.status_update_lock.acquire(True)
            self.winder.set_label(label, self.label_guide) if self.show_label else self.winder.set_label(" ", " ")
            self.winder.set_status(AppIndicator.IndicatorStatus.ATTENTION)
            self.winder.set_status(AppIndicator.IndicatorStatus.ACTIVE)
            self.status_update_lock.release()

    def menu_noplace(self):
        """ Show a menu if no places specified """
        log.debug("Indicator: making a menu for no places")
        menu_noplace = Gtk.Menu()

        setup = Gtk.MenuItem(_("Set Up Weather..."))
        setup.connect("activate", self.prefs)
        setup.show()
        menu_noplace.append(setup)

        quit = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_QUIT, None)
        quit.connect("activate", self.quit)
        quit.show()
        menu_noplace.append(quit)

        self.status_update_lock.acquire(True)
        self.winder.set_menu(menu_noplace)
        self.winder.set_icon(os.path.join(PROJECT_ROOT_DIRECTORY, "share/indicator-weather/media/icon.png"))
        self.winder.set_status(AppIndicator.IndicatorStatus.ATTENTION)
        self.winder.set_status(AppIndicator.IndicatorStatus.ACTIVE)
        self.status_update_lock.release()
                
    def menu_normal(self):
        """ Show a menu with weather and location data """
        log.debug("Indicator: menu_normal: filling in a menu for found places")
                    
        self.menu = Gtk.Menu()

    ##City
        self.city_show = Gtk.MenuItem()
        self.city_show.set_sensitive(True)
        self.menu.append(self.city_show)
        self.city_show.show()

    ##Condition
        self.cond_show = Gtk.MenuItem()
        self.cond_show.set_sensitive(True)
        self.cond_show.show()
        self.menu.append(self.cond_show)

    ##Temperature
        self.temp_show = Gtk.MenuItem()
        self.temp_show.set_sensitive(True)
        self.temp_show.show()
        self.menu.append(self.temp_show)

    ##Relative Temperature
        self.relative_show = Gtk.MenuItem()
        self.relative_show.set_sensitive(True)
        self.relative_show.show()
        self.menu.append(self.relative_show)

    ##Humidity
        self.humid_show = Gtk.MenuItem()
        self.humid_show.set_sensitive(True)
        self.humid_show.show()
        self.menu.append(self.humid_show)

    ##Wind
        self.wind_show = Gtk.MenuItem()
        self.wind_show.set_sensitive(True)
        self.wind_show.show()
        self.menu.append(self.wind_show)

    ##Sunrise
        self.sunrise_show = Gtk.MenuItem()
        self.sunrise_show.set_sensitive(True)
        self.sunrise_show.show()
        self.menu.append(self.sunrise_show)

    ##Sunset
        self.sunset_show = Gtk.MenuItem()
        self.sunset_show.set_sensitive(True)
        self.sunset_show.show()
        self.menu.append(self.sunset_show)

    ##Cities
        if len(self.places) != 1:
            ##Breaker
            breaker = Gtk.SeparatorMenuItem()
            breaker.show()
            self.menu.append(breaker)

            log.debug("Indicator: menu_normal: adding first location menu item '%s'" % self.places[0][1])
            loco1 = Gtk.RadioMenuItem.new_with_label([], self.places[0][1])
            if self.placechosen == 0:
                loco1.set_active(True)
            loco1.connect("toggled", self.on_city_changed)
            loco1.show()
            self.menu.append(loco1)
            group = loco1.get_group()
            for place in self.places[1:]:
                log.debug("Indicator: menu_normal: adding location menu item '%s'" % place[1])
                loco = Gtk.RadioMenuItem.new_with_label(group, place[1])
                if self.places.index(place) == self.placechosen:
                    loco.set_active(True)
                loco.connect("toggled", self.on_city_changed)
                loco.show()
                self.menu.append(loco)
                group = loco.get_group()

    ##Breaker
        breaker = Gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)

        self.refresh_show = Gtk.MenuItem()
        #label will be set later
        self.refresh_show.connect("activate", self.update_weather)
        self.refresh_show.show()
        self.menu.append(self.refresh_show)

        ext_show = Gtk.MenuItem(_("Forecast"))
        ext_show.connect("activate", self.extforecast)
        ext_show.show()
        self.menu.append(ext_show)

    ##Preferences
        prefs_show = Gtk.MenuItem(_("Preferences..."))
        prefs_show.connect("activate", self.prefs)
        prefs_show.show()
        self.menu.append(prefs_show)

    ##About
        about_show = Gtk.MenuItem(_("About..."))
        about_show.connect("activate", self.about)
        about_show.show()
        self.menu.append(about_show)

    ##Quit
        quit = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_QUIT, None)
        quit.connect("activate", self.quit)
        quit.show()
        self.menu.append(quit)

        self.winder.set_menu(self.menu)
        self.update_label(" ")
                

    def on_city_changed(self,widget):
        """ Another city has been selected from radiobutton """
        if widget.get_active():
            for place in self.places:
                if (place[1] == widget.get_label()):
                    log.debug("Indicator: new location selected: %s" % self.places.index(place))
                    self.placechosen = self.places.index(place)
                    break

            if self.placechosen >= len(self.places):
                self.placechosen = 0
            self.place = self.places[self.placechosen]
            self.location_details = self.settings.get_location_details(self.place[0])
            if self.location_details in (False, None, '', '[]', "['']"):
                log.debug("Indicator: could not parse location details for placechosen='%s'" % self.placechosen)
                self.menu_update_lock.acquire(True)                
                self.menu_noplace()
                self.menu_update_lock.release()
            else:
                self.location_details = eval(self.location_details)
            self.settings.set_value("placechosen", self.placechosen)
            self.update_weather(False)

    def on_system_sleep(self):
        """Callback from UPower that system suspends/hibernates
        
        """
        # store time
        self.sleep_time = datetime.datetime.now()
        log.debug("Indicator: system goes to sleep at %s" % self.sleep_time)
        # remove gobject timeouts
        if hasattr(self, "refresh_id"):
            GObject.source_remove(self.refresh_id)
        if hasattr(self, "rate_id"):
            GObject.source_remove(self.rate_id)

    def on_system_resume(self):
        """Callback from UPower that system resumes
        
        """
        now = datetime.datetime.now()
        log.debug("Indicator: system resumes at %s" % now)
        # if we have places set
        if isinstance(self.places, types.ListType) and len(self.places)>0:
            td = now - self.sleep_time
            mins_elapsed = td.days/24*60 + td.seconds/60
            # update refresh label
            if self.refreshed_minutes_ago >= 0:
                mins_elapsed += self.refreshed_minutes_ago
                self.update_refresh_label(mins_elapsed)
            # check if we need to update the weather now or to reschedule the update
            min_diff = int(self.rate) - mins_elapsed
            if min_diff > 0:
                self.schedule_weather_update(min_diff)
            else:
                self.update_weather()

    def schedule_weather_update(self, rate_override = None):
        """ Schedule the next weather update """
        if hasattr(self, "rate_id"):
            GObject.source_remove(self.rate_id)
        if rate_override:
            self.rate_id = GObject.timeout_add(
##                int(rate_override) * 60000, self.update_weather)
                int(rate_override * 60000), self.update_weather)
        else:
            self.rate_id = GObject.timeout_add(
                int(self.rate) * 60000, self.update_weather)

    def schedule_refresh_label_update(self):
        """ Schedule the next 'Refresh' label update """
        if hasattr(self, "refresh_id"):
            GObject.source_remove(self.refresh_id)
        self.refresh_id = GObject.timeout_add(60000, self.update_refresh_label)

    def update_refresh_label(self, reset_minutes = None):
        """ Update 'Refresh' label with time since last successful data refresh """
        if reset_minutes is not None:
            self.refreshed_minutes_ago = reset_minutes
        else:
            self.refreshed_minutes_ago += 1
        self.set_refresh_label()
        self.schedule_refresh_label_update()
        return False

    def set_refresh_label(self, refreshing=False):
        """ Update the 'Refresh' label text """
        if refreshing:
            refresh_label=_("Refreshing, please wait")
        elif self.refreshed_minutes_ago < 0:
            refresh_label=_("Refresh")
        elif self.refreshed_minutes_ago == 0:
            refresh_label="%s (%s)" % (_("Refresh"), _("just now"))
        else:
            refresh_label = "%s (%s)" % (_("Refresh"), _("%d min. ago") % self.refreshed_minutes_ago)
        self.refresh_show.set_label(refresh_label)

    def get_cached_weather(self, queue):
        """ Load weather data from cache and put it onto the queue """
        try:
            log.debug("Indicator: get_cached_weather: setting "
                      "previous_condition to None")
            self.previous_condition = None
            cached_weather = self.settings.get_weather(self.places[self.placechosen][0])
            if cached_weather is not None:
                cached_weather = eval(cached_weather)
                log.debug("Indicator: loading weather from cache "
                          "for %s" % self.places[self.placechosen])
            # Put the cached weather onto to the Queue
            queue.put({'cached_weather': cached_weather})
        except Exception, e:
            log.error(e)
            log.debug(traceback.format_exc(e))

    def show_cached_weather(self, cached_weather):
        """ Update the indicator icon, label and menu with cached weather data """
        if cached_weather is None:
            # No cached weather exists
            log.debug("Indicator: show_cached_weather: no cached data exists "
                      "for %s" % self.location_details[0])
            return
        
        try:
            self.menu_normal()
            self.set_refresh_label(True)
            self.icon = cached_weather['icon']
            if (self.icon == False):
                self.winder.set_icon(
                    os.path.join(PROJECT_ROOT_DIRECTORY,
                    "share/indicator-weather/media/icon_unknown_condition.png")
                )
            else:
                self.winder.set_icon(self.icon)
    
            self.city_show.set_label(self.places[self.placechosen][1])
            self.previous_condition = cached_weather['condition']
            self.cond_show.set_label(cached_weather['condition'])
            self.temp_show.set_label(cached_weather['temper'])
            # workaround for old cached data without 'feelslike' entry
            if (self.show_relative and 'feelslike' in cached_weather and
                                       cached_weather['feelslike'] != None):
                self.relative_show.set_visible(True)
                self.relative_show.set_label(cached_weather['feelslike'])
            else:
                self.relative_show.set_visible(False)
            self.humid_show.set_label(cached_weather['humidity'])
            if self.show_wind:
                self.wind_show.set_visible(True)
                self.wind_show.set_label(cached_weather['wind'])
            else:
                self.wind_show.set_visible(False)
            if self.show_suntimes:
                self.sunrise_show.set_visible(True)
                self.sunrise_show.set_label(cached_weather['sunrise'])
                self.sunset_show.set_visible(True)
                self.sunset_show.set_label(cached_weather['sunset'])
            else:
                self.sunrise_show.set_visible(False)
                self.sunset_show.set_visible(False)

            self.update_label(cached_weather['label'])
                        
        except Exception, e:
            log.error(e)
            log.debug(traceback.format_exc(e))

    def get_new_weather_data(self, notif, queue):
        """ Get fresh weather data from source and put it onto the queue """
        # get weather and catch any exception
        weather = None
        try:
            weather = self.get_weather()
        except urllib2.URLError, e:
            weather = None
            log.error("Indicator: networking error: %s" % e)
        except Exception, e:
            weather = None
            log.error(e)
            log.debug(traceback.format_exc(e))
        # Put the new weather data onto the Queue
        queue.put({'weather': weather})

    def show_new_weather_data(self, weather):
        """ Update the indicator icon, label and menu with new weather data """
        try:
            if weather is None:
                # remove the "Refreshing" status
                self.set_refresh_label()
                # No data returned - leave cached data to be displayed
                log.error("Indicator: updateWeather: could not get weather, leaving cached data")
                # Repeat an attempt in one minute
                self.schedule_weather_update(1)
                return
            
            # Fill in menu with data
            self.condition = weather.get_condition_label()
            self.icon = weather.get_icon_name()
            log.debug(u"Indicator: updateWeather: got condition '%s', icon '%s'" % (self.condition, self.icon))
            log.debug(
                u"Indicator: fill in menu with params: " \
                u"city='%s', temp='%s', humid='%s', wind='%s', " \
                u"sunrise='%s', sunset='%s', puretemp=%s" % 
                (utf8(self.places[self.placechosen][1]),
                weather.get_temperature_label(), weather.get_humidity_label(),
                weather.get_wind_label(), weather.get_sunrise_label(),
                weather.get_sunset_label(),
                weather.get_temperature_string())
                )
            self.menu_normal()
            self.update_refresh_label(0)
            self.city_show.set_label(self.places[self.placechosen][1])
            self.cond_show.set_label(self.condition)
            self.temp_show.set_label(weather.get_temperature_label())
            _relative_label = weather.get_relative_label()
            if (self.show_relative and "---" not in _relative_label):
                self.relative_show.set_visible(True)
                self.relative_show.set_label(_relative_label)
            else:
                self.relative_show.set_visible(False)
            self.humid_show.set_label(weather.get_humidity_label())
            if self.show_wind:
                self.wind_show.set_visible(True)
                self.wind_show.set_label(weather.get_wind_label())
            else:
                self.wind_show.set_visible(False)
            if self.show_suntimes:
                self.sunrise_show.set_visible(True)
                self.sunrise_show.set_label(weather.get_sunrise_label())
                self.sunset_show.set_visible(True)
                self.sunset_show.set_label(weather.get_sunset_label())
            else:
                self.sunrise_show.set_visible(False)
                self.sunset_show.set_visible(False)
    
            # Save cached data if correct icon is supplied
            if (self.icon == False):
                self.winder.set_icon(
                    os.path.join(PROJECT_ROOT_DIRECTORY,
                    "share/indicator-weather/media/icon_unknown_condition.png")
                )
            else:
                self.winder.set_icon(self.icon)
                self.settings.save_weather(weather, self.places[self.placechosen][0])
            # Update the indicator label
            self.update_label(weather.get_temperature_string())
    
            # Notify user, if notifications are enabled
            if self.condition != self.previous_condition:
                if weather.condition_is_severe() and \
                   (self.notif == 'O' or self.notif == 'A') :
                    # Severe weather condition notification
                    log.debug("Indicator: updateWeather: severe condition notification")
                    self.notify(self.condition, self.icon, severe=True)
                elif self.notif == 'A':
                    # Weather condition has changed
                    log.debug("Indicator: updateWeather: weather has changed, notify")
                    self.notify(self.condition, self.icon)
                # Save the current condition to track changes for notifications
                self.previous_condition = self.condition
        except Exception, e:
            log.error(e)
            log.debug(traceback.format_exc(e))

        # Schedule the next weather fetch    
        self.schedule_weather_update()
        
    def update_weather(self, notif=True, widget=None):
        """ Update the displayed weather data from cache and fetch new data """
        log.debug("Indicator: updateWeather: updating weather for %s" %
                  self.places[self.placechosen])
        # First, display cached data
        cache_thread = threading.Thread(target=self.get_cached_weather,
                                                name='Cache', args=(self.queue,))
        cache_thread.start()
        
        # Then, start a new thread with real data pickup
        fetcher_thread = threading.Thread(target=self.get_new_weather_data,
                                          name='Fetcher',
                                          args=(self.notif, self.queue))
        fetcher_thread.start()

        # Update the menu with the cached weather
        cache_thread.join()
        cached_weather = self.queue.get()
        if cached_weather is not None and 'cached_weather' in cached_weather:
            self.show_cached_weather(cached_weather['cached_weather'])        

        # Update the menu with the new weather
        fetcher_thread.join()
        weather = self.queue.get()
        if weather is not None and 'weather' in weather:
            self.show_new_weather_data(weather['weather'])

    def get_weather(self):
        """ Get current weather for selected location """
        log.debug("Indicator: getWeather for location '%s'" %
                  self.location_details['full name'])
        self.current_location = Location(self.metric_system, self.wind_unit,
                                         self.heat_index, self.chill_index,
                                         self.location_details)
        log.debug("Indicator: getWeather: updating weather report")
        self.current_location.update_weather_data(self.weather_source)
        return self.current_location.weather

    def notify(self, condition, icon, severe=False):
        """ Show notification to user according to preferences """
        log.debug("Indicator: Notify on weather condition, severe=%s, "
                  "condition=%s, icon=%s" % (severe, condition, icon))
        if severe:
            n = Notify.Notification.new(_("Severe weather alert"),
                                       condition,
                                       icon)
        else:
            n = Notify.Notification.new(condition, "", icon)
        n.show()

    def prefs(self, widget):
        """ Menu callback to open Preferences dialog """
        log.debug("Indicator: open Preferences")
        if ((not hasattr(self, 'prefswindow')) or (not self.prefswindow.get_visible())):
            self.prefswindow = PreferencesDialog()
            self.prefswindow.show()
    
    def about(self, widget):
        """ Menu callback to open About dialog """
        log.debug("Indicator: open About dialog")
        self.aboutdialog = Gtk.AboutDialog()
        self.aboutdialog.set_name(_("Weather Indicator"))
        self.aboutdialog.set_version(VERSION)

        ifile = open(os.path.join(PROJECT_ROOT_DIRECTORY,
                                  "share/doc/indicator-weather/AUTHORS"), "r")
        self.aboutdialog.set_copyright(ifile.read().replace('\x0c', ''))
        ifile.close()

        ifile = open(os.path.join(PROJECT_ROOT_DIRECTORY,
                                  "share/common-licenses/GPL-3"), "r")
        self.aboutdialog.set_license(ifile.read().replace('\x0c', ''))
        ifile.close()

        self.aboutdialog.set_website("https://launchpad.net/weather-indicator")
        self.aboutdialog.set_translator_credits(_("translator-credits"))
        logo_path = os.path.join(PROJECT_ROOT_DIRECTORY,
                                 "share/indicator-weather/media/icon.png")
        self.aboutdialog.set_logo(GdkPixbuf.Pixbuf.new_from_file(logo_path))

        self.aboutdialog.connect("response", self.about_close)
        self.aboutdialog.show()

    def about_close(self, widget, event=None):
        """ Menu callback to close About dialog """
        log.debug("Indicator: closing About dialog")
        self.aboutdialog.destroy()

    def extforecast(self, widget):
        """ Menu callback to open Extended forecast window """
        log.debug("Indicator: open Forecast")
        if ((not hasattr(self, 'forecastwd')) or \
            (not self.forecastwd.get_visible())):
                self.forecastwd = ExtendedForecast()
                self.forecastwd.show()

    def quit(self, widget, data=None):
        """ Menu callback to quit the indicator applet """
        log.debug("Indicator: Quitting")
        Gtk.main_quit()

class PreferencesDialog(Gtk.Dialog):
    """ Class for preferences dialog """
    __gtype_name__ = "PreferencesDialog"

    def __new__(cls):
        """ Creating a new preferences dialog """
        log.debug("Preferences: creating")
        builder = get_builder('PreferencesDialog')
        new_object = builder.get_object("preferences_dialog")
        new_object.finish_initializing(builder)
        return new_object

    def finish_initializing(self, builder):
        """ Fill in preferences dialog with correct data """
        log.debug("Preferences: finishing initialization")
        log.debug("Preferences: got settings: unit=%s, notif=%s, wind=%s, "
                  "rate=%s, source=%s, heat=%s, chill=%s" %
                  (wi.unit, wi.notif, wi.wind, wi.rate, wi.source,
                   wi.heat, wi.chill))
        self.builder = builder

        # Set correct wind_unit using dictionary of wind value and object name
        self.builder.get_object(wi.metric_systems[wi.unit][0]).set_active(True)
        self.builder.get_object(wi.notifications[wi.notif]).set_active(True)
        self.builder.get_object(wi.wind_systems[wi.wind][0]).set_active(True)
        self.builder.get_object(wi.weather_sources[wi.source][0]).set_active(True)
        self.builder.get_object('show_label').set_active(wi.show_label)
        self.builder.get_object('show_label').set_visible(hasattr(wi.winder, 'set_label'))
        self.builder.get_object('rate').set_value(float(wi.rate))
        self.builder.get_object(wi.heat_estimates[wi.heat][0]).set_active(True)
        self.builder.get_object(wi.chill_estimates[wi.chill][0]).set_active(True)
        self.builder.get_object('show_relative').set_active(wi.show_relative)
        self.builder.get_object('show_wind').set_active(wi.show_wind)
        self.builder.get_object('show_suntimes').set_active(wi.show_suntimes)

        log.debug("Preferences: Loading places")
        if wi.places != None:
            for place in wi.places:
                if len(place)>1 and place[0] is not None:
                    log.debug("Preferences: Places: got (%s, %s)" % (place[1], place[0]))
                    newplace = list()
                    newplace.append(place[1])
                    newplace.append(place[0])
                    newplace.append(wi.settings.get_location_details(place[0]))

                    self.builder.get_object('citieslist').append(newplace)
                    self.builder.get_object('ok_button').set_sensitive(True)

        self.builder.connect_signals(self)

    def on_remove_location(self, widget):
        """ 'Remove' clicked - remove location from list """
        selection = self.builder.get_object('location_list').get_selection()
        model, iter = selection.get_selected()
        if iter != None:
            log.debug("Preferences: Removing location %s (code %s)" % 
                      (model[iter][0], model[iter][1]))
            newplaces = []
            for place in wi.places:
                if place[1] != model[iter][0] and \
                   place[0] != model[iter][1]:
                    newplaces.append(place) 
            if newplaces != wi.places:                
                wi.places = newplaces
                log.debug("Preferences: update settings object")
                wi.settings.set_value("places", utf8(wi.places))
           
            model.remove(iter)
            wi.places_changed = True
            
        if (self.builder.get_object('citieslist').get_iter_first() == None):
            self.builder.get_object('ok_button').set_sensitive(False)
        
    def on_add_location(self, widget):
        """ 'Add' clicked - create a new Assistant """
        log.debug("Preferences: Add location clicked")
        if ((not hasattr(self, 'assistant')) or (not self.assistant.get_visible())):
            self.assistant = Assistant()
            self.assistant.show()

    def ok(self, widget, data=None):
        """ 'OK' clicked - save settings """
        log.debug("Preferences: Saving settings")
        need_to_update_weather = False
        need_to_update_indicator = False

        # Show label near icon
        new_show_label = self.builder.get_object('show_label').get_active()
        if (wi.show_label != new_show_label):
            wi.show_label = new_show_label
            wi.settings.set_value("show_label", new_show_label)
            need_to_update_weather = False
            need_to_update_indicator = True
            log.debug("Preferences: Show Label changed to '%s'" % wi.show_label)

        # Show relative temperature
        new_show_relative = self.builder.get_object('show_relative').get_active()
        if (wi.show_relative != new_show_relative):
            wi.show_relative = new_show_relative
            wi.settings.set_value("show_relative", new_show_relative)
            need_to_update_weather = True
            log.debug("PreferencesDialog: Show Relative Temp changed to %s" % wi.show_relative)
            
        # Show wind speed & direction
        new_show_wind = self.builder.get_object('show_wind').get_active()
        if (wi.show_wind != new_show_wind):
            wi.show_wind = new_show_wind
            wi.settings.set_value("show_wind", new_show_wind)
            need_to_update_weather = True
            log.debug("PreferencesDialog: Show Wind Data changed to %s" % wi.show_wind)
        
        # Show sunrise & sunset times
        new_show_suntimes = self.builder.get_object('show_suntimes').get_active()
        if (wi.show_suntimes != new_show_suntimes):
            wi.show_suntimes = new_show_suntimes
            wi.settings.set_value("show_suntimes", new_show_suntimes)
            need_to_update_weather = True
            log.debug("PreferencesDialog: Show Sunrise/Sunset Times changed to %s" % wi.show_suntimes)
        
        # Metric systems
        for k in wi.metric_systems.keys():
            if self.builder.get_object(wi.metric_systems[k][0]).get_active():
                new_unit = k
                new_metric_system = wi.metric_systems[k][1]

        if (wi.unit != new_unit):
            wi.unit = new_unit
            wi.metric_system = new_metric_system
            wi.settings.set_value("unit", wi.unit)
            need_to_update_weather = True
            log.debug("Preferences: Unit changed to '%s'" % wi.unit)

        # Notifications
        for k in wi.notifications.keys():
            if self.builder.get_object(wi.notifications[k]).get_active():
                new_notification  = k

        if (wi.notif != new_notification):
            wi.notif = new_notification
            wi.settings.set_value("notif", wi.notif)
            need_to_update_weather = True
            log.debug("Preferences: Notifications changed to '%s'" % wi.notif)

        # Wind Units
        for k in wi.wind_systems.keys():
            if self.builder.get_object(wi.wind_systems[k][0]).get_active():
                new_wind_unit   = k
                new_wind_system = wi.wind_systems[k][1]

        if (wi.wind != new_wind_unit):
            wi.wind = new_wind_unit
            wi.wind_unit = new_wind_system
            wi.settings.set_value("wind", wi.wind)
            need_to_update_weather = True
            log.debug("Preferences: Wind Unit changed to '%s'" % wi.wind)

        # Heat estimate formula
        for k in wi.heat_estimates.keys():
            if self.builder.get_object(wi.heat_estimates[k][0]).get_active():
                new_heat_index = k
                new_heat_estimate = wi.heat_estimates[k][1]

        if (wi.heat != new_heat_index):
            wi.heat = new_heat_index
            wi.heat_index = new_heat_estimate
            wi.settings.set_value("heat", wi.heat)
            need_to_update_weather = True
            log.debug("Preferences: Heat Estimate changed to '%s'" % wi.heat)

        # Chill estimate formula
        for k in wi.chill_estimates.keys():
            if self.builder.get_object(wi.chill_estimates[k][0]).get_active():
                new_chill_index = k
                new_chill_estimate = wi.chill_estimates[k][1]

        if (wi.chill != new_chill_index):
            wi.chill = new_chill_index
            wi.chill_index = new_chill_estimate
            wi.settings.set_value("chill", wi.chill)
            need_to_update_weather = True
            log.debug("Preferences: Chill Estimate changed to '%s'" % wi.chill)

        # Weather source
        for k in wi.weather_sources.keys():
            if self.builder.get_object(wi.weather_sources[k][0]).get_active():
                new_source   = k
                new_weather_source = wi.weather_sources[k][1]

        if (wi.source != new_source):
            wi.source = new_source
            wi.weather_source = new_weather_source
            wi.settings.set_value("data_source", wi.source)
            need_to_update_weather = True
            log.debug("Preferences: Weather Source changed to '%s'" % wi.source)

        # Rate
        if int(self.builder.get_object('rate').get_value()) != wi.rate:
            wi.settings.set_value("refresh_rate", int(self.builder.get_object('rate').get_value()))
            wi.rate = int(self.builder.get_object('rate').get_value())
            log.debug("Preferences: Rate changed to '%s'" % wi.rate)
            wi.schedule_weather_update()

        # Get places from location list
##        newplaces = list()
##        item = self.builder.get_object('citieslist').get_iter_first()
##        while (item != None):
##            newplace = list()
##            newplace.append(self.builder.get_object('citieslist').get_value (item, 1))
##            newplace.append(self.builder.get_object('citieslist').get_value (item, 0))
##            newplaces.append(newplace)
##            item = self.builder.get_object('citieslist').iter_next(item)

        # If places have changed - update weather data
##        if newplaces != wi.places:
##            wi.places = newplaces
        if wi.places_changed:
            log.debug("Preferences: Places changed to '%s'" % utf8(wi.places))
            wi.settings.set_value("places", utf8(wi.places))
            if (type(wi.place) != None) and (wi.place in wi.places):
                wi.placechosen = wi.places.index(wi.place)
            else:
                wi.placechosen = 0
                wi.place = wi.places[0]
            log.debug("Preferences: Place Chosen changed to '%s'" % wi.placechosen)
            wi.settings.set_value("placechosen", wi.placechosen)
            wi.location_details = eval(wi.settings.get_location_details(wi.place[0]))
##            wi.menu_normal()
##            wi.set_refresh_label()
            need_to_update_weather = True
            wi.places_changed = False

        if need_to_update_weather:
####            wi.update_weather(False)
            wi.schedule_weather_update(0.003)

        if need_to_update_indicator:
            wi.update_label(wi.previous_label_value)

        self.destroy()

    def cancel(self, widget, data=None):
        """ 'Cancel' clicked - forget all changes """
        log.debug("Preferences: Cancelling")
        self.destroy()

class ExtendedForecast(Gtk.Window):
    """ Class for forecast window """
    __gtype_name__ = "ExtendedForecast"

    def __new__(cls):
        """ Create forecast """
        log.debug("ExtendedForecast: creating")
        builder = get_builder('ExtendedForecast')
        new_object = builder.get_object("extended_forecast")
        new_object.finish_initializing(builder)
        return new_object

    def finish_initializing(self, builder):
        """ Fill in forecast parameters """
        log.debug("ExtendedForecast: finishing initialization")
        self.builder = builder
        self.builder.connect_signals(self)

        # Get forecast data using Forecast object
        log.debug("ExtendedForecast: chosen place: %s (code %s)" %
                  (wi.places[wi.placechosen][1], wi.places[wi.placechosen][0]))
        self.builder.get_object('extended_forecast').set_title("%s %s" %
                    (_('Weather Forecast for'), wi.places[wi.placechosen][1]))
        log.debug("ExtendedForecast: getting forecast data")
        forecast = Forecast(wi.metric_system,
                            wi.current_location.location_details['yahoo id'],
                            locale_name)
        forecast.prepare_forecast_data()
        if forecast.error_message != None:
            # Error occurred while getting forecast data
            self.builder.get_object('connection_error').set_text("%s" %
                                                    forecast.error_message)
            self.builder.get_object('connection_error').set_visible(True)
            self.builder.get_object('hbox1').set_visible(False)
        else:
            daysofweek = forecast.get_forecast_daysofweek()
            forecast_data = forecast.get_forecast_data()
            if forecast_data == None:
                # Forecast data unavailable - hide elements
                # and show 'connection_error' label
                self.builder.get_object('connection_error').set_visible(True)
                self.builder.get_object('hbox1').set_visible(False)
                self.builder.get_object('hseparator1').set_visible(False)
                return
            (highdata, lowdata) = forecast_data
            icons      = forecast.get_forecast_icons()
            conditions = forecast.get_forecast_conditions()

            log.debug("ExtendedForecast: parsing forecast data")
            # Create labels for each weekday
            for i in xrange(1,5):
                try:
                    lbl_name = 'day%slbl' % (i)
                    self.builder.get_object(lbl_name).set_label('<big>%s</big>' % 
                                                    daysofweek[i].capitalize())
                except IndexError:
                    log.error("ExtendedForecast: Yahoo didn't return "
                              "forecast for %s days" % i)
                    log.error(forecast.forecast)
            
            # Fill in icons
            for i in xrange(1,5):
                # Get icon name from dictionary in Weather object
                # for Yahoo condition codes
                try:
                    conds = Weather._YahooConditions.get(icons[i])
                    if conds != None:
                        yahoo_icon = conds[0]
                    else:
                        log.error("ExtendedForecast: unknown Yahoo weather "
                                  "condition code '%s'" % icons[i])
                        log.error(forecast.forecast)
                        yahoo_icon = 'weather-indicator-unknown'
                    self.builder.get_object('day%simage' % 
                            str(i)).set_from_icon_name(yahoo_icon,
                                                       Gtk.IconSize.BUTTON)
                except IndexError:
                    log.error("ExtendedForecast: Yahoo didn't return "
                              "condition for %s days" % i)
                    log.error(forecast.forecast)

            # Fill in condition labels
            for i in xrange(1,5):
                if conditions[i] != '':
                    condition = conditions[i]
                else:
                    condition = _("Unknown condition")
                self.builder.get_object('day%scond' %
                                        str(i)).set_label(condition)

            # Fill in High and Low temperatures
            if wi.metric_system == UnitSystem.SI:
                tempunit = u"°C"
            else:
                tempunit = u"°F"
            for i in xrange(1,5):
                label = "%s: %s%s" % (_('High'), highdata[i],tempunit)
                self.builder.get_object('day%stemphigh' % 
                                        str(i)).set_label(label)
                label = "%s: %s%s" % (_('Low'), lowdata[i],tempunit)
                self.builder.get_object('day%stemplow' % 
                                        str(i)).set_label(label)

    def close(self, widget, data=None):
        """ 'Close' clicked - close forecast window """
        log.debug("ExtendedForecast: closing window")
        self.destroy()

    def on_destroy(self, widget):
        pass

class Assistant(Gtk.Assistant):
    """ Class for a wizard, which helps to add a new location in location list """
    __gtype_name__ = "Assistant"

    def __new__(cls):
        """ Create new object """
        log.debug("Assistant: creating new Assistance instance")
        builder = get_builder('Assistant')
        new_object = builder.get_object("assistant")
        new_object.finish_initializing(builder)
        return new_object

    def finish_initializing(self, builder):
        """ Finish UI initialization - prepare combobox """
        log.debug("Assistant: finishing initialization")
        self.builder = builder
        self.builder.connect_signals(self)
        self.assistant = self.builder.get_object("assistant")
        self.assistant.set_page_complete(self.builder.get_object("label"),True)
        self.assistant.set_page_complete(self.builder.get_object("review"),True)

        # Set up combobox
        log.debug("Assistant: setting up location combobox")
        self.store = Gtk.ListStore(str, str, str, str, str)
        self.location_input_combo = self.builder.get_object("combolocations")
        self.location_input_combo.set_model(self.store)
        self.location_input_combo.set_entry_text_column(0)
        self.location_entry = self.builder.get_object("entrylocation")
        self.place_selected = None
        self.location = None

        self.assistant.set_forward_page_func(self.next_page, None)

    def on_get_city_names(self, widget):
        """ 'Get cities' button clicked - get suggested cities list """
        new_text = self.location_entry.get_text()
        log.debug("Assistant: looking for location '%s'" % new_text)
        try:
            # Clear up exising suggestions
            self.store.clear()
            # Get suggested city names from GeoNames DB in native locale
            new_text = urllib.quote(new_text)
            url = 'http://api.geonames.org/searchJSON?q=%s&featureClass=P&maxRows=10&lang=%s&username=indicatorweather' % (new_text, locale_name)
            cities = eval(urllib2.urlopen(url).read())
            for city in cities['geonames']:
                # Create a full city name, consisting of city name, administrative areas names and country name
                if 'adminName2' in city:
                    displayed_city_name = "%s, %s, %s, %s" % (
                        city['name'], city['adminName1'],
                        city['adminName1'], city['countryName']
                        )
                elif 'adminName1' in city:
                    displayed_city_name = "%s, %s, %s" % (
                        city['name'], city['adminName1'], city['countryName']
                        )
                else:
                    displayed_city_name = "%s, %s" % (city['name'], 
                                                      city['countryName'])
                self.store.append([displayed_city_name,
                                   str(city['geonameId']), str(city['lat']),
                                   str(city['lng']), str(city['name'])])
                self.location_input_combo.popup()
        except urllib2.URLError:
            log.error("Assistant: error reaching url '%s'" % url)

    def on_select_city(self, entry):
        """ A city is selected from suggested list """
        log.debug("Assistant: on_select city")      #DEBUG
        if self.location_input_combo.get_active() != -1:
            self.place_selected = self.store[self.location_input_combo.get_active()]
            self.assistant.set_page_complete(self.builder.get_object("placeinput"),True)
        else:
            self.place_selected = None
            self.location = None
            self.assistant.set_page_complete(self.builder.get_object("placeinput"), False)

    def next_page(self, current_page, data):
        """ Create a location object out of a selected location """
        log.debug("Assistant: moved to page %s" % current_page)
        if (self.assistant.get_current_page() == 0) and \
           not self.location and self.place_selected:
            # Label input page
            log.debug("Assistant: Page %s: got location with code %s" %
                      (current_page, self.place_selected[1]))
            self.location = Location(wi.metric_system, wi.wind_unit,
                                     wi.heat_index, wi.chill_index)
            if self.location.prepare_location(self.place_selected):
                log.debug("Assistant: Page %s: City %s found" % 
                          (current_page, self.place_selected[0]))
                # Set a short city name as default label
                self.builder.get_object("entrylbl").set_text(self.place_selected[4])
            else:
                # Error occurred while getting location data
                log.error("Assistant: Page %s: City %s with code %s was NOT "
                          "found" % (current_page, self.place_selected[0],
                                     self.place_selected[1]))
                log.debug("Assistant: Creating Error dialog")       #DEBUG
                md = Gtk.MessageDialog(
                    self.assistant, Gtk.DialogFlags.DESTROY_WITH_PARENT,
                    Gtk.MessageType.ERROR, Gtk.ButtonsType.CLOSE,
                    "%s '%s'" % (_("Could not find location id for"),
                               (self.place_selected[0])))
                md.format_secondary_text(
                    "Unknown error occurred while picking up location data. "
                    "Please try again later.")
                md.run()
                log.debug("Assistant: Error dialog closed")     #DEBUG
                self.location_entry.set_text('')
                self.place_selected = None
                self.location = None
                self.assistant.set_page_complete(self.builder.get_object("placeinput"), False)
                md.destroy()
                
                return 3
        elif self.assistant.get_current_page() == 1:
            # Confirmation page
            lbl = self.builder.get_object("entrylbl").get_text()
            log.debug("Assistant: Page %s: City label is %s" % 
                      (current_page, lbl))
            # If empty label was input, set label to short city name
            if lbl == '':
                log.debug("Assistant: Page %s: Empty label found, setting "
                          "lbl to short name - %s" % 
                          (current_page, self.place_selected[4]))
                lbl = self.place_selected[4]
                self.builder.get_object("entrylbl").set_text(lbl)
            # Update summary page
            self.location.location_details['label'] = lbl
            self.builder.get_object("lbl3").set_label(_('Label:'))
            self.builder.get_object("labellbl").set_label('<b>%s</b>' % lbl)
            self.builder.get_object("placelbl").set_label(
                '<b>%s</b>' % self.place_selected[0])

        return self.assistant.get_current_page() + 1

    def on_cancel(self,widget):
        """ 'Cancel' clicked """
        log.debug("Assistant: Cancelled")
        self.destroy()

    def on_apply(self,widget):
        """ 'Apply' clicked - save location details, add an entry in a location list """
        (location_code, location_details) = self.location.export_location_details()
        log.debug("Assistant: Apply: adding location ('%s', '%s')" %
                  (self.location.location_details['label'], location_code))
        newplace = list()
        newplace.append(self.location.location_details['label'])
        newplace.append(str(location_code))
        newplace.append(str(location_details))
        wi.settings.save_location_details(
            eval(str(location_details)), str(location_code)
            )
        wi.prefswindow.builder.get_object('citieslist').append(newplace)

        newplaces = list()
        item = wi.prefswindow.builder.get_object('citieslist').get_iter_first()
        while (item != None):
            newplace = list()
            newplace.append(wi.prefswindow.builder.get_object('citieslist').get_value(item, 1))
            newplace.append(wi.prefswindow.builder.get_object('citieslist').get_value(item, 0))
            newplaces.append(newplace)
            item = wi.prefswindow.builder.get_object('citieslist').iter_next(item)
        wi.places = newplaces
        wi.places_changed = True

        # Enable 'OK' button in Preferences
        wi.prefswindow.builder.get_object('ok_button').set_sensitive(True)
        self.hide()

class SingleInstance(object):
    """ Class to ensure, that single instance of the applet is run for each user """

    def __init__(self, pidPath):
        """ Initialize, specifying a path to store pids """
        self.pidPath=pidPath
        # See if pidFile exists
        if os.path.exists(pidPath):
            log.debug("SingleInstance: pid file %s exists" % pidPath)
            # Make sure it is not a "stale" pidFile
            pid=open(pidPath, 'r').read().strip()
            # Check list of running pids, if not running it is stale so overwrite
            pidRunning = commands.getoutput('ls -1 /proc | grep ^%s$' % pid)
            log.debug("SingleInstance: pid running %s" % pidRunning)
            self.lasterror = True if pidRunning else False
        else:
            self.lasterror = False

        if not self.lasterror:
            log.debug("SingleInstance: writing new pid %s" % str(os.getpid()))
            # Create a temp file, copy it to pidPath and remove temporary file
            (fp, temp_path)=tempfile.mkstemp()
            try:
                os.fdopen(fp, "w+b").write(str(os.getpid()))
                shutil.copy(temp_path, pidPath)
                os.unlink(temp_path)
            except Exception as e:
                log.error("SingleInstance: exception while renaming '%s' "
                          "to '%s':\n %s" % (temp_path, pidPath, str(e)))

    def is_already_running(self):
        return self.lasterror

    def __del__(self):
        if not self.lasterror:
            log.debug("SingleInstance: deleting %s" % self.pidPath)
            os.unlink(self.pidPath)

def main():
    Gtk.main()

    return 0

if __name__ == "__main__":
    #Enable and configure logs
    global log
    cachedir = os.environ.get('XDG_CACHE_HOME','').strip()
    if not cachedir:
        cachedir = os.path.expanduser("~/.cache")
    log_filename = os.path.join(cachedir, "indicator-weather.log")
    log = logging.getLogger('IndicatorWeather')
    log.propagate = False
    log.setLevel(logging.DEBUG)
    log_handler = logging.handlers.RotatingFileHandler(
        log_filename, maxBytes=1024*1024, backupCount=5)
    log_formatter = logging.Formatter("[%(threadName)s] %(asctime)s - "
                                      "%(levelname)s - %(message)s")
    log_handler.setFormatter(log_formatter)
    log.addHandler(log_handler)

    log.info("------------------------------")
    log.info("Started Weather Indicator from %s" % PROJECT_ROOT_DIRECTORY)
    log.info("Weather Indicator version %s" % VERSION)

    # Single instance stuff for weather indicator
    myapp = SingleInstance("/tmp/indicator-weather-%d.pid" % os.getuid())
    # check is another instance of same program running
    if myapp.is_already_running():
        log.info("Another instance of this program is already running")
        sys.exit(_("Another instance of this program is already running"))

    # Set http proxy support
    ProxyMonitor.monitor_proxy(log)
    # Use date-time format as in indicator-datetime
    TimeFormatter.monitor_indicator_datetime(log)

    # not running, safe to continue...

    # Remember locale name
    global locale_name
    locale_name = locale.getlocale()[0]
    if locale_name is not None:
        locale_name = locale_name.split('_')[0]
    else:
        locale.setlocale(locale.LC_ALL, 'C') # use default (C) locale
        locale_name = "en"

    # init GLib/GObject
    GObject.threads_init()

    # init Gdk threads and get Gdk lock
    Gdk.threads_init()
    Gdk.threads_enter()
    
    # init Gtk
    Gtk.init(None)

    # create main thread and enter main loop
    wi = indicator_weather()
    main()
    
    # release Gdk lock
    Gdk.threads_leave()   
