#!/usr/bin/python
# -*- coding: utf-8 -*-
### BEGIN LICENSE
# Copyright (C) 2010 Sebastian MacDonald Sebas310@gmail.com
# Copyright (C) 2010 Mehdi Rejraji mehd36@gmail.com
# This program is free software: you can redistribute it and/or modify it 
# under the terms of the GNU General Public License version 3, as published 
# by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranties of 
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
# PURPOSE.  See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along 
# with this program.  If not, see <http://www.gnu.org/licenses/>.
### END LICENSE

import sys
import os
import gtk
import pygtk
pygtk.require('2.0')
import gobject
import appindicator
import gconf
import urllib2
import re
import datetime
import locale
import pynotify
from xml.dom.minidom import parseString
import time
import math
import commands
import threading
import logging
import logging.handlers

import gettext
from gettext import gettext as _
gettext.textdomain('indicator-weather')

from gweather.I_KNOW_THIS_IS_UNSTABLE import gweather
import pymetar as metar

# Add project root directory (enable symlink, and trunk execution).
PROJECT_ROOT_DIRECTORY = os.path.abspath(
    os.path.dirname(os.path.dirname(os.path.realpath(sys.argv[0]))))

if (os.path.exists(os.path.join(PROJECT_ROOT_DIRECTORY, 'indicator_weather'))
    and PROJECT_ROOT_DIRECTORY not in sys.path):
    sys.path.insert(0, PROJECT_ROOT_DIRECTORY)
    os.putenv('PYTHONPATH', PROJECT_ROOT_DIRECTORY) # for subprocesses

from indicator_weather.helpers import get_builder

gconfClient = gconf.client_get_default()

class Location:
    """
    Data object which contains the name of a city (label), its GWeather object "location"
    """

    #Initialize an object with a label
    def __init__(self, metric_system, wind_units):
        self.__metric_system = metric_system
        self.__wind_units = wind_units
        self.__found = False
        self.__lat = None
        self.__lon = None

    #Replace chars with HTML-safe equivalents
    def html_decode(self, value):
        htmlCodes = (
            ('&', '&amp;'),
            ('<', '&lt;'),
            ('>', '&gt;'),
            ('"', '&quot;'),
            ("'", '&#39;'),
        )
        for code in htmlCodes:
            value = value.replace(code[0], code[1])
        return value

    # Get a full city name
    def get_full_city_name(self):
        # We're getting a parent here, as 'location' here is actually a weather station
        self.__city = self.__location.get_parent()
        self.__full_city_name = ""
        while (self.__city.get_parent().get_parent() != None):
            self.__full_city_name += "%s, " % self.__city.get_name()
            self.__city = self.__city.get_parent()
        self.__full_city_name += "%s" % self.__city.get_name()
        return self.html_decode(self.__full_city_name)

    #Get short city name
    def get_short_city_name(self):
        return self.html_decode(self.__location.get_parent().get_name())

    #Internal proc - iterate by known locations to find a city by its name
    def __find_city_by_name (self, node, city_name):
        if (node.get_name() == city_name):
            #FIXME: City may have several weather stations - we're selecting the first one only
            if (node.get_children() != None):
                return node.get_children()[0];
        else:
            for obj in node.get_children():
                possible_city = self.__find_city_by_name(obj, city_name)
                if (possible_city != None):
                    return possible_city;
    
    #Internal proc - iterate by known locations to find city by its code
    def __find_city_by_code (self, node, city_code):
        if (node.get_code() == city_code):
            return node;
        else:
            for obj in node.get_children():
                possible_city = self.__find_city_by_code(obj, city_code)
                if (possible_city != None):
                    return possible_city;

    #Fill in location attribute, looking up by location name
    def find_city_by_name (self, city_name):
        location = self.__find_city_by_name(gweather.location_new_world(True), city_name)
        self.prepare_location(location)

    #Fill in location attribute, looking up by location code
    def find_city_by_code (self, city_code):
        location = self.__find_city_by_code(gweather.location_new_world(True), city_code)
        self.prepare_location(location)

    #Prepare metar reporter for the location
    def prepare_location(self, location):
        if (location != None):
            self.__location = location
            self.__code = location.get_code()
            self.__lat = location.get_coords()[0]
            self.__lon = location.get_coords()[1]
            self.__report_fetcher = metar.ReportFetcher(self.__code)
            self.__found = True
        else:
            self.__found = False

    #Get continent name for radar map
    def getContinent(self):
        if (self.__location != None):
            self.__city = self.__location
            self.__continent_name = ""
            self.__city = self.__city.get_parent()
            while (self.__city.get_parent().get_parent() != None):
                self.__city = self.__city.get_parent()
            self.__continent_name = self.__city.get_name()
            return self.__continent_name
        
    def set_label(self, value):
        self.__label = value

    @property
    def code(self):
        return self.__code

    @property
    def found(self):
        return self.__found

    @property
    def label(self):
        return self.__label

    @property
    def weather(self):
        return self.__weather

    #Get sun status
    def get_sun_data(self):
        #return ("00:00:00", "00:00:00", "00:00:00")
        if (self.found):
            now = datetime.datetime.now()
            url = 'http://www.earthtools.org/sun/%s/%s/%s/%s/99/1' % (self.__lat,self.__lon,now.day,now.month)
            try:
                f = urllib2.urlopen(url)
                s=f.read()
                parsed = parseString(s)
                sunrise = parsed.getElementsByTagName("morning")[0].getElementsByTagName("civil")[0].firstChild.nodeValue
                sunset  = parsed.getElementsByTagName("evening")[0].getElementsByTagName("civil")[0].firstChild.nodeValue
            #sunrise = parsed.getElementsByTagName("sunrise")[0].firstChild.nodeValue
            #sunset = parsed.getElementsByTagName("sunset")[0].firstChild.nodeValue
                timezone = parsed.getElementsByTagName("timezone")[0].firstChild.nodeValue
                return (sunrise, sunset, timezone)
            except urllib2.URLError:
                print "error reaching url %s" % url
                return ("00:00:00", "00:00:00", "00:00:00")
        else:
            print "Can't gather sun data on empty location"

    #Update weather data and store weather object
    def update_weather_data(self):
        if (self.__report_fetcher != None):
            try:
                self.__fetched_report = self.__report_fetcher.FetchReport()
                self.__weather_report = metar.ReportParser(self.__fetched_report).ParseReport()
                self.__sun_report = self.get_sun_data();
                self.__weather = Weather(self.__weather_report, self.__sun_report, self.__metric_system, self.__wind_units)
            except urllib2.URLError:
                self.__found = False
                print "error fetching report"

    #Get and store forecast data - use Google
    def prepare_forecast_data(self):
        import locale
        localebad = locale.getlocale()[0]
        locale = localebad.split ('_')
        #Here we generate a string, compiled of latitude and longitude for location
        self.coord_string = (",,,%.6f,%.6f" % (self.__lat, self.__lon)).replace(".","")
        url = "http://www.google.com/ig/api?weather=" + self.coord_string + "&hl=" + locale[0]
        print "url:%s" % url
        try:
            f = urllib2.urlopen(url)
            s = f.read()
            encoding = f.headers['content-type'].split('charset=')[-1]
            s = unicode(s, encoding).encode('utf-8').replace("&#39;", "'")
            self.unitsystem = s.split("<unit_system data=\"")[-1].split("\"")[0]
            self.__parsedforecast = parseString(s)
        except urllib2.URLError:
            print "error reaching url %s" % url
        #FIXME: check for errors here

    #Parse a list of days of week with forecast data
    def get_forecast_daysofweek(self):
        self.daysofweek = []
        for day_of_week in self.__parsedforecast.getElementsByTagName("day_of_week"):
                self.daysofweek.append([day_of_week.attributes["data"].value][0])
        return self.daysofweek

    #Parse high values for forecast data
    def get_forecast_highdata(self):
        self.highdata = []
        if ((self.unitsystem == 'SI') and (self.__metric_system == MetricSystem.SI)) or ((self.unitsystem == 'US') and (self.__metric_system == MetricSystem.IMPERIAL)):
            #correct scale selected
            for high in self.__parsedforecast.getElementsByTagName("high"):
                self.highdata.append([high.attributes["data"].value][0])
        elif ((self.unitsystem == 'SI') and (self.__metric_system == MetricSystem.IMPERIAL)):
            #convert from SI to imperial
            for high in self.__parsedforecast.getElementsByTagName("high"):
                self.highdata.append(int(((int([high.attributes["data"].value][0])*9)/5)+32))
        elif ((self.unitsystem == 'US') and (self.__metric_system == MetricSystem.SI)):
            #convert from imperial to SI
            for high in self.__parsedforecast.getElementsByTagName("high"):
                self.highdata.append(int((((int([high.attributes["data"].value][0]))-32)*5)/9))
        return self.highdata

    #Parse low values for forecast data
    def get_forecast_lowdata(self):
        self.lowdata = []
        if ((self.unitsystem == 'SI') and (self.__metric_system == MetricSystem.SI)) or ((self.unitsystem == 'US') and (self.__metric_system == MetricSystem.IMPERIAL)):
            #correct scale selected
            for low in self.__parsedforecast.getElementsByTagName("low"):
                self.lowdata.append([low.attributes["data"].value][0])
        elif ((self.unitsystem == 'SI') and (self.__metric_system == MetricSystem.IMPERIAL)):
            #convert from SI to imperial
            for low in self.__parsedforecast.getElementsByTagName("low"):
                self.lowdata.append(int(((int([low.attributes["data"].value][0])*9)/5)+32))
        elif ((self.unitsystem == 'US') and (self.__metric_system == MetricSystem.SI)):
            #convert from imperial to SI
            for low in parsed.getElementsByTagName("low"):
                self.lowdata.append(int((((int([low.attributes["data"].value][0]))-32)*5)/9))
        return self.lowdata

    #Parse icons for forecast data
    def get_forecast_icons(self):
        self.icons = []
        for icon in self.__parsedforecast.getElementsByTagName("icon"):
                self.icons.append([icon.attributes["data"].value][0].split("/ig/images/weather/")[-1].split(".gif")[0])
        return self.icons

    #Parse conditions for forecast data
    def get_forecast_conditions(self):
        self.conditions = []
        for condition in self.__parsedforecast.getElementsByTagName("condition"):
            self.conditions.append([condition.attributes["data"].value][0])
        return self.conditions
        
class MetricSystem:
    SI = 1
    IMPERIAL = 2

class WindUnits:
    MPS = 1
    MPH = 2
    BEAUFORT = 3
    KPH = 4
    #KNOTS = 5

class Weather:
    """
    Data object to parse metar weather object and convert units
    """
    
    #Available conditions and their icons
    # The following format is used:
    # pymetar name: (translated name, day icon name, night icon name, is severe) 
    _WeatherConditions = {
        #FIXME: Do we really have to copypaste these key values?

        #Clear
        "sunny"                   : ( _("Sunny"),          "weather-clear", False),
        "mostly sunny"            : ( _("Mostly sunny"),   "weather-clear", False),
        "partly sunny"            : ( _("Partly sunny"),   "weather-clear", False),
        "clear"                   : ( _("Clear"),          "weather-clear", False),
        "clear sky"               : ( _("Clear sky"),      "weather-clear", False),
        "becoming sunny"          : ( _("Becoming sunny"), "weather-clear", False),

        #Clouds
        "mostly cloudy"           : ( _("Mostly cloudy"),     "weather-clouds",   False),
        "increasing clouds"       : ( _("Increasing clouds"), "weather-clouds",   False),
        "decreasing clouds"       : ( _("Decreasing clouds"), "weather-clouds",   False),
        "broken clouds"           : ( _("Broken clouds"),     "weather-clouds",   False),
        "scattered clouds"        : ( _("Scattered clouds"),  "weather-overcast", False),
        "overcast"                : ( _("Overcast"),          "weather-overcast", False),

        #Few clouds
        "few clouds"              : ( _("Few clouds"),       "weather-few-clouds", False),
        "partly cloudy"           : ( _("Partly cloudy"),    "weather-few-clouds", False),
        "becoming cloudy"         : ( _("Becoming cloudy"),  "weather-few-clouds", False),
        "clearing"                : ( _("Clearing"),         "weather-few-clouds", False),
        "gradual clearing"        : ( _("Gradual clearing"), "weather-few-clouds", False),
        "clearing late"           : ( _("Clearing late"),    "weather-few-clouds", False),

        #Fog
        "fog"                     : ( _("Fog"),                  "weather-fog", False),
        "patchy fog"              : ( _("Patchy fog"),           "weather-fog", False),
        "dense fog"               : ( _("Dense fog"),            "weather-fog", False),
        "areas fog"               : ( _("Areas fog"),            "weather-fog", False),
        "blowing dust"            : ( _("Blowing dust"),         "weather-fog", False),
        "blowing sand"            : ( _("Blowing sand"),         "weather-fog", False),
        "patchy haze"             : ( _("Patchy haze"),          "weather-fog", False),
        "areas haze"              : ( _("Areas haze"),           "weather-fog", False),
        "haze"                    : ( _("Haze"),                 "weather-fog", False),
        "patchy ice fog"          : ( _("Patchy ice fog"),       "weather-fog", False),
        "areas ice fog"           : ( _("Areas ice fog"),        "weather-fog", False),
        "ice fog"                 : ( _("Ice fog"),              "weather-fog", False),
        "patchy freezing fog"     : ( _("Patchy freezing fog"),  "weather-fog", False),
        "areas freezing fog"      : ( _("Areas freezing fog"),   "weather-fog", False),
        "freezing fog"            : ( _("Freezing fog"),         "weather-fog", False),
        "freezing spray"          : ( _("Freezing spray"),       "weather-fog", False),
        "patchy smoke"            : ( _("Patchy smoke"),         "weather-fog", False),
        "areas smoke"             : ( _("Areas smoke"),          "weather-fog", False),
        "smoke"                   : ( _("Smoke"),                "weather-fog", False),
        "patchy ash"              : ( _("Patchy ash"),           "weather-fog", False),
        "areas ash"               : ( _("Areas ash"),            "weather-fog", False),
        "ash"                     : ( _("Ash"),                  "weather-fog", False),
        "volcanic ash"            : ( _("Volcanic ash"),         "weather-fog", False),
        

        #Snow
        "light snow"                 : ( _("Light snow"),                 "weather-snow", False),
        "blowing snow"               : ( _("Blowing snow"),               "weather-snow", False),
        "blizzard"                   : ( _("Blizzard"),                   "weather-snow", False),
        "patchy ice crystals"        : ( _("Patchy ice crystals"),        "weather-snow", False),
        "areas ice crystals"         : ( _("Areas ice crystals"),         "weather-snow", False),
        "ice crystals"               : ( _("Ice crystals"),               "weather-snow", False),
        "patchy frost"               : ( _("Patchy frost"),               "weather-snow", False),
        "areas frost"                : ( _("Areas frost"),                "weather-snow", False),
        "frost"                      : ( _("Frost"),                      "weather-snow", False),
        "slight chance snow showers" : ( _("Slight chance snow showers"), "weather-snow", False),
        "chance snow showers"        : ( _("Chance snow showers"),        "weather-snow", False),
        "snow showers likely"        : ( _("Snow showers likely"),        "weather-snow", False),
        "snow showers"               : ( _("Snow showers"),               "weather-snow", False),
        "slight chance snow/rain"    : ( _("Slight chance snow/rain"),    "weather-snow", False),
        "chance snow/rain"           : ( _("Chance snow/rain"),           "weather-snow", False),
        "snow/rain likely"           : ( _("Snow/rain likely"),           "weather-snow", False),
        "snow/rain"                  : ( _("Snow/rain"),                  "weather-snow", False),
        "slight chance wintry mix"   : ( _("Slight chance wintry mix"),   "weather-snow", False),
        "chance wintry mix"          : ( _("Chance wintry mix"),          "weather-snow", False),
        "wintry mix likely"          : ( _("Wintry mix likely"),          "weather-snow", False),
        "wintry mix"                 : ( _("Wintry mix"),                 "weather-snow", False),
        "slight chance snow/sleet"   : ( _("Slight chance snow/sleet"),   "weather-snow", False),
        "chance snow/sleet"          : ( _("Chance snow/sleet"),          "weather-snow", False),
        "snow/sleet likely"          : ( _("Snow/sleet likely"),          "weather-snow", False),
        "snow/sleet"                 : ( _("Snow/sleet"),                 "weather-snow", False),

        #Rain
        "slight chance sleet"              : ( _("Slight chance sleet"),              "weather-showers", False),
        "chance sleet"                     : ( _("Chance sleet"),                     "weather-showers", False),
        "sleet likely"                     : ( _("Sleet likely"),                     "weather-showers", False),
        "sleet"                            : ( _("Sleet"),                            "weather-showers", False),
        "slight chance rain showers"       : ( _("Slight chance rain showers"),       "weather-showers", False),
        "chance rain showers"              : ( _("Chance rain showers"),              "weather-showers", False),
        "rain showers likely"              : ( _("Rain showers likely"),              "weather-showers", False),
        "rain showers"                     : ( _("Rain showers"),                     "weather-showers", False),
        "slight chance rain"               : ( _("Slight chance rain"),               "weather-showers", False),
        "chance rain"                      : ( _("Chance rain"),                      "weather-showers", False),
        "rain likely"                      : ( _("Rain likely"),                      "weather-showers", False),
        "rain"                             : ( _("Rain"),                             "weather-showers", False),
        "heavy rain"                       : ( _("Heavy rain"),                       "weather-showers", False),
        "slight chance drizzle"            : ( _("Slight chance drizzle"),            "weather-showers", False),
        "chance drizzle"                   : ( _("Chance drizzle"),                   "weather-showers", False),
        "drizzle likely"                   : ( _("Drizzle likely"),                   "weather-showers", False),
        "drizzle"                          : ( _("Drizzle"),                          "weather-showers", False),
        "slight chance freezing rain"      : ( _("Slight chance freezing rain"),      "weather-showers", False),
        "chance freezing rain"             : ( _("Chance freezing rain"),             "weather-showers", False),
        "freezing rain likely"             : ( _("Freezing rain likely"),             "weather-showers", False),
        "freezing rain"                    : ( _("Freezing rain"),                    "weather-showers", False),
        "slight chance freezing drizzle"   : ( _("Slight chance freezing drizzle"),   "weather-showers", False),
        "chance freezing drizzle"          : ( _("Chance freezing drizzle"),          "weather-showers", False),
        "freezing drizzle likely"          : ( _("Freezing drizzle likely"),          "weather-showers", False),
        "freezing drizzle"                 : ( _("Freezing drizzle"),                 "weather-showers", False),
        "slight chance rain/freezing rain" : ( _("Slight chance rain/freezing rain"), "weather-showers", False), 
        "chance rain/freezing rain"        : ( _("Chance rain/freezing rain"),        "weather-showers", False),
        "rain/freezing rain likely"        : ( _("Rain/freezing rain likely"),        "weather-showers", False),
        "rain/freezing rain"               : ( _("Rain/freezing rain"),               "weather-showers", False),

        #Storms
        "storm"                           : ( _("Storm"),                       "weather-storm", True),
        "isolated thunderstorms"          : ( _("Isolated thunderstorms"),      "weather-storm", True),
        "slight chance thunderstorms"     : ( _("Slight chance thunderstorms"), "weather-storm", True),
        "chance thunderstorms"            : ( _("Chance thunderstorms"),        "weather-storm", True),
        "thunderstorms likely"            : ( _("Thunderstorms likely"),        "weather-storm", True),
        "thunderstorm"                    : ( _("Thunderstorms"),               "weather-storm", True),
        "severe thunderstorms"            : ( _("Severe thunderstorms"),        "weather-storm", True),
        "water spout"                     : ( _("Water spout"),                 "weather-storm", True)
    }

    # Night icons for weather conditions
    _Night_Icons = {
        "weather-storm"      : "weather-storm",
        "weather-showers"    : "weather-showers",
        "weather-snow"       : "weather-snow",
        "weather-fog"        : "weather-fog",
        "weather-few-clouds" : "weather-few-clouds-night",
        "weather-overcast"   : "weather-overcast",
        "weather-clouds"     : "weather-clouds-night",
        "weather-clear"      : "weather-clear-night"
    }

    def __init__(self, weather_report, sun_report, metric_system, wind_unit):
        self.__report = weather_report
        self.__sun = sun_report
        self.__metric_system = metric_system
        self.__wind_unit = wind_unit
        self.__current_condition = None

        self.__get_weather_conditions = self.__report.getWeather()
        self.__get_conditions = self.__report.getConditions()
        self.__get_sky_conditions = self.__report.getSkyConditions()
        log.debug("Weather: getWeather: '%s'" % str(self.__get_weather_conditions))
        log.debug("Weather: getConditions: '%s'" % str(self.__get_conditions))
        log.debug("Weather: getSkyConditions: '%s'" % str(self.__get_sky_conditions))
        if ((self.__report.getWeather() != None) and (self._WeatherConditions.get(self.__report.getWeather().lower()) != None)):
            self.__current_condition = self._WeatherConditions.get(self.__report.getWeather().lower())
        elif ((self.__report.getConditions()[0] != None) and (self._WeatherConditions.get(self.__report.getConditions()[0].lower()) != None)):
            self.__current_condition = self._WeatherConditions.get(self.__report.getConditions()[0].lower())
        elif ((self.__report.getSkyConditions() != None) and (self._WeatherConditions.get(self.__report.getSkyConditions().lower()) != None)):
            self.__current_condition = self._WeatherConditions.get(self.__report.getSkyConditions().lower())

        log.debug("Weather: current condition: '%s'" % str(self.__current_condition))

        #formatting sun data
        now = datetime.datetime.now().time()
        log.debug("Weather: got sunrise '%s', sunset '%s'" % (self.__sun[0], self.__sun[1]))
        self.__sunrise = self.__sun[0]
        self.__sunset = self.__sun[1]
        #FIXME: this is ugly
        self.__sunrise_t = datetime.time(int(self.__sunrise.split(':')[0]), int(self.__sunrise.split(':')[1]), int(self.__sunrise.split(':')[2]))
        self.__sunset_t = datetime.time(int(self.__sunset.split(':')[0]), int(self.__sunset.split(':')[1]), int(self.__sunset.split(':')[2]))
        if now<self.__sunrise_t or now>self.__sunset_t:
            self.__night = True
        else:
            self.__night = False
    
    def isNight(self):
        return self.__night

    def isReportCorrect(self):
        return True if self.__report != None else False

    def isSevereCondition(self):
        if self.__current_condition != None:
            log.debug("Weather: got severe condition '%s'" % self.__current_condition[2])
            return self.__current_condition[2]
        else:
            log.error("Weather: got empty severe condition")
            return False;

    def getPureCondition(self):
        if self.__current_condition != None:
            log.debug("Weather: got condition '%s'" % self.__current_condition[0])
            return self.__current_condition[0]
        else:
            log.error("Weather: got empty condition")
            return _("Error retreiving condition");

    def getCondition(self):
        return "%s: %s" % (_("Condition"), self.getPureCondition())

    def getSkyCondition(self):
        return "%s: %s" % (_("Sky"), self.__report.getSkyConditions())

    def getPixmap(self):
        if self.__current_condition != None:
            if self.isNight:
                log.error("Weather: night, show '%s' icon" % self._Night_Icons.get(self.__current_condition[1]))
                return self._Night_Icons.get(self.__current_condition[1])
            else:
                log.error("Weather: day, show '%s' icon" % self.__current_condition[1])
                return self.__current_condition[1]
        else:
            log.error("Weather: return 'offline' icon due to empty condition")
            return "weather-indicator-unknown"

    def getHumidity(self):
        return "%s: %s %s" % (_("Humidity"), self.__report.getHumidity(), "%")

    def getDewPoint(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getDewPointCelsius()
            _unit  = "C"
        else:
            _value = self.__report.getDewPointFahrenheit()
            _unit  = "F"
        return "%s: %s %s" % (_("Dew Point"), _value, _unit)

    def getPressure(self):
        return "%s: %s %s" % (_("Pressure"), self.__report.getPressure(), "hPa")

    def getPureTemperature(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getTemperatureCelsius()
            _unit  = "C"
        else:
            _value = self.__report.getTemperatureFahrenheit()
            _unit  = "F"
        return "%0.1f %s" % (_value, _unit)

    def getTemperature(self):
        return "%s: %s" % (_("Temperature"), self.getPureTemperature())

    def getHumidex(self):
        self.vapour_pressure = 6.11 * math.exp(5417.7530 * ( (1/273.16) - (1/(self.__report.getDewPointCelsius()+273.16))))
        self.humidex = self.__report.getTemperatureCelsius() + (0.5555)*(self.vapour_pressure  - 10.0);
        return "%s: %0.1f" % (_("Humidex"), self.humidex)

    def getVisibility(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getVisibilityKilometers()
            _unit  = _("km")
        else:
            _value = self.__report.getVisibilityMiles()
            _unit  = _("mile(s)")
        return "%s: %s %s" % (_("Visibility"), _value, _unit)

    def getWindDirection(self):
        #FIXME: return a "SW" instead of "280" degrees values
        return "%s: %s" % (_("Wind Direction"), self.__report.getWindDirection())

    def getWindSpeed(self):
        if (self.__wind_unit == WindUnits.MPS):
            _value = self.__report.getWindSpeed()
            _unit  = _("m/s")
        if (self.__wind_unit == WindUnits.MPH):
            _value = self.__report.getWindSpeedMilesPerHour()
            _unit  = _("mph")
        if (self.__wind_unit == WindUnits.BEAUFORT):
            _value = self.__report.getWindSpeedBeaufort()
            _unit  = ""
        if (self.__wind_unit == WindUnits.KPH):
            _value = self.__report.getWindSpeed() * 3.6
            _unit  = _("km/h")
        #if (self.__wind_unit == WindUnits.KNOTS):
        #    _value = self.__report.getWindSpeedKnots()
        #    _unit  = _("knot(s)")
        return "%s: %0.1f %s" % (_("Wind Speed"), _value, _unit)

    def getWindChill(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getWindchill()
            _unit  = "C"
        else:
            _value = self.__report.getWindchillF()
            _unit  = "F"
        return "%s: %s %s" % (_("Wind Chill"), _value, _unit)

    def getSunrise(self):
        return "%s: %s" % (_("Sunrise"), time.strftime('%X',time.strptime(self.__sunrise,'%H:%M:%S')))

    def getSunset(self):
        return "%s: %s" % (_("Sunset"), time.strftime('%X',time.strptime(self.__sunset,'%H:%M:%S')))

class indicator_weather(threading.Thread):
    
    def __init__(self):
        log.debug("Indicator: creating")
        threading.Thread.__init__(self)
        self.main_icon = os.path.join
        self.winder = appindicator.Indicator ("indicator-weather", "weather-indicator", appindicator.CATEGORY_OTHER)
        self.winder.set_status (appindicator.STATUS_ACTIVE)
        self.winder.set_attention_icon ("weather-indicator-error")
        
        self.rate = gconfClient.get_int("/apps/indicator-weather/refresh_rate")
        self.unit = gconfClient.get_string("/apps/indicator-weather/unit")
        self.notif = gconfClient.get_string("/apps/indicator-weather/notif")
        self.wind = gconfClient.get_string("/apps/indicator-weather/wind")
        self.placechosen = gconfClient.get_int("/apps/indicator-weather/placechosen")
        self.places = gconfClient.get_string("/apps/indicator-weather/places")

        log.debug("Preferences: got settings: rate=%s, unit=%s, notif=%s, wind=%s, placechosen=%s, places=%s" %
                (self.rate, self.unit, self.notif, self.wind, self.placechosen, self.places))

        #Setting default values
        self.metric_system = MetricSystem.SI
        self._wind_unit = WindUnits.MPH
        self.place = None
        self.menu = None
        
        if self.placechosen in (False, None) or self.placechosen >= len(eval(self.places)):
            log.debug("Indicator: could not parse placechosen, setting to 0")
            gconfClient.set_int("/apps/indicator-weather/placechosen", 0)
            self.placechosen = 0
        
        if self.unit in (False, None):
            log.debug("Indicator: could not parse unit, setting to S")
            gconfClient.set_string("/apps/indicator-weather/unit", 'S')
            self.unit = 'S'
            self.metric_system = MetricSystem.SI
        else:
            if (self.unit == 'S'):
                self.metric_system = MetricSystem.SI
            else:
                self.metric_system = MetricSystem.IMPERIAL
            
        if self.notif in (False, None):
            log.debug("Indicator: could not parse notif, setting to N")
            gconfClient.set_string("/apps/indicator-weather/notif", 'N')
            self.notif = 'N'
        
        if self.wind in (False, None):
            log.debug("Indicator: could not parse notif, setting to mph")
            gconfClient.set_string("/apps/indicator-weather/wind", 'mph')
            self._wind_unit = WindUnits.MPH
        else:
            if (self.wind == 'mph'):
                self._wind_unit = WindUnits.MPH
            elif (self.wind == 'mps'):
                self._wind_unit = WindUnits.MPS
            elif (self.wind == 'beaufort'):
                self._wind_unit = WindUnits.BEAUFORT
            elif (self.wind == 'kph'):
                self._wind_unit = WindUnits.KPH
            #elif (self.wind == 'knots'):
            #    self._wind_unit = WindUnits.KNOTS
            
        if self.rate in (False, None):
            log.debug("Indicator: could not parse rate, setting to 15")
            gconfClient.set_int("/apps/indicator-weather/refresh_rate", 15)
            self.rate = self.rate = gconfClient.get_int("/apps/indicator-weather/refresh_rate")
            
        if self.places in (False, None, '', '[]', "['']",):
            log.debug("Indicator: could not parse places")
            self.menu_noplace()
        else:
            self.places = eval(self.places)
            #Check, that each place is a code - length is 4
            places_correct = True
            for place in self.places:
                if len(place[0]) != 4:
                    log.debug("Indicator: incorrect place code found: %s" % place)
                    places_correct = False
            if places_correct == False:
                self.places = None
                self.menu_noplace()
            else:
                self.menu_normal()
                self.place = self.places[self.placechosen]
                self.update_weather()
                self.winder.set_menu(self.menu)
            
    def menu_noplace(self):
        log.debug("Indicator: making a menu for no places")
        menu_noplace = gtk.Menu()
        setup = gtk.MenuItem(_("Set Up Weather..."))
        setup.connect("activate", self.prefs)
        setup.show()
        menu_noplace.append(setup)

        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        menu_noplace.append(quit)

        self.winder.set_menu(menu_noplace)
    
    def menu_normal(self):
        log.debug("Indicator: menu_normal: filling in a menu for found places")
        self.menu = gtk.Menu()
            
    ##City
        self.city_show = gtk.MenuItem()
        self.city_show.set_sensitive(True)
        self.menu.append(self.city_show)
        self.city_show.show()
        
    ##Condition
        self.cond_show = gtk.MenuItem()
        self.cond_show.set_sensitive(True)
        self.cond_show.show()
        self.menu.append(self.cond_show)
        
    ##Temperature        
        self.temp_show = gtk.MenuItem()
        self.temp_show.set_sensitive(True)
        self.temp_show.show()
        self.menu.append(self.temp_show)

    ##Humidex        
        self.humidex_show = gtk.MenuItem()
        self.humidex_show.set_sensitive(True)
        self.humidex_show.show()
        self.menu.append(self.humidex_show)
        
    ##Humidity
        self.humid_show = gtk.MenuItem()
        self.humid_show.set_sensitive(True)
        self.humid_show.show()
        self.menu.append(self.humid_show)
        
    ##Wind
        self.wind_show = gtk.MenuItem()
        self.wind_show.set_sensitive(True)
        self.wind_show.show()
        self.menu.append(self.wind_show)
                
    ##Sunrise
        self.sunrise_show = gtk.MenuItem()
        self.sunrise_show.set_sensitive(True)
        self.sunrise_show.show()
        self.menu.append(self.sunrise_show)

    ##Sunset
        self.sunset_show = gtk.MenuItem()
        self.sunset_show.set_sensitive(True)
        self.sunset_show.show()
        self.menu.append(self.sunset_show)
        
    ##Cities
        if len(self.places) != 1:
            ##Breaker
            breaker = gtk.SeparatorMenuItem()
            breaker.show()
            self.menu.append(breaker)

            log.debug("Indicator: menu_normal: adding first location menu item '%s'" % self.places[0][1])
            loco1 = gtk.RadioMenuItem(None, self.places[0][1])
            if self.placechosen == 0:
                loco1.set_active(True)
            loco1.connect("toggled", self.on_city_changed)
            loco1.show()
            self.menu.append(loco1)
            for place in self.places[1:]:
                log.debug("Indicator: menu_normal: adding location menu item '%s'" % place[1])
                loco = gtk.RadioMenuItem(loco1, place[1])
                if self.places.index(place) == self.placechosen:
                    loco.set_active(True)
                loco.connect("toggled", self.on_city_changed)
                loco.show()
                self.menu.append(loco)
        
    ##Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)

        refresh_show = gtk.MenuItem(_("Refresh"))
        refresh_show.connect("activate", self.update_weather)
        refresh_show.show()
        self.menu.append(refresh_show)
        
        ext_show = gtk.MenuItem(_("Forecast"))
        ext_show.connect("activate", self.extforecast)
        ext_show.show()
        self.menu.append(ext_show)

    ##Preferences      
        prefs_show = gtk.MenuItem(_("Preferences..."))
        prefs_show.connect("activate", self.prefs)
        prefs_show.show()
        self.menu.append(prefs_show)

    ##Quit
        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        self.menu.append(quit)

        self.winder.set_menu(self.menu)
        if (hasattr(self.winder, 'set_label')):
            log.debug("Indicator: menu_normal: setting label to empty value")
            self.winder.set_label("")
        
    def on_city_changed(self,widget):
        if widget.get_active():
            for place in self.places:
                if (place[1] == widget.get_label()):
                    log.debug("Indicator: new location selected: %s" % self.places.index(place))
                    self.placechosen = self.places.index(place)
                    break
            gconfClient.set_int("/apps/indicator-weather/placechosen", self.placechosen)
            self.update_weather(False)

    def update_weather(self, notif=True,widget=None):
        log.debug("Indicator: updateWeather: updating weather for %s" % self.places[self.placechosen])
        weather = self.get_weather(self.places[self.placechosen])
        if weather == None:
            log.debug("Indicator: updateWeather: could not get weather")
            for item in self.menu.get_children()[0:len(self.menu.get_children())]:
                item.destroy()

            self.menu = gtk.Menu()
            self.problem_show = gtk.MenuItem(_("Connection problem"))
            self.problem_show.set_sensitive(False)
            self.problem_show.show()
            self.menu.append(self.problem_show)

            self.refresh_show = gtk.MenuItem(_("Refresh"))
            self.refresh_show.connect("activate", self.update_weather)
            self.refresh_show.show()
            self.menu.append(self.refresh_show)

            self.quit_menu = gtk.ImageMenuItem(gtk.STOCK_QUIT)
            self.quit_menu.connect("activate", self.quit)
            self.quit_menu.show()
            self.menu.append(self.quit_menu)

            self.winder.set_icon("weather-indicator-error")
            if (hasattr(self.winder, 'set_label')):
                self.winder.set_label("")
            self.winder.set_menu(self.menu)

            log.debug("Indicator: updateWeather: setting rate to one minute")
            self.rateid = gobject.timeout_add(60000, self.update_weather)
            return
		
        self.condition = weather.getPureCondition()
        self.icon = weather.getPixmap()
        log.debug("Indicator: updateWeather: got condition '%s', icon '%s'" % (self.condition, self.icon))
        if (self.icon == False):
          self.winder.set_icon("weather-indicator-unknown")
        else:
        	self.winder.set_icon(self.icon)
        
        #self.city_table.attach(gtk.Label("City"), 0, 1, 0, 1)

        log.debug("Indicator: fill in menu with params: city='%s', temp='%s', humidex='%s', humid='%s', wind='%s', sunrise='%s', sunset='%s', puretemp=%s" % (self.places[self.placechosen][1], weather.getTemperature(), weather.getHumidex(), weather.getHumidity(), weather.getWindSpeed(), weather.getSunrise(), weather.getSunset(), weather.getPureTemperature()))
        self.menu_normal()
        self.city_show.set_label(self.places[self.placechosen][1])
        self.cond_show.set_label(self.condition)
        self.temp_show.set_label(weather.getTemperature())
        self.humidex_show.set_label(weather.getHumidex())
        self.humid_show.set_label(weather.getHumidity())
        self.wind_show.set_label(weather.getWindSpeed())
        self.sunrise_show.set_label(weather.getSunrise())
        self.sunset_show.set_label(weather.getSunset())
        if (hasattr(self.winder, 'set_label')):
            log.debug("Indicator: updateWeather: setting label to %s" % weather.getPureTemperature())  
            self.winder.set_label(weather.getPureTemperature())

        if self.condition != gconfClient.get_string("/apps/indicator-weather/current") and self.notif == 'U':
            log.debug("Indicator: updateWeather: weather has changed, notify")
            self.notify(self.condition, self.icon)
        if self.notif == 'S' and weather.isSevereCondition():
            log.debug("Indicator: updateWeather: severe condition notification")
            self.notify(self.condition, self.icon, severe=True)

        gconfClient.set_string("/apps/indicator-weather/current",self.condition)
        log.debug("Indicator: updateWeather: setting rate to %s" % self.rate)    
        self.rateid = gobject.timeout_add(int(self.rate) * 60000, self.update_weather)

    def responseToDialog(self, entry, dialog, response):
        #FIXME: Do we need this?
        log.debug("Indicator: response to dialog")  
        dialog.response(response)

    def get_weather(self, city, firstrun=False, extended=False, onlycity=False):
        log.debug("Indicator: getWeather: extended = %s" % extended)  
        self.current_location = Location(self.metric_system, self._wind_unit)
        if (self.current_location.find_city_by_code(city[0]) == False):
            log.error("Indicator: getWeather: location with code %s not found" % city[0])  
        if extended == False:
            log.debug("Indicator: getWeather: updating weather report")  
            self.current_location.update_weather_data()
            if (self.current_location.found == False) or (self.current_location.weather.isReportCorrect() == False):
                log.debug("Indicator: getWeather: report is empty")  
                return None;
            else:
                return self.current_location.weather
        else:
            self.current_location.prepare_forecast_data()
            self.daysofweek = self.current_location.get_forecast_daysofweek()
            self.lowdata    = self.current_location.get_forecast_lowdata()
            self.highdata   = self.current_location.get_forecast_highdata()
            self.icons      = self.current_location.get_forecast_icons()
            self.conditions = self.current_location.get_forecast_conditions()
        
    def prefs(self, widget):
        log.debug("Indicator: open Preferences")  
        self.prefswindow = PreferencesDialog()
        self.prefswindow.show()
        
    def extforecast(self, widget):
        log.debug("Indicator: open Forecast")  
        forecastwd = ExtendedForecast()
        forecastwd.show()
        
    def notify(self,conditon,icon,severe=False):
        log.debug("Indicator: Notify on weather condition, severe=%s, condition=%s, icon=%s" % (severe, self.condition, icon))  
        if severe:
			n = pynotify.Notification (_("Severe weather alert"),
                self.condition,
                icon)
        else:
		    n = pynotify.Notification (self.condition,"",icon)
        n.show ()

    def quit(self, widget, data=None):
        log.debug("Indicator: Quitting")  
        gtk.main_quit()

class PreferencesDialog(gtk.Dialog):
    __gtype_name__ = "PreferencesDialog"
    def __new__(cls):
        log.debug("Preferences: creating")
        builder = get_builder('PreferencesDialog')
        new_object = builder.get_object("preferences_dialog")
        new_object.finish_initializing(builder)
        return new_object

    def finish_initializing(self, builder):
        log.debug("Preferences: finishing initialization")
        log.debug("Preferences: got settings: unit=%s, notif=%s, wind=%s, rate=%s" %
                (wi.unit, wi.notif, wi.wind, wi.rate))
        self.builder = builder
        #Refactor this
        if wi.unit == 'S':
            self.builder.get_object('si').set_active(True)
        elif wi.unit == 'I':
            self.builder.get_object('imperial').set_active(True)
        if wi.notif == 'N':
            self.builder.get_object('nonotif').set_active(True)
        elif wi.notif == 'O':
            self.builder.get_object('notifsevere').set_active(True)
        else:
            self.builder.get_object('notifall').set_active(True)            
        if wi.wind == 'mps':
            self.builder.get_object('mps').set_active(True)
        elif wi.wind == 'mph':
            self.builder.get_object('mph').set_active(True)
        elif wi.wind == 'kph':
            self.builder.get_object('kph').set_active(True)
        #elif wi.wind == 'knots':
        #    self.builder.get_object('knots').set_active(True)
        else:
            self.builder.get_object('beaufort').set_active(True)
        
        self.builder.get_object('rate').set_value(wi.rate)

        log.debug("Preferences: Loading places")
        if wi.places != None:
            for place in wi.places:
                log.debug("Preferences: Places: got (%s, %s)" % (place[1], place[0]))
                newplace = list()
                newplace.append(place[1])
                newplace.append(place[0])
            
                self.builder.get_object('citieslist').append(newplace)
            self.builder.get_object('button1').set_sensitive(True)
            
        self.builder.connect_signals(self)
        
    def on_remove_location(self, widget):
        selection = self.builder.get_object('displaylist').get_selection()
        model, iter = selection.get_selected()
        log.debug("Preferences: Removing location %s (code %s)" % (model[iter][0], model[iter][1]))
        if iter != None:
            model.remove(iter)

        if (self.builder.get_object('citieslist').get_iter_first() == None):
            self.builder.get_object('button1').set_sensitive(False)

    def on_add_location(self, widget):
        log.debug("Preferences: Add location clicked")
        self.assistant = Assistant()
        self.assistant.show()
       
    def on_destroy(self, widget, data=None):
        pass
        #"""Called when the WeatherIndicatorWindow is closed."""
        #gtk.main_quit()
    #def on_city_edited(self,widget,path,value):
        ###CHECK AVAILABILITY
        #self.builder.get_object('citieslist').set_value(self.builder.get_object('citieslist').get_iter_from_string(path), 0, value)
    
    def ok(self, widget, data=None):
        """The user has selected to save the changes.

        Called before the dialog returns gtk.RESONSE_OK from run().
        """
        log.debug("Preferences: Saving settings")
        needupdate = False
        # Metric System
        metric_systems = [('si',       "S", MetricSystem.SI),
                          ('imperial', "I", MetricSystem.IMPERIAL)]

        for metric_system in metric_systems:
            if self.builder.get_object(metric_system[0]).get_active():
                new_unit = metric_system[1]
                new_metric_system = metric_system[2]

        if (wi.unit != new_unit):
            wi.unit = new_unit
            wi.metric_system = new_metric_system
            gconfClient.set_string("/apps/indicator-weather/unit", wi.unit)
            needupdate = True
            log.debug("Preferences: Unit changed to '%s'" % wi.unit)

        # Wind Units
        wind_systems = [('mps',      "mps",      WindUnits.MPS),
                        ('mph',      "mph",      WindUnits.MPH),
                        ('kph',      "kph",      WindUnits.KPH),
                        ('beaufort', "beaufort", WindUnits.BEAUFORT)]
                        #('knots',    "knots",    WindUnits.KNOTS)]

        for wind_system in wind_systems:
            if self.builder.get_object(wind_system[0]).get_active():
                new_wind_unit   = wind_system[1]
                new_wind_system = wind_system[2]

        if (wi.wind != new_wind_unit):
            wi.wind = new_wind_unit
            wi._wind_unit = new_wind_system
            gconfClient.set_string("/apps/indicator-weather/wind", wi.wind)
            needupdate = True
            log.debug("Preferences: Wind Unit changed to '%s'" % wi.wind)

        # Notifications
        notifications = [('nonotif',     "N"),
                         ('notifsevere', "O"),
                         ('notifall',    "U")]
        for notification in notifications:
            if self.builder.get_object(notification[0]).get_active():
                new_notification  = notification[1]

        if (wi.notif != new_notification):
            wi.notif = new_notification
            gconfClient.set_string("/apps/indicator-weather/notif", wi.notif)
            needupdate = True
            log.debug("Preferences: Notifications changed to '%s'" % wi.notif)

        ##Rate
        if int(self.builder.get_object('rate').get_value()) != wi.rate:
            gconfClient.set_int("/apps/indicator-weather/refresh_rate", int(self.builder.get_object('rate').get_value()))
            wi.rate = int(self.builder.get_object('rate').get_value())
            gobject.source_remove(wi.rateid)
            wi.rateid = gobject.timeout_add(int(wi.rate) * 60000, wi.update_weather)
            log.debug("Preferences: Rate changed to '%s'" % wi.rate)
            
        ##places
        newplaces = list()
        item = self.builder.get_object('citieslist').get_iter_first()
        while ( item != None ):
            newplace = list()
            newplace.append(self.builder.get_object('citieslist').get_value (item, 1))
            newplace.append(self.builder.get_object('citieslist').get_value (item, 0))
            newplaces.append(newplace)
            item = self.builder.get_object('citieslist').iter_next(item)
        if newplaces != wi.places:
            wi.places = newplaces
            log.debug("Preferences: Places changed to '%s'" % str(wi.places))
            gconfClient.set_string("/apps/indicator-weather/places", str(wi.places))
            if (type(wi.place) != None) and (wi.place in wi.places):
                wi.placechosen = wi.places.index(wi.place)
            else:
                wi.placechosen = 0
            log.debug("Preferences: Place Chosen changed to '%s'" % wi.placechosen)
            gconfClient.set_int("/apps/indicator-weather/placechosen", wi.placechosen)
            wi.menu_normal()
            wi.winder.set_menu(wi.menu)
            needupdate = True
        
        if needupdate:
            wi.update_weather(False)
        
        self.destroy()

    def cancel(self, widget, data=None):
        """The user has elected cancel changes.

        Called before the dialog returns gtk.RESPONSE_CANCEL for run()
        """
        # Restore any changes to self._preferences here.
        log.debug("Preferences: Cancelling")
        self.destroy()
        
class ExtendedForecast(gtk.Window):
    __gtype_name__ = "ExtendedForecast"
    def __new__(cls):
        log.debug("ExtendedForecast: creating")
        builder = get_builder('ExtendedForecast')
        new_object = builder.get_object("extended_forecast")
        new_object.finish_initializing(builder)
        return new_object
        
    def finish_initializing(self, builder):
        log.debug("ExtendedForecast: finishing initialization")
        self.builder = builder
        self.builder.connect_signals(self)

        log.debug("ExtendedForecast: chosen place: %s (code %s)" % (wi.places[wi.placechosen][1], wi.places[wi.placechosen][0]))
        self.builder.get_object('extended_forecast').set_title(_('Weather Forecast for ')+wi.places[wi.placechosen][1])
        log.debug("ExtendedForecast: getting forecast data")
        wi.get_weather(wi.places[wi.placechosen],False,True)

        log.debug("ExtendedForecast: parsing forecast data")
        self.builder.get_object('day1lbl').set_label('<big>%s</big>' % wi.daysofweek[0].capitalize())
        self.builder.get_object('day2lbl').set_label('<big>%s</big>' % wi.daysofweek[1].capitalize())
        self.builder.get_object('day3lbl').set_label('<big>%s</big>' % wi.daysofweek[2].capitalize())
        self.builder.get_object('day4lbl').set_label('<big>%s</big>' % wi.daysofweek[3].capitalize())

        #FIXME: Refactor this
        i=0
        for icon in wi.icons[1:]:
            i=i+1
            if icon in ('chance_of_storm', 'storm', 'thunderstorm', 'chance_of_tstorm'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-storm',gtk.ICON_SIZE_BUTTON)
            elif icon in ('sleet',  'snow',  'icy',  'flurries',  'chance_of_snow'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-snow',gtk.ICON_SIZE_BUTTON)
            elif icon in ('dust',  'fog',  'smoke',  'haze',  'mist'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-fog',gtk.ICON_SIZE_BUTTON)
            elif icon in ('rain'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-showers',gtk.ICON_SIZE_BUTTON)
            elif icon in ('chance_of_rain'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-showers-scattered',gtk.ICON_SIZE_BUTTON)
            elif icon in ('sunny', 'clear'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-clear',gtk.ICON_SIZE_BUTTON)
            elif icon in ('mostly_cloudy', 'cloudy'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-overcast',gtk.ICON_SIZE_BUTTON)
            elif icon in ('mostly_sunny',  'partly_cloudy'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-few-clouds',gtk.ICON_SIZE_BUTTON)
            else:
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('window-close',gtk.ICON_SIZE_BUTTON)
        i=0
        for condition in wi.conditions[1:]:
            i=i+1
            self.builder.get_object('day%scond' % str(i)).set_label(condition)
        i=0
        #Refactor this
        if wi.unit == 'S':
            tempunit = '°C'
        elif wi.unit == 'I':
            tempunit = '°F'
        for high in wi.highdata:
            i=i+1
            self.builder.get_object('day%stemphigh' % str(i)).set_label((_('High: ')+'%s%s') % (high,tempunit))
        i=0
        for low in wi.lowdata:
            i=i+1
            self.builder.get_object('day%stemplow' % str(i)).set_label((_('Low: ')+'%s%s') % (low,tempunit))
        
    
    def close(self, widget, data=None):
        log.debug("ExtendedForecast: closing window")
        self.destroy()
    
    def on_destroy(self, widget, data=None):
        pass
        
#class EditPlace(gtk.MessageDialog):
    #__gtype_name__ = "EditPlace"
    #def __new__(cls):
        #builder = get_builder('EditPlace')
        #new_object = builder.get_object("edit_place")
        #new_object.finish_initializing(builder)
        #return new_object
        
    #def finish_initializing(self, builder):
        #self.builder = builder
        #self.builder.connect_signals(self)
    
    #def ok(self, widget, data=None):
        #self.destroy()
        #if self.builder.get_object("entry").get_text() != '':
            #return self.builder.get_object("entry").get_text()
        #else:
            #return False
        ###APPLY CHANGES
        
    #def cancel(self, widget, data=None):
        #"""The user has elected cancel changes.

        #Called before the dialog returns gtk.RESPONSE_CANCEL for run()
        #"""
        ## Restore any changes to self._preferences here.
        #self.destroy()
        #return False

class Assistant(gtk.Assistant):
    __gtype_name__ = "Assistant"
    
    def __new__(cls):
        log.debug("Assistant: creating new Assistance instance")
        builder = get_builder('Assistant')
        new_object = builder.get_object("assistant")
        new_object.finish_initializing(builder)  
        return new_object

    # Generate a treeview model for gweather data
    def generate_treeview(self):
        log.debug("Assistant: generating treeview")
        #FIXME: Move this to WI object
        self.__all_locations_store = gtk.TreeStore(str, str, bool, str)
        node = gweather.location_new_world(True)
        self.parse_gweather_locations(node, None)
        return self.__all_locations_store

    # Recursevly parse locations
    def parse_gweather_locations(self, node, parent):
        children = node.get_children()
        if len(children) > 0:
            for i in children:
                timezone = i.get_timezone().get_tzid() if i.get_timezone() is not None else None
                is_city = i.get_level() is gweather.LOCATION_CITY
                #Unless it is a weather station or a country without children, iterate through children
                if (i.get_level() is gweather.LOCATION_WEATHER_STATION) or (len(i.get_children())>0):
                    node_iter = self.__all_locations_store.append(parent, (i.get_name(), timezone, is_city, i.get_code()))
                    self.parse_gweather_locations(i, node_iter)

    # Finish UI initialization - fill in tree
    def finish_initializing(self, builder):
        log.debug("Assistant: finishing initialization")
        self.builder = builder
        self.builder.connect_signals(self)
        self.assistant = self.builder.get_object("assistant")
        self.assistant.set_page_complete(self.builder.get_object("label"),True)
        self.assistant.set_page_complete(self.builder.get_object("review"),True)
        self.assistant.set_page_complete(self.builder.get_object("confirmplace"),True)
        # Fill in tree
        log.debug("Assistant: setting up treeview")
        self.__all_locations_view = self.builder.get_object("treeview-locations")
        column = gtk.TreeViewColumn("Location", gtk.CellRendererText(), text=0)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
        self.__all_locations_view.append_column(column)
        self.__all_locations_view.set_fixed_height_mode(True)

        self.__all_locations_store = gtk.TreeStore(str, str, bool, str)
        self.__all_locations_store.set_sort_column_id(0, gtk.SORT_ASCENDING)
        self.generate_treeview()
        self.__all_locations_view.set_model(self.__all_locations_store)
        self.__all_locations_selection = self.__all_locations_view.get_selection()
        self.__all_locations_selection.connect("changed", self.on_selection_changed)

        self.assistant.set_forward_page_func(self.get_city)

    #Callback for row selection
    def on_selection_changed(self,selection):
        self.assistant.set_page_complete(self.builder.get_object("placeinput"),False)
        if selection.count_selected_rows() != 0:
            select_iter = selection.get_selected()[1]
            log.debug("Assistant: Page 0: Tree: selected '%s', code %s" %
                    (self.__all_locations_store[select_iter][0], self.__all_locations_store[select_iter][3]))
            if self.is_location_and_leaf_node(select_iter):
                log.debug("Assistant: Page 0: Enabling 'Next' button")
                self.assistant.set_page_complete(self.builder.get_object("placeinput"),True)

    #Check, that selected row is a leaf and enable "next" button    
    def is_location_and_leaf_node(self, iter):
        row = self.__all_locations_store[iter]
        is_leaf_node = not self.__all_locations_store.iter_has_child(iter)
        return row[0] is not None and row[1] is not None and is_leaf_node

    # Create a location out of a tree
    def get_city(self,current_page):
        log.debug("Assistant: moved to page %s" % current_page)
        if self.assistant.get_current_page() == 1:
            select_iter = self.__all_locations_selection.get_selected()[1]
            city_iter = self.__all_locations_store[select_iter]
            self.city_code = city_iter[3]
            log.debug("Assistant: Page %s: got location with code %s" % (current_page, self.city_code))
            self.location = Location(wi.metric_system, wi._wind_unit)
            self.location.find_city_by_code(self.city_code)
            if self.location.found:
                log.debug("Assistant: Page %s: City %s found, full name - %s" %
                        (current_page, self.location.get_short_city_name(), self.location.get_full_city_name()))
                self.builder.get_object("lblplace").set_label('<big>%s</big>' % self.location.get_full_city_name())
                self.builder.get_object("entrylbl").set_text(self.location.get_short_city_name())
            else:
                log.error("Assistant: Page %s: City with code %s was NOT found" % (current_page, self.city_code))
        elif self.assistant.get_current_page() == 2:
            lbl = self.builder.get_object("entrylbl").get_text()
            log.debug("Assistant: Page %s: City label is %s" % (current_page, lbl))
            if lbl == '':
                log.debug("Assistant: Page %s: Empty label found, setting lbl to short name - %s label is %s" %
                    (current_page, self.location.get_short_city_name()))
                lbl = self.location.get_short_city_name()
            self.location.set_label(lbl)
            self.builder.get_object("lbl3").set_label('Label:')
            self.builder.get_object("labellbl").set_label('<b>%s</b>' % self.location.label)
            self.builder.get_object("placelbl").set_label('<b>'+self.location.get_full_city_name()+'</b>')
            
        return self.assistant.get_current_page() + 1
            
    def on_cancel(self,widget):
        log.debug("Assistant: Cancelled")
        self.destroy()
        
    def on_apply(self,widget):
        log.debug("Assistant: Apply: adding location ('%s', '%s')" % (self.location.label, self.location.code))
        newplace = list()
        newplace.append(self.location.label)
        newplace.append(self.location.code)
        wi.prefswindow.builder.get_object('citieslist').append(newplace)
        wi.prefswindow.builder.get_object('button1').set_sensitive(True)
        self.hide()

class singleinstance(object):
    '''
    singleinstance - based on Windows version by Dragan Jovelic this is a Linux
                     version that accomplishes the same task: make sure that
                     only a single instance of an application is running.
    '''
    def __init__(self, pidPath):
        '''
        pidPath - full path/filename where pid for running application is to be
                  stored.  Often this is ./var/<pgmname>.pid
        '''
        self.pidPath=pidPath
        # See if pidFile exists
        if os.path.exists(pidPath):
            log.debug("SingleInstance: pid file %s exists" % pidPath)
            # Make sure it is not a "stale" pidFile
            pid=open(pidPath, 'r').read().strip()
            # Check list of running pids, if not running it is stale so
            # overwrite
            pidRunning=commands.getoutput('ls /proc | grep %s' % pid)
            log.debug("SingleInstance: pid running %s" % pidRunning)
            if pidRunning:
                self.lasterror=True
            else:
                self.lasterror=False
        else:
            self.lasterror=False

        if not self.lasterror:
            log.debug("SingleInstance: writing new pid %s" % str(os.getpid()))
            # Write my pid into pidFile to keep multiple copies of program from
            # running.
            fp=open(pidPath, 'w')
            fp.write(str(os.getpid()))
            fp.close()

    def alreadyrunning(self):
        return self.lasterror

    def __del__(self):
        if not self.lasterror:
            log.debug("SingleInstance: deleting %s" % self.pidPath)
            os.unlink(self.pidPath)

def main():
    gtk.main()
    return 0

if __name__ == "__main__":
    #Enable and configure logs
    log_filename = os.path.join(os.path.expanduser("~/.cache"), "indicator-weather.log")
    log = logging.getLogger('IndicatorWeather')
    log.setLevel(logging.DEBUG)
    log_handler = logging.handlers.RotatingFileHandler(log_filename, maxBytes=1024*1024, backupCount=5)
    log_formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    log_handler.setFormatter(log_formatter)
    log.addHandler(log_handler)

    log.info("------------------------------")
    log.info("Started Weather Indicator from %s" % PROJECT_ROOT_DIRECTORY)

    # Single instance stuff for weather indicator
    myapp = singleinstance("/tmp/weather-indicator.pid")
    # check is another instance of same program running
    if myapp.alreadyrunning():
        log.info("Another instance of this program is already running")
        sys.exit(_("Another instance of this program is already running"))
        
    # not running, safe to continue...
    gtk.gdk.threads_init()
    gtk.gdk.threads_enter()
    wi = indicator_weather()
    main()
    gtk.gdk.threads_leave()
