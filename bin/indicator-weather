#!/usr/bin/python
# -*- coding: utf-8 -*-
### BEGIN LICENSE
# Copyright (C) 2010 Sebastian MacDonald Sebas310@gmail.com
# Copyright (C) 2010 Mehdi Rejraji mehd36@gmail.com
# This program is free software: you can redistribute it and/or modify it 
# under the terms of the GNU General Public License version 3, as published 
# by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranties of 
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
# PURPOSE.  See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along 
# with this program.  If not, see <http://www.gnu.org/licenses/>.
### END LICENSE

import sys
import os
import gtk
import pygtk
pygtk.require('2.0')
import gobject
import appindicator
import gconf
import urllib2
import re
import datetime
import locale
import pynotify
from xml.dom.minidom import parseString
import time

import gettext
from gettext import gettext as _
gettext.textdomain('indicator-weather')

from gweather.I_KNOW_THIS_IS_UNSTABLE import gweather
import pymetar as metar

# Add project root directory (enable symlink, and trunk execution).
PROJECT_ROOT_DIRECTORY = os.path.abspath(
    os.path.dirname(os.path.dirname(os.path.realpath(sys.argv[0]))))

if (os.path.exists(os.path.join(PROJECT_ROOT_DIRECTORY, 'indicator_weather'))
    and PROJECT_ROOT_DIRECTORY not in sys.path):
    sys.path.insert(0, PROJECT_ROOT_DIRECTORY)
    os.putenv('PYTHONPATH', PROJECT_ROOT_DIRECTORY) # for subprocesses

from indicator_weather.helpers import get_builder

gconfClient = gconf.client_get_default()

class Location:
    """
    Data object which contains the name of a city (label), its GWeather object "location"
    """

    #Initialize an object with a label
    def __init__(self, metric_system, wind_units):
        self.__metric_system = metric_system
        self.__wind_units = wind_units
        self.__found = False
        self.__lat = None
        self.__lon = None

    # Get a full city name
    def get_full_city_name(self):
        # We're getting a parent here, as 'location' here is actually a weather station
        self.__city = self.__location.get_parent()
        self.__full_city_name = ""
        while (self.__city.get_parent() != None):
            self.__full_city_name += "%s, " % self.__city.get_name()
            self.__city = self.__city.get_parent()
        self.__full_city_name += "%s" % self.__city.get_name()
        return self.__full_city_name

    #Internal proc - iterate by known locations to find a city by its name
    def __find_city_by_name (self, node, city_name):
        if (node.get_name() == city_name):
            #FIXME: City may have several weather stations - we're selecting the first one only
            if (node.get_children() != None):
                return node.get_children()[0];
        else:
            for obj in node.get_children():
                possible_city = self.__find_city_by_name(obj, city_name)
                if (possible_city != None):
                    return possible_city;
    
    #Internal proc - iterate by known locations to find city by its code
    def __find_city_by_code (self, node, city_code):
        if (node.get_code() == city_code):
            return node;
        else:
            for obj in node.get_children():
                possible_city = self.__find_city_by_code(obj, city_code)
                if (possible_city != None):
                    return possible_city;

    #Fill in location attribute, looking up by location name
    def find_city_by_name (self, city_name):
        location = self.__find_city_by_name(gweather.location_new_world(False), city_name)
        self.prepare_location(location)

    #Fill in location attribute, looking up by location code
    def find_city_by_code (self, city_code):
        location = self.__find_city_by_code(gweather.location_new_world(False), city_code)
        self.prepare_location(location)

    #Prepare metar reporter for the location
    def prepare_location(self, location):
        if (location != None):
            self.__location = location
            self.__code = location.get_code()
            self.__lat = location.get_coords()[0]
            self.__lon = location.get_coords()[1]
            self.__report_fetcher = metar.ReportFetcher(self.__code)
            self.__found = True
        else:
            self.__found = False

    def set_label(self, value):
        self.__label = value

    @property
    def code(self):
        return self.__code

    @property
    def found(self):
        return self.__found

    @property
    def label(self):
        return self.__label

    @property
    def weather(self):
        return self.__weather

    #Get sun status
    def get_sun_data(self):
        if (self.found):
            now = datetime.datetime.now()
            url = 'http://www.earthtools.org/sun/%s/%s/%s/%s/99/1' % (self.__lat,self.__lon,now.day,now.month)
            try:
                f = urllib2.urlopen(url)
                s=f.read()
                parsed = parseString(s)
                sunrise = parsed.getElementsByTagName("morning")[0].getElementsByTagName("civil")[0].firstChild.nodeValue
                sunset  = parsed.getElementsByTagName("evening")[0].getElementsByTagName("civil")[0].firstChild.nodeValue
            #sunrise = parsed.getElementsByTagName("sunrise")[0].firstChild.nodeValue
            #sunset = parsed.getElementsByTagName("sunset")[0].firstChild.nodeValue
                timezone = parsed.getElementsByTagName("timezone")[0].firstChild.nodeValue
                return (sunrise, sunset, timezone)
            except urllib2.URLError:
                print "error reaching url %s" % url
                return ("", "", "")
        else:
            print "Can't gather sun data on empty location"

    #Update weather data and store weather object
    def update_weather_data(self):
        if (self.__report_fetcher != None):
            try:
                self.__fetched_report = self.__report_fetcher.FetchReport()
                self.__weather_report = metar.ReportParser(self.__fetched_report).ParseReport()
                self.__sun_report = self.get_sun_data();
                self.__weather = Weather(self.__weather_report, self.__sun_report, self.__metric_system, self.__wind_units)
            except urllib2.URLError:
                self.__found = False
                print "error fetching report"

    #Get and store forecast data - use Google
    def prepare_forecast_data(self):
        import locale
        localebad = locale.getlocale()[0]
        locale = localebad.split ('_')
        #Here we generate a string, compiled of latitude and longitude for location
        self.coord_string = (",,,%.6f,%.6f" % (self.__lat, self.__lon)).replace(".","")
        url = "http://www.google.com/ig/api?weather=" + self.coord_string + "&hl=" + locale[0]
        print "url:\n%s" % url
        try:
            f = urllib2.urlopen(url)
            s = f.read()
            encoding = f.headers['content-type'].split('charset=')[-1]
            s = unicode(s, encoding).encode('utf-8').replace("&#39;", "'")
            self.unitsystem = s.split("<unit_system data=\"")[-1].split("\"")[0]
            self.__parsedforecast = parseString(s)
        except urllib2.URLError:
            print "error reaching url %s" % url
        #FIXME: check for errors here

    #Parse a list of days of week with forecast data
    def get_forecast_daysofweek(self):
        self.daysofweek = []
        for day_of_week in self.__parsedforecast.getElementsByTagName("day_of_week"):
                self.daysofweek.append([day_of_week.attributes["data"].value][0])
        return self.daysofweek

    #Parse high values for forecast data
    def get_forecast_highdata(self):
        self.highdata = []
        if ((self.unitsystem == 'SI') and (self.__metric_system == MetricSystem.SI)) or ((self.unitsystem == 'US') and (self.__metric_system == MetricSystem.IMPERIAL)):
            #correct scale selected
            for high in self.__parsedforecast.getElementsByTagName("high"):
                self.highdata.append([high.attributes["data"].value][0])
        elif ((self.unitsystem == 'SI') and (self.__metric_system == MetricSystem.IMPERIAL)):
            #convert from SI to imperial
            for high in self.__parsedforecast.getElementsByTagName("high"):
                self.highdata.append(int(((int([high.attributes["data"].value][0])*9)/5)+32))
        elif ((self.unitsystem == 'US') and (self.__metric_system == MetricSystem.SI)):
            #convert from imperial to SI
            for high in self.__parsedforecast.getElementsByTagName("high"):
                self.highdata.append(int((((int([high.attributes["data"].value][0]))-32)*5)/9))
        return self.highdata

    #Parse low values for forecast data
    def get_forecast_lowdata(self):
        self.lowdata = []
        if ((self.unitsystem == 'SI') and (self.__metric_system == MetricSystem.SI)) or ((self.unitsystem == 'US') and (self.__metric_system == MetricSystem.IMPERIAL)):
            #correct scale selected
            for low in self.__parsedforecast.getElementsByTagName("low"):
                self.lowdata.append([low.attributes["data"].value][0])
        elif ((self.unitsystem == 'SI') and (self.__metric_system == MetricSystem.IMPERIAL)):
            #convert from SI to imperial
            for low in self.__parsedforecast.getElementsByTagName("low"):
                self.lowdata.append(int(((int([low.attributes["data"].value][0])*9)/5)+32))
        elif ((self.unitsystem == 'US') and (self.__metric_system == MetricSystem.SI)):
            #convert from imperial to SI
            for low in parsed.getElementsByTagName("low"):
                self.lowdata.append(int((((int([low.attributes["data"].value][0]))-32)*5)/9))
        return self.lowdata

    #Parse icons for forecast data
    def get_forecast_icons(self):
        self.icons = []
        for icon in self.__parsedforecast.getElementsByTagName("icon"):
                self.icons.append([icon.attributes["data"].value][0].split("/ig/images/weather/")[-1].split(".gif")[0])
        return self.icons

    #Parse conditions for forecast data
    def get_forecast_conditions(self):
        self.conditions = []
        for condition in self.__parsedforecast.getElementsByTagName("condition"):
            self.conditions.append([condition.attributes["data"].value][0])
        return self.conditions
        
class MetricSystem:
    SI = 1
    IMPERIAL = 2

class WindUnits:
    MPS = 1
    MPH = 2
    BEAUFORT = 3
    KNOTS = 4

class Weather:
    """
    Data object to parse metar weather object and convert units
    """
    
    #Available conditions and their icons
    # The following format is used:
    # pymetar name: (translated name, day icon name, night icon name, is severe) 
    _WeatherConditions = {
        #FIXME: Do we really have to copypaste these key values?

        #Clear
        "sunny"                   : ( _("Sunny"),          "weather-clear", False),
        "mostly sunny"            : ( _("Mostly sunny"),   "weather-clear", False),
        "partly sunny"            : ( _("Partly sunny"),   "weather-clear", False),
        "clear"                   : ( _("Clear"),          "weather-clear", False),
        "clear sky"               : ( _("Clear sky"),      "weather-clear", False),
        "becoming sunny"          : ( _("Becoming sunny"), "weather-clear", False),

        #Clouds
        "mostly cloudy"           : ( _("Mostly cloudy"),     "weather-clouds",   False),
        "increasing clouds"       : ( _("Increasing clouds"), "weather-clouds",   False),
        "decreasing clouds"       : ( _("Decreasing clouds"), "weather-clouds",   False),
        "broken clouds"           : ( _("Broken clouds"),     "weather-clouds",   False),
        "scattered clouds"        : ( _("Scattered clouds"),  "weather-overcast", False),
        "overcast"                : ( _("Overcast"),          "weather-overcast", False),

        #Few clouds
        "few clouds"              : ( _("Few clouds"),       "weather-few-clouds", False),
        "partly cloudy"           : ( _("Partly cloudy"),    "weather-few-clouds", False),
        "becoming cloudy"         : ( _("Becoming cloudy"),  "weather-few-clouds", False),
        "clearing"                : ( _("Clearing"),         "weather-few-clouds", False),
        "gradual clearing"        : ( _("Gradual clearing"), "weather-few-clouds", False),
        "clearing late"           : ( _("Clearing late"),    "weather-few-clouds", False),

        #Fog
        "fog"                     : ( _("Fog"),                  "weather-fog", False),
        "patchy fog"              : ( _("Patchy fog"),           "weather-fog", False),
        "dense fog"               : ( _("Dense fog"),            "weather-fog", False),
        "areas fog"               : ( _("Areas fog"),            "weather-fog", False),
        "blowing dust"            : ( _("Blowing dust"),         "weather-fog", False),
        "blowing sand"            : ( _("Blowing sand"),         "weather-fog", False),
        "patchy haze"             : ( _("Patchy haze"),          "weather-fog", False),
        "areas haze"              : ( _("Areas haze"),           "weather-fog", False),
        "haze"                    : ( _("Haze"),                 "weather-fog", False),
        "patchy ice fog"          : ( _("Patchy ice fog"),       "weather-fog", False),
        "areas ice fog"           : ( _("Areas ice fog"),        "weather-fog", False),
        "ice fog"                 : ( _("Ice fog"),              "weather-fog", False),
        "patchy freezing fog"     : ( _("Patchy freezing fog"),  "weather-fog", False),
        "areas freezing fog"      : ( _("Areas freezing fog"),   "weather-fog", False),
        "freezing fog"            : ( _("Freezing fog"),         "weather-fog", False),
        "freezing spray"          : ( _("Freezing spray"),       "weather-fog", False),
        "patchy smoke"            : ( _("Patchy smoke"),         "weather-fog", False),
        "areas smoke"             : ( _("Areas smoke"),          "weather-fog", False),
        "smoke"                   : ( _("Smoke"),                "weather-fog", False),
        "patchy ash"              : ( _("Patchy ash"),           "weather-fog", False),
        "areas ash"               : ( _("Areas ash"),            "weather-fog", False),
        "ash"                     : ( _("Ash"),                  "weather-fog", False),
        "volcanic ash"            : ( _("Volcanic ash"),         "weather-fog", False),
        

        #Snow
        "light snow"                 : ( _("Light snow"),                 "weather-snow", False),
        "blowing snow"               : ( _("Blowing snow"),               "weather-snow", False),
        "blizzard"                   : ( _("Blizzard"),                   "weather-snow", False),
        "patchy ice crystals"        : ( _("Patchy ice crystals"),        "weather-snow", False),
        "areas ice crystals"         : ( _("Areas ice crystals"),         "weather-snow", False),
        "ice crystals"               : ( _("Ice crystals"),               "weather-snow", False),
        "patchy frost"               : ( _("Patchy frost"),               "weather-snow", False),
        "areas frost"                : ( _("Areas frost"),                "weather-snow", False),
        "frost"                      : ( _("Frost"),                      "weather-snow", False),
        "slight chance snow showers" : ( _("Slight chance snow showers"), "weather-snow", False),
        "chance snow showers"        : ( _("Chance snow showers"),        "weather-snow", False),
        "snow showers likely"        : ( _("Snow showers likely"),        "weather-snow", False),
        "snow showers"               : ( _("Snow showers"),               "weather-snow", False),
        "slight chance snow/rain"    : ( _("Slight chance snow/rain"),    "weather-snow", False),
        "chance snow/rain"           : ( _("Chance snow/rain"),           "weather-snow", False),
        "snow/rain likely"           : ( _("Snow/rain likely"),           "weather-snow", False),
        "snow/rain"                  : ( _("Snow/rain"),                  "weather-snow", False),
        "slight chance wintry mix"   : ( _("Slight chance wintry mix"),   "weather-snow", False),
        "chance wintry mix"          : ( _("Chance wintry mix"),          "weather-snow", False),
        "wintry mix likely"          : ( _("Wintry mix likely"),          "weather-snow", False),
        "wintry mix"                 : ( _("Wintry mix"),                 "weather-snow", False),
        "slight chance snow/sleet"   : ( _("Slight chance snow/sleet"),   "weather-snow", False),
        "chance snow/sleet"          : ( _("Chance snow/sleet"),          "weather-snow", False),
        "snow/sleet likely"          : ( _("Snow/sleet likely"),          "weather-snow", False),
        "snow/sleet"                 : ( _("Snow/sleet"),                 "weather-snow", False),

        #Rain
        "slight chance sleet"              : ( _("Slight chance sleet"),              "weather-showers", False),
        "chance sleet"                     : ( _("Chance sleet"),                     "weather-showers", False),
        "sleet likely"                     : ( _("Sleet likely"),                     "weather-showers", False),
        "sleet"                            : ( _("Sleet"),                            "weather-showers", False),
        "slight chance rain showers"       : ( _("Slight chance rain showers"),       "weather-showers", False),
        "chance rain showers"              : ( _("Chance rain showers"),              "weather-showers", False),
        "rain showers likely"              : ( _("Rain showers likely"),              "weather-showers", False),
        "rain showers"                     : ( _("Rain showers"),                     "weather-showers", False),
        "slight chance rain"               : ( _("Slight chance rain"),               "weather-showers", False),
        "chance rain"                      : ( _("Chance rain"),                      "weather-showers", False),
        "rain likely"                      : ( _("Rain likely"),                      "weather-showers", False),
        "rain"                             : ( _("Rain"),                             "weather-showers", False),
        "heavy rain"                       : ( _("Heavy rain"),                       "weather-showers", False),
        "slight chance drizzle"            : ( _("Slight chance drizzle"),            "weather-showers", False),
        "chance drizzle"                   : ( _("Chance drizzle"),                   "weather-showers", False),
        "drizzle likely"                   : ( _("Drizzle likely"),                   "weather-showers", False),
        "drizzle"                          : ( _("Drizzle"),                          "weather-showers", False),
        "slight chance freezing rain"      : ( _("Slight chance freezing rain"),      "weather-showers", False),
        "chance freezing rain"             : ( _("Chance freezing rain"),             "weather-showers", False),
        "freezing rain likely"             : ( _("Freezing rain likely"),             "weather-showers", False),
        "freezing rain"                    : ( _("Freezing rain"),                    "weather-showers", False),
        "slight chance freezing drizzle"   : ( _("Slight chance freezing drizzle"),   "weather-showers", False),
        "chance freezing drizzle"          : ( _("Chance freezing drizzle"),          "weather-showers", False),
        "freezing drizzle likely"          : ( _("Freezing drizzle likely"),          "weather-showers", False),
        "freezing drizzle"                 : ( _("Freezing drizzle"),                 "weather-showers", False),
        "slight chance rain/freezing rain" : ( _("Slight chance rain/freezing rain"), "weather-showers", False), 
        "chance rain/freezing rain"        : ( _("Chance rain/freezing rain"),        "weather-showers", False),
        "rain/freezing rain likely"        : ( _("Rain/freezing rain likely"),        "weather-showers", False),
        "rain/freezing rain"               : ( _("Rain/freezing rain"),               "weather-showers", False),

        #Storms
        "storm"                           : ( _("Storm"),                       "weather-storm", True),
        "isolated thunderstorms"          : ( _("Isolated thunderstorms"),      "weather-storm", True),
        "slight chance thunderstorms"     : ( _("Slight chance thunderstorms"), "weather-storm", True),
        "chance thunderstorms"            : ( _("Chance thunderstorms"),        "weather-storm", True),
        "thunderstorms likely"            : ( _("Thunderstorms likely"),        "weather-storm", True),
        "thunderstorm"                    : ( _("Thunderstorms"),               "weather-storm", True),
        "severe thunderstorms"            : ( _("Severe thunderstorms"),        "weather-storm", True),
        "water spout"                     : ( _("Water spout"),                 "weather-storm", True)
    }

    # Night icons for weather conditions
    _Night_Icons = {
        "weather-storm"      : "weather-storm",
        "weather-showers"    : "weather-showers",
        "weather-snow"       : "weather-snow",
        "weather-fog"        : "weather-fog",
        "weather-few-clouds" : "weather-few-clouds-night",
        "weather-overcast"   : "weather-overcast",
        "weather-clouds"     : "weather-clouds-night",
        "weather-clear"      : "weather-clear-night"
    }

    def __init__(self, weather_report, sun_report, metric_system, wind_unit):
        self.__report = weather_report
        self.__sun = sun_report
        self.__metric_system = metric_system
        self.__wind_unit = wind_unit
        self.__current_condition = None

        self.__get_weather_conditions = self.__report.getWeather()
        self.__get_conditions = self.__report.getConditions()
        self.__get_sky_conditions = self.__report.getSkyConditions()
        print "getWeather: '%s'" % self.__get_weather_conditions
        print "getConditions: "   , self.__get_conditions
        print "getSkyConditions: ", self.__get_sky_conditions
        if ((self.__report.getWeather() != None) and (self._WeatherConditions.get(self.__report.getWeather().lower()) != None)):
            self.__current_condition = self._WeatherConditions.get(self.__report.getWeather().lower())
        elif ((self.__report.getConditions()[0] != None) and (self._WeatherConditions.get(self.__report.getConditions()[0].lower()) != None)):
            self.__current_condition = self._WeatherConditions.get(self.__report.getConditions()[0].lower())
        elif ((self.__report.getSkyConditions() != None) and (self._WeatherConditions.get(self.__report.getSkyConditions().lower()) != None)):
            self.__current_condition = self._WeatherConditions.get(self.__report.getSkyConditions().lower())

        print "condition:", self.__current_condition

        #formatting sun data
        now = datetime.datetime.now().time()
        #FIXME: this is ugly
        self.__sunrise = self.__sun[0]
        print "Sunrise time " + self.__sun[0]
        self.__sunset = self.__sun[1]
        self.__sunrise_t = datetime.time(int(self.__sunrise.split(':')[0]), int(self.__sunrise.split(':')[1]), int(self.__sunrise.split(':')[2]))
        self.__sunset_t = datetime.time(int(self.__sunset.split(':')[0]), int(self.__sunset.split(':')[1]), int(self.__sunset.split(':')[2]))
        if now<self.__sunrise_t or now>self.__sunset_t:
            self.__night = True
        else:
			self.__night = False
    
    def isNight(self):
        return self.__night

    def isReportCorrect(self):
        return True if self.__report != None else False

    def isSevereCondition(self):
        if self.__current_condition != None:
            return self.__current_condition[2]
        else:
            print "BUG: Severe condition is empty!"
            return False;

    def getPureCondition(self):
        if self.__current_condition != None:
            return self.__current_condition[0]
        else:
            print "BUG: Condition name is empty!"
            return "BUG: Condition name is empty!";

    def getCondition(self):
        return "%s: %s" % (_("Condition"), self.getPureCondition())

    def getSkyCondition(self):
        return "%s: %s" % (_("Sky"), self.__report.getSkyConditions())

    def getPixmap(self):
        if self.__current_condition != None:
            if self.isNight:
                return self._Night_Icons.get(self.__current_condition[1])
            else:
                return self.__current_condition[1]
        else:
            print "BUG: Cannot get icon for weather condition"
            return "ubuntuone-client-offline"

    def getHumidity(self):
        return "%s: %s %s" % (_("Humidity"), self.__report.getHumidity(), "%")

    def getDewPoint(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getDewPointCelsius()
            _unit  = "C"
        else:
            _value = self.__report.getDewPointFahrenheit()
            _unit  = "F"
        return "%s: %s %s" % (_("Dew Point"), _value, _unit)

    def getPressure(self):
        return "%s: %s %s" % (_("Pressure"), self.__report.getPressure(), "hPa")

    def getTemperature(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getTemperatureCelsius()
            _unit  = "C"
        else:
            _value = self.__report.getTemperatureFahrenheit()
            _unit  = "F"
        return "%s: %s %s" % (_("Temperature"), _value, _unit)

    def getVisibility(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getVisibilityKilometers()
            _unit  = _("km")
        else:
            _value = self.__report.getVisibilityMiles()
            _unit  = _("mile(s)")
        return "%s: %s %s" % (_("Visibility"), _value, _unit)

    def getWindDirection(self):
        #FIXME: return a "SW" instead of "280" degrees values
        return "%s: %s" % (_("Wind Direction"), self.__report.getWindDirection())

    def getWindSpeed(self):
        if (self.__wind_unit == WindUnits.MPS):
            _value = self.__report.getWindSpeed()
            _unit  = _("mps")
        if (self.__wind_unit == WindUnits.MPH):
            _value = self.__report.getWindSpeedMilesPerHour()
            _unit  = _("mph")
        if (self.__wind_unit == WindUnits.BEAUFORT):
            _value = self.__report.getWindSpeedBeaufort()
            _unit  = ""
        if (self.__wind_unit == WindUnits.KNOTS):
            _value = self.__report.getWindSpeedKnots()
            _unit  = _("knot(s)")
        return "%s: %s %s" % (_("Wind Speed"), _value, _unit)

    def getWindChill(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getWindchill()
            _unit  = "C"
        else:
            _value = self.__report.getWindchillF()
            _unit  = "F"
        return "%s: %s %s" % (_("Wind Chill"), _value, _unit)

    def getSunrise(self):
        return "%s: %s" % (_("Sunrise"), time.strftime('%X',time.strptime(self.__sunrise,'%H:%M:%S')))

    def getSunset(self):
        return "%s: %s" % (_("Sunset"), time.strftime('%X',time.strptime(self.__sunset,'%H:%M:%S')))

class indicator_weather:
    def __init__(self):
        self.winder = appindicator.Indicator ("indicator-weather", "weather-clear", appindicator.CATEGORY_OTHER)
        self.winder.set_status (appindicator.STATUS_ACTIVE)
        self.winder.set_attention_icon ("ubuntuone-client-error")
        
        self.rate = gconfClient.get_int("/apps/indicator-weather/refresh_rate")
        self.unit = gconfClient.get_string("/apps/indicator-weather/unit")
        self.notif = gconfClient.get_string("/apps/indicator-weather/notif")
        self.wind = gconfClient.get_string("/apps/indicator-weather/wind")
        self.placechosen = gconfClient.get_int("/apps/indicator-weather/placechosen")
        self.labels = gconfClient.get_string("/apps/indicator-weather/places")
        self.places = gconfClient.get_string("/apps/indicator-weather/places")
        self.placesid = gconfClient.get_string("/apps/indicator-weather/placesid")
        
        if self.placechosen in (False, None):
            gconfClient.set_int("/apps/indicator-weather/placechosen", 0)
            self.placechosen = 0
        
        if self.unit in (False, None):
            gconfClient.set_string("/apps/indicator-weather/unit", 'S')
            self.unit = 'S'
        else:
            if (self.unit == 'S'):
                self.metric_system = MetricSystem.SI
            else:
                self.metric_system = MetricSystem.IMPERIAL
            
        if self.notif in (False, None):
            gconfClient.set_string("/apps/indicator-weather/notif", 'N')
            self.notif = 'N'
        
        if self.wind in (False, None):
            gconfClient.set_string("/apps/indicator-weather/wind", 'mph')
            self._wind_unit = WindUnits.MPH
        else:
            if (self.wind == 'mph'):
                self._wind_unit = WindUnits.MPH
            elif (self.wind == 'mps'):
                self._wind_unit = WindUnits.MPS
            elif (self.wind == 'beaufort'):
                self._wind_unit = WindUnits.BEAUFORT
            elif (self.wind == 'knots'):
                self._wind_unit = WindUnits.KNOTS
            
        if self.rate in (False, None):
            gconfClient.set_int("/apps/indicator-weather/refresh_rate", 5)
            self.rate = self.rate = gconfClient.get_int("/apps/indicator-weather/refresh_rate")
            
        if self.places in (False, None, '', '[]', "['']",):
            self.menu_noplace()
        else:
            self.places = eval(self.places)
            self.menu_normal()
            self.place = self.places[self.placechosen]
            self.update_weather()
            self.winder.set_menu(self.menu)
            
    def menu_noplace(self):
        menu_noplace = gtk.Menu()
        setup = gtk.MenuItem(_("Set Up Weather..."))
        setup.connect("activate", self.placeadding)
        setup.show()
        menu_noplace.append(setup)

        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        menu_noplace.append(quit)

        self.winder.set_menu(menu_noplace)
    
    def menu_normal(self):
        self.menu = gtk.Menu()
            
    ##City
        self.city_show = gtk.MenuItem()
        self.city_show.set_sensitive(True)
        self.menu.append(self.city_show)
        self.city_show.show()
        
    ##Condition
        self.cond_show = gtk.MenuItem()
        self.cond_show.set_sensitive(True)
        self.cond_show.show()
        self.menu.append(self.cond_show)
        
    ##Temperature        
        self.temp_show = gtk.MenuItem()
        self.temp_show.set_sensitive(True)
        self.temp_show.show()
        self.menu.append(self.temp_show)
        
    ##Humidity
        self.humid_show = gtk.MenuItem()
        self.humid_show.set_sensitive(True)
        self.humid_show.show()
        self.menu.append(self.humid_show)
        
    ##Wind
        self.wind_show = gtk.MenuItem()
        self.wind_show.set_sensitive(True)
        self.wind_show.show()
        self.menu.append(self.wind_show)
                
    ##Sunrise
        self.sunrise_show = gtk.MenuItem()
        self.sunrise_show.set_sensitive(True)
        self.sunrise_show.show()
        self.menu.append(self.sunrise_show)

    ##Sunset
        self.sunset_show = gtk.MenuItem()
        self.sunset_show.set_sensitive(True)
        self.sunset_show.show()
        self.menu.append(self.sunset_show)
        
    ##Cities
        if len(self.places) != 1:
            ##Breaker
            breaker = gtk.SeparatorMenuItem()
            breaker.show()
            self.menu.append(breaker)
            
            loco1 = gtk.RadioMenuItem(None, self.places[0][1])
            if self.placechosen == 0:
                loco1.set_active(True)
            loco1.connect("toggled", self.on_city_changed)
            loco1.show()
            self.menu.append(loco1)
            for place in self.places[1:]:
                loco = gtk.RadioMenuItem(loco1, place[1])
                if self.places.index(place) == self.placechosen:
                    loco.set_active(True)
                loco.connect("toggled", self.on_city_changed)
                loco.show()
                self.menu.append(loco)
        
    ##Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)
        
        ext_show = gtk.MenuItem(_("Forecast..."))
        ext_show.connect("activate", self.extforecast)
        ext_show.show()
        self.menu.append(ext_show)
    ##Preferences      
        prefs_show = gtk.MenuItem(_("Preferences..."))
        prefs_show.connect("activate", self.prefs)
        prefs_show.show()
        self.menu.append(prefs_show)

        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        self.menu.append(quit)
        
    def placeadding(self,widget):
        self.placeadded = ''
        self.assistant = Assistant()
        self.assistant.show()
        
    def rebuild_menu(self):
        for item in self.menu.get_children()[7:len(self.menu.get_children())]:
            item.destroy()
        
    ##Cities
        if len(self.places) != 1:
            ##Breaker
            breaker = gtk.SeparatorMenuItem()
            breaker.show()
            self.menu.append(breaker)
            
            loco1 = gtk.RadioMenuItem(None, self.places[0][1])
            if self.placechosen == 0:
                loco1.set_active(True)
            loco1.connect("toggled", self.on_city_changed)
            loco1.show()
            self.menu.append(loco1)
            for place in self.places[1:]:
                loco = gtk.RadioMenuItem(loco1, place[1])
                if self.places.index(place) == self.placechosen:
                    loco.set_active(True)
                loco.connect("toggled", self.on_city_changed)
                loco.show()
                self.menu.append(loco)
    ##Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)
        
        ext_show = gtk.MenuItem(_("Forecast..."))
        ext_show.connect("activate", self.extforecast)
        ext_show.show()
        self.menu.append(ext_show)
    ##Preferences      
        prefs_show = gtk.MenuItem(_("Preferences..."))
        prefs_show.connect("activate", self.prefs)
        prefs_show.show()
        self.menu.append(prefs_show)

        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        self.menu.append(quit)
        
        self.winder.set_menu(self.menu)

    def on_city_changed(self,widget):
        if widget.get_active():
            for place in self.places:
                if (place[1] == widget.get_label()):
                    self.placechosen = self.places.index(place)
                    break
            gconfClient.set_int("/apps/indicator-weather/placechosen", self.placechosen)
            self.update_weather(False)

    def update_weather(self, notif=True,widget=None):
        self.rateid = gobject.timeout_add(int(self.rate) * 60000, self.update_weather)
        weather = self.get_weather(self.places[self.placechosen])
        if weather == None:
			for item in self.menu.get_children()[0:len(self.menu.get_children())]:
				item.destroy()
			self.problem_show = gtk.MenuItem(_("Connection problem"))
			self.problem_show.set_sensitive(False)
			self.problem_show.show()
			self.menu.append(self.problem_show)
			self.winder.set_icon("ubuntuone-client-error")
			return
		
        self.condition = weather.getPureCondition()
        self.icon = weather.getPixmap()
        if (self.icon == False):
			self.winder.set_icon("ubuntuone-client-error")
        else:
        	self.winder.set_icon(self.icon)
        
        print 'Update :',weather.getPureCondition(),'(every',self.rate,'min. for',self.places[self.placechosen][1]+')'

        #self.city_table.attach(gtk.Label("City"), 0, 1, 0, 1)
        
        self.city_show.set_label(self.places[self.placechosen][1])
        self.cond_show.set_label(self.condition)
        self.temp_show.set_label(weather.getTemperature())
        self.humid_show.set_label(weather.getHumidity())
        self.wind_show.set_label(weather.getWindSpeed())
        self.sunrise_show.set_label(weather.getSunrise())
        self.sunset_show.set_label(weather.getSunset())       
        
        if self.notif != 'N' and weather.isSevereCondition():
	        if self.condition != gconfClient.get_string("/apps/indicator-weather/current") and self.notif == 'U':
	            self.notify(self.condition, self.icon)
            #FIXME: Fix notitfications on severe events
            #elif current in ('thunderstorm', 'chance_of_tstorm') and self.notif == 'O':
	        #    self.notify(self.condition, self.icon, severe=True)
	            
        gconfClient.set_string("/apps/indicator-weather/current",self.condition)
                
    def responseToDialog(self, entry, dialog, response):
        dialog.response(response)
        
    def getText(self, replace=True):
        dialog = gtk.MessageDialog(
            None,
            gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
            gtk.MESSAGE_QUESTION,
            gtk.BUTTONS_OK,
            None)
        dialog.set_markup('Please enter your address:')
        entry = gtk.Entry()
        entry.connect("activate", self.responseToDialog, dialog, gtk.RESPONSE_OK)
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Address:"), False, 5, 5)
        hbox.pack_end(entry)
        dialog.vbox.pack_end(hbox, True, True, 0)
        dialog.show_all()
        dialog.run()
        if replace == False:
            if not (entry.get_text() in self.places):
                self.places.append(entry.get_text())
                gconfClient.set_string("/apps/indicator-weather/places", str([self.places]))
                dialog.destroy()
                return True
            else:
                dialog.destroy()
                return False
        else:
            self.places = list()
            self.places.append(entry.get_text())
            gconfClient.set_string("/apps/indicator-weather/places", str([self.places]))
        dialog.destroy()
        self.update_weather()
            
    def get_weather(self, city, firstrun=False, extended=False, onlycity=False):
        if ((len(city[0]) == 1) or (city[0] == "Enter Location")):
            return ""
        location = Location(self.metric_system, self._wind_unit)
        if (location.find_city_by_code(city[0]) == False):
            print "location with code %s not found" % city[0]    
        if extended == False:
            location.update_weather_data()
            if (location.found == False) or (location.weather.isReportCorrect() == False):
                print "report is empty";
                return None;
            else:
                return location.weather
        else:
            #FIXME: extended report should be gathered from Google
            location.prepare_forecast_data()
            self.daysofweek = location.get_forecast_daysofweek()
            self.lowdata    = location.get_forecast_lowdata()
            self.highdata   = location.get_forecast_highdata()
            self.icons      = location.get_forecast_icons()
            self.conditions = location.get_forecast_conditions()
        
    def prefs(self, widget):
        self.prefswindow = PreferencesDialog()
        self.prefswindow.show()
        
    def extforecast(self,widget):
        forecastwd = ExtendedForecast()
        forecastwd.show()
        
    def addlocation(self,widget):
        self.getText()
        self.menu_normal()
        self.place = self.places[self.placechosen]
        self.update_weather(False)
        self.winder.set_menu(self.menu)
        
    def notify(self,conditon,icon,severe=False):
        if severe:
			n = pynotify.Notification (_("Severe weather alert"),
                self.condition,
                icon)
        else:
		    n = pynotify.Notification (self.condition,"",icon)
        n.show ()

    def quit(self, widget, data=None):
        gtk.main_quit()

class PreferencesDialog(gtk.Dialog):
    __gtype_name__ = "PreferencesDialog"
    def __new__(cls):
        builder = get_builder('PreferencesDialog')
        new_object = builder.get_object("preferences_dialog")
        new_object.finish_initializing(builder)
        return new_object

    def finish_initializing(self, builder):
        self.builder = builder
        if wi.unit == 'S':
            self.builder.get_object('si').set_active(True)
        elif wi.unit == 'I':
            self.builder.get_object('imperial').set_active(True)
        if wi.notif == 'N':
            self.builder.get_object('nonotif').set_active(True)
        elif wi.notif == 'O':
            self.builder.get_object('notifsevere').set_active(True)
        else:
            self.builder.get_object('notifall').set_active(True)            
        
        if wi.wind == 'mps':
            self.builder.get_object('mps').set_active(True)
        elif wi.wind == 'mph':
            self.builder.get_object('mph').set_active(True)
        elif wi.wind == 'knots':
            self.builder.get_object('knots').set_active(True)
        else:
            self.builder.get_object('beaufort').set_active(True)
        
        self.builder.get_object('rate').set_value(wi.rate)
        end = len(wi.places)
        for place in wi.places:
            newplace = list()
            newplace.append(place[1])
            newplace.append(place[0])
            
            self.builder.get_object('citieslist').append(newplace)
            
        self.builder.connect_signals(self)
        
    def on_remove_location(self,widget):
        selection = self.builder.get_object('displaylist').get_selection()
        model, iter = selection.get_selected()
        if iter != None:
            model.remove(iter)
    
    def on_add_location(self, widget):
        self.assistant2 = Assistant2()
        self.assistant2.show()
       
    def on_destroy(self, widget, data=None):
        pass
        #"""Called when the WeatherIndicatorWindow is closed."""
        #gtk.main_quit()
    #def on_city_edited(self,widget,path,value):
        ###CHECK AVAILABILITY
        #self.builder.get_object('citieslist').set_value(self.builder.get_object('citieslist').get_iter_from_string(path), 0, value)
    
    def ok(self, widget, data=None):
        """The user has selected to save the changes.

        Called before the dialog returns gtk.RESONSE_OK from run().
        """
        needupdate = False
        # Metric System
        for button in self.builder.get_object('si').get_group():
            if button.get_active() == True and button.get_label()[0] != wi.unit:
                gconfClient.set_string("/apps/indicator-weather/unit", button.get_label()[0])
                wi.unit = button.get_label()[0]
                if wi.unit == 'S':
                    wi.metric_system = MetricSystem.SI
                else:
                    wi.metric_system = MetricSystem.IMPERIAL
                needupdate = True
                print 'Unit changed :', wi.unit

        # Wind Units
        for button in self.builder.get_object('mps').get_group():
            if button.get_active() == True and button.get_label().lower() != wi.wind:
                gconfClient.set_string("/apps/indicator-weather/wind", button.get_label().lower())
                wi.wind = button.get_label().lower()
                #FIXME: thats ugly
                if (wi.wind == 'mph'):
                    wi._wind_unit = WindUnits.MPH
                elif (wi.wind == 'mps'):
                    wi._wind_unit = WindUnits.MPS
                elif (wi.wind == 'beaufort'):
                    wi._wind_unit = WindUnits.BEAUFORT
                elif (wi.wind == 'knots'):
                    wi._wind_unit = WindUnits.KNOTS
                needupdate = True
                print 'Wind Unit changed :', wi.wind

        # Notifications
        for button in self.builder.get_object('nonotif').get_group():
            if button.get_active() == True and button.get_label()[0] != wi.notif:
                gconfClient.set_string("/apps/indicator-weather/notif", button.get_label()[0])
                wi.notif = button.get_label()[0]
                print 'Notifications changed :', wi.notif
                
        ##Rate
        if int(self.builder.get_object('rate').get_value()) != wi.rate:
            gconfClient.set_int("/apps/indicator-weather/refresh_rate", int(self.builder.get_object('rate').get_value()))
            wi.rate = int(self.builder.get_object('rate').get_value())
            gobject.source_remove(wi.rateid)
            wi.rateid = gobject.timeout_add(int(wi.rate) * 60000, wi.update_weather)
            print 'Rate changed :',wi.rate
            
        ##places
        newplaces = list()
        item = self.builder.get_object('citieslist').get_iter_first()
        while ( item != None ):
            newplace = list()
            newplace.append(self.builder.get_object('citieslist').get_value (item, 1))
            newplace.append(self.builder.get_object('citieslist').get_value (item, 0))
            newplaces.append(newplace)
            item = self.builder.get_object('citieslist').iter_next(item)
        if newplaces != wi.places:
            wi.places = newplaces
            if len(wi.places) >= 1:
                gconfClient.set_string("/apps/indicator-weather/places", str(wi.places))
                if wi.place in wi.places:
                    wi.placechosen = wi.places.index(wi.place)
                else:
                    wi.placechosen = 0
                gconfClient.set_int("/apps/indicator-weather/placechosen", wi.placechosen)
                wi.rebuild_menu()
                needupdate = True
            else:
                wi.placechosen = 0
                gconfClient.set_int("/apps/indicator-weather/placechosen", wi.placechosen)
                gconfClient.set_string("/apps/indicator-weather/places", str([wi.places]))
                wi.winder.set_icon("weather-clear")
                wi.menu_noplace()
                needupdate = False
            
        ##Wind
        #for button in self.builder.get_object('m/s').get_group():
            #if button.get_active() == True and button.get_label() != wi.windunit:
                #gconfClient.set_string("/apps/indicator-weather/wind", button.get_label())
                #wi.windunit = button.get_label()
                #needupdate = True
                #print 'Wind changed :', wi.windunit
        
        if needupdate:
            wi.update_weather(False)
        
        # Make any updates to self._preferences here. e.g.
        #self._preferences["preference1"] = "value2"
        #self._save_preferences()
        self.destroy()

    def cancel(self, widget, data=None):
        """The user has elected cancel changes.

        Called before the dialog returns gtk.RESPONSE_CANCEL for run()
        """
        # Restore any changes to self._preferences here.
        self.destroy()
        
class ExtendedForecast(gtk.Window):
    __gtype_name__ = "ExtendedForecast"
    def __new__(cls):
        builder = get_builder('ExtendedForecast')
        new_object = builder.get_object("extended_forecast")
        new_object.finish_initializing(builder)
        return new_object
        
    def finish_initializing(self, builder):
        self.builder = builder
        self.builder.connect_signals(self)
        
        self.builder.get_object('extended_forecast').set_title(_('Weather Forecast for ')+wi.places[wi.placechosen][1])
        wi.get_weather(wi.places[wi.placechosen],False,True)
        
        self.builder.get_object('day1lbl').set_label('<big>'+wi.daysofweek[0].capitalize()+'</big>')
        self.builder.get_object('day2lbl').set_label('<big>'+wi.daysofweek[1].capitalize()+'</big>')
        self.builder.get_object('day3lbl').set_label('<big>'+wi.daysofweek[2].capitalize()+'</big>')
        self.builder.get_object('day4lbl').set_label('<big>'+wi.daysofweek[3].capitalize()+'</big>')
        i=0
        for icon in wi.icons[1:]:
            i=i+1
            if icon in ('chance_of_storm', 'storm', 'thunderstorm', 'chance_of_tstorm'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-storm',gtk.ICON_SIZE_BUTTON)
            elif icon in ('sleet',  'snow',  'icy',  'flurries',  'chance_of_snow'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-snow',gtk.ICON_SIZE_BUTTON)
            elif icon in ('dust',  'fog',  'smoke',  'haze',  'mist'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-fog',gtk.ICON_SIZE_BUTTON)
            elif icon in ('rain'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-showers',gtk.ICON_SIZE_BUTTON)
            elif icon in ('chance_of_rain'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-showers-scattered',gtk.ICON_SIZE_BUTTON)
            elif icon in ('sunny', 'clear'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-clear',gtk.ICON_SIZE_BUTTON)
            elif icon in ('mostly_cloudy', 'cloudy'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-overcast',gtk.ICON_SIZE_BUTTON)
            elif icon in ('mostly_sunny',  'partly_cloudy'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-few-clouds',gtk.ICON_SIZE_BUTTON)
            else:
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('window-close',gtk.ICON_SIZE_BUTTON)
        i=0
        for condition in wi.conditions[1:]:
            i=i+1
            self.builder.get_object('day%scond' % str(i)).set_label(condition)
        i=0
        if wi.unit == 'S':
            tempunit = '°C'
        elif wi.unit == 'I':
            tempunit = '°F'
        for high in wi.highdata:
            i=i+1
            self.builder.get_object('day%stemphigh' % str(i)).set_label((_('High: ')+'%s%s') % (high,tempunit))
        i=0
        for low in wi.lowdata:
            i=i+1
            self.builder.get_object('day%stemplow' % str(i)).set_label((_('Low: ')+'%s%s') % (low,tempunit))
        
    
    def close(self, widget, data=None):
        self.destroy()
    
    def on_destroy(self, widget, data=None):
        pass
        
#class EditPlace(gtk.MessageDialog):
    #__gtype_name__ = "EditPlace"
    #def __new__(cls):
        #builder = get_builder('EditPlace')
        #new_object = builder.get_object("edit_place")
        #new_object.finish_initializing(builder)
        #return new_object
        
    #def finish_initializing(self, builder):
        #self.builder = builder
        #self.builder.connect_signals(self)
    
    #def ok(self, widget, data=None):
        #self.destroy()
        #if self.builder.get_object("entry").get_text() != '':
            #return self.builder.get_object("entry").get_text()
        #else:
            #return False
        ###APPLY CHANGES
        
    #def cancel(self, widget, data=None):
        #"""The user has elected cancel changes.

        #Called before the dialog returns gtk.RESPONSE_CANCEL for run()
        #"""
        ## Restore any changes to self._preferences here.
        #self.destroy()
        #return False

class Assistant(gtk.Assistant):
    __gtype_name__ = "Assistant"
    
    def __new__(cls):
        builder = get_builder('Assistant')
        new_object = builder.get_object("assistant")
        new_object.finish_initializing(builder)
        return new_object
        
    def finish_initializing(self, builder):
        self.builder = builder
        self.builder.connect_signals(self)
        self.builder.get_object("assistant").set_page_complete(self.builder.get_object("chooseunit"),True)
        self.builder.get_object("assistant").set_page_complete(self.builder.get_object("label"),True)
        self.builder.get_object("assistant").set_page_complete(self.builder.get_object("review"),True)
        self.builder.get_object("assistant").set_forward_page_func(self.get_city)
        
    def on_find_location(self,widget):
        def get_my_ip_address():
            whatismyip = 'http://www.whatismyip.com/automation/n09230945.asp'
            try:
                return urllib2.urlopen(whatismyip).readlines()[0]
            except urllib2.URLError:
                print "error reaching url %s" % whatismyip
                return ""
        try:
            response = urllib2.urlopen('http://api.hostip.info/get_html.php?ip=%s' % get_my_ip_address()).read()
            m = re.search('City: (.*)', response)
            if m:
                self.builder.get_object("entry").set_text(m.group(1))
        except urllib2.URLError:
            print "error reaching url %s" % whatismyip
                
    def on_entry_edited(self,widget):
        if widget.get_text() == '':
            self.builder.get_object("assistant").set_page_complete(self.builder.get_object("placeinput"),False)
        else:
            self.builder.get_object("assistant").set_page_complete(self.builder.get_object("placeinput"),True)
    
    def get_city(self,current_page):
        if self.builder.get_object("assistant").get_current_page() == 1:
            self.city_name = self.builder.get_object("entry").get_text()
            #FIXME: Use new switches - metric system and Wind Units
            print "City name "+self.city_name
            self.location = Location(wi.metric_system, wi._wind_unit)
            self.location.find_city_by_name(self.city_name)
            if self.location.found:
                print "city was found"
                self.builder.get_object("lblplace").set_label('<big>%s</big>' % self.location.get_full_city_name())
                self.builder.get_object("assistant").set_page_complete(self.builder.get_object("confirmplace"),True)
                return 3
            else:
                print "city not found"
                return 2
        elif self.builder.get_object("assistant").get_current_page() == 4:
            lbl = self.builder.get_object("entrylbl").get_text()
            if lbl == '':
                self.location.set_label(self.city_name)
                self.builder.get_object("lbl3").set_label('')
            else:
                self.location.set_label(self.builder.get_object("entrylbl").get_text())
                self.builder.get_object("lbl3").set_label('Label:')

            self.builder.get_object("labellbl").set_label('<b>%s</b>' % self.location.label)
            for button in self.builder.get_object('si').get_group():
                if button.get_active() == True:
                    self.builder.get_object("unitlbl").set_label('<b>'+button.get_label()+'</b>')
            self.builder.get_object("placelbl").set_label('<b>'+self.city_name+'</b>')
            
        return self.builder.get_object("assistant").get_current_page() + 1
            
    def on_cancel(self,widget):
        self.destroy()
        
    def on_apply(self,widget):
        newplace = list()
        newplace.append(self.location.code)
        newplace.append(self.location.label)

        wi.placeadded = self.location.label
        wi.places = list()
        wi.places.append(newplace)

        newlocation = list()
        newlocation.append(self.location)
        wi.locations = list()
        wi.locations.append(newlocation)

        for button in self.builder.get_object('si').get_group():
            if button.get_active() == True and button.get_label()[0] != wi.unit:
                gconfClient.set_string("/apps/indicator-weather/unit", button.get_label()[0])
                wi.unit = button.get_label()[0]

        for button in self.builder.get_object('mps').get_group():
            if button.get_active() == True and button.get_label().lower() != wi.wind:
                gconfClient.set_string("/apps/indicator-weather/wind", button.get_label().lower())
                wi.unit = button.get_label().lower()
                #FIXME: thats ugly
                if (wi.wind == 'mph'):
                    wi._wind_unit = WindUnits.MPH
                elif (wi.wind == 'mps'):
                    wi._wind_unit = WindUnits.MPS
                elif (wi.wind == 'beaufort'):
                    wi._wind_unit = WindUnits.BEAUFORT
                elif (wi.wind == 'knots'):
                    wi._wind_unit = WindUnits.KNOTS
        
        self.hide()
        gconfClient.set_string("/apps/indicator-weather/places", str(wi.places))
        wi.menu_normal()
        wi.place = wi.places[wi.placechosen]
        wi.update_weather(False)
        wi.winder.set_menu(wi.menu)
        
class Assistant2(gtk.Assistant):
    __gtype_name__ = "Assistant2"
    def __new__(cls):
        builder = get_builder('Assistant2')
        new_object = builder.get_object("assistant2")
        new_object.finish_initializing(builder)
        return new_object
        
    def finish_initializing(self, builder):
        self.builder = builder
        self.builder.connect_signals(self)
        self.builder.get_object("assistant2").set_page_complete(self.builder.get_object("label"),True)
        self.builder.get_object("assistant2").set_forward_page_func(self.get_city)
        
    def on_find_location(self,widget):
        def get_my_ip_address():
            whatismyip = 'http://www.whatismyip.com/automation/n09230945.asp'
            try:
                return urllib2.urlopen(whatismyip).readlines()[0]
            except urllib2.URLError:
                print "error reaching url %s" % whatismyip
                return ""
        try:
            response = urllib2.urlopen('http://api.hostip.info/get_html.php?ip=%s' % get_my_ip_address()).read()
            m = re.search('City: (.*)', response)
            if m:
                self.builder.get_object("entry").set_text(m.group(1))
        except urllib2.URLError:
            print "error reaching url http://api.hostip.info/get_html.php?ip=%s" % get_my_ip_address()
            return ""

    def on_entry_edited(self,widget):
        if widget.get_text() == '':
            self.builder.get_object("assistant2").set_page_complete(self.builder.get_object("placeinput"),False)
        else:
            self.builder.get_object("assistant2").set_page_complete(self.builder.get_object("placeinput"),True)
    
    def get_city(self,current_page):
        if self.builder.get_object("assistant2").get_current_page() == 0:
            self.city_name = self.builder.get_object("entry").get_text()
            #FIXME: Use new switches - metric system and Wind Units
            self.location = Location(wi.metric_system, wi._wind_unit)
            self.location.find_city_by_name(self.city_name)
            if self.location.found:
                self.builder.get_object("lblplace").set_label('<big>%s</big>' % self.location.get_full_city_name())
                self.builder.get_object("assistant2").set_page_complete(self.builder.get_object("confirmplace"),True)
                return 2
            else:
                return 1
        return self.builder.get_object("assistant2").get_current_page() + 1
            
    def on_cancel(self,widget):
        self.destroy()
        
    def on_apply(self,widget):
        self.new_label = self.builder.get_object("entrylbl").get_text()
        if self.new_label == '':
            self.location.set_label(self.city_name)
        else:
            self.location.set_label(self.new_label)
        newplace = list()
        newplace.append(self.location.label)
        newplace.append(self.location.code)
        wi.prefswindow.builder.get_object('citieslist').append(newplace)
        self.hide()

def main():
    gtk.main()
    return 0

if __name__ == "__main__":
    wi = indicator_weather()
    main()
