#!/usr/bin/python
# -*- coding: utf-8 -*-
### BEGIN LICENSE
# Copyright (C) 2010 Sebastian MacDonald Sebas310@gmail.com
# Copyright (C) 2010 Mehdi Rejraji mehd36@gmail.com
# This program is free software: you can redistribute it and/or modify it 
# under the terms of the GNU General Public License version 3, as published 
# by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranties of 
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
# PURPOSE.  See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along 
# with this program.  If not, see <http://www.gnu.org/licenses/>.
### END LICENSE

import sys
import os
import gtk
import pygtk
pygtk.require('2.0')
import gobject
import appindicator
import gconf
import urllib2
import re
import datetime
import locale
import pynotify
from xml.dom.minidom import parseString
import time

import gettext
from gettext import gettext as _
gettext.textdomain('indicator-weather')

from gweather.I_KNOW_THIS_IS_UNSTABLE import gweather
import pymetar as metar

# Add project root directory (enable symlink, and trunk execution).
PROJECT_ROOT_DIRECTORY = os.path.abspath(
    os.path.dirname(os.path.dirname(os.path.realpath(sys.argv[0]))))

if (os.path.exists(os.path.join(PROJECT_ROOT_DIRECTORY, 'indicator_weather'))
    and PROJECT_ROOT_DIRECTORY not in sys.path):
    sys.path.insert(0, PROJECT_ROOT_DIRECTORY)
    os.putenv('PYTHONPATH', PROJECT_ROOT_DIRECTORY) # for subprocesses

from indicator_weather.helpers import get_builder

gconfClient = gconf.client_get_default()

class Location(object):
    """
    Data object which contains the name of a city (label), its GWeather object "location"
    """

    #Initialize an object with a label
    def __init__(self, metric_system, wind_units):
        self.__metric_system = metric_system
        self.__wind_units = wind_units
        self.__found = False
        self.__lat = None
        self.__lon = None

    # Get a full city name
    def get_full_city_name(self):
        # We're getting a parent here, as 'location' here is actually a weather station
        self.__city = self.__location.get_parent()
        self.__full_city_name = ""
        while (self.__city.get_parent() != None):
            self.__full_city_name += "%s, " % self.__city.get_name()
            self.__city = self.__city.get_parent()
        self.__full_city_name += "%s" % self.__city.get_name()
        return self.__full_city_name

    #Internal proc - iterate by known locations to find a city by its name
    def __find_city_by_name (self, node, city_name):
        if (node.get_name() == city_name):
            #FIXME: City may have several weather stations - we're selecting the first one only
            if (node.get_children() != None):
                return node.get_children()[0];
        else:
            for obj in node.get_children():
                possible_city = self.__find_city_by_name(obj, city_name)
                if (possible_city != None):
                    return possible_city;
    
    #Internal proc - iterate by known locations to find city by its code
    def __find_city_by_code (self, node, city_code):
        if (node.get_code() == city_code):
            return node;
        else:
            for obj in node.get_children():
                possible_city = self.__find_city_by_code(obj, city_code)
                if (possible_city != None):
                    return possible_city;

    #Fill in location attribute, looking up by location name
    def find_city_by_name (self, city_name):
        location = self.__find_city_by_name(gweather.location_new_world(False), city_name)
        self.prepare_location(location)

    #Fill in location attribute, looking up by location code
    def find_city_by_code (self, city_code):
        location = self.__find_city_by_code(gweather.location_new_world(False), city_code)
        self.prepare_location(location)

    def prepare_location(self, location):
        if (location != None):
            self.__location = location
            self.__code = location.get_code()
            self.__lat = location.get_coords()[0]
            self.__lon = location.get_coords()[1]
            self.__report_fetcher = metar.ReportFetcher(self.__code)
            self.__found = True
        else:
            self.__found = False

    def set_label(self, value):
        self.__label = value

    @property
    def code(self):
        return self.__code

    @property
    def found(self):
        return self.__found

    @property
    def label(self):
        return self.__label

    @property
    def weather(self):
        return self.__weather

    #Get sun status
    def get_sun_data(self):
        if (self.found):
            now = datetime.datetime.now()
            url = 'http://www.earthtools.org/sun/%s/%s/%s/%s/99/1' % (self.__lat,self.__lon,now.day,now.month)
            f = urllib2.urlopen(url)
            s=f.read()
            parsed = parseString(s)
            sunrise = parsed.getElementsByTagName("sunrise")[0].firstChild.nodeValue
            sunset = parsed.getElementsByTagName("sunset")[0].firstChild.nodeValue
            timezone = parsed.getElementsByTagName("timezone")[0].firstChild.nodeValue
            return (sunrise, sunset, timezone)
        else:
            print "Can't gather sun data on empty location"

    #Update weather data and store weather object
    def update_weather_data(self):
        if (self.__report_fetcher != None):
            self.__fetched_report = self.__report_fetcher.FetchReport()
            self.__weather_report = metar.ReportParser(self.__fetched_report).ParseReport()
            self.__sun_report = self.get_sun_data();
            self.__weather = Weather(self.__weather_report, self.__sun_report, self.__metric_system, self.__wind_units)

class MetricSystem:
    SI = 1
    IMPERIAL = 2

class WindUnits:
    MPS = 1
    MPH = 2
    BEAUFORT = 3
    KNOTS = 4

class Weather(object):
    """
    Data object to parse metar weather object and convert units
    """

    def __init__(self, weather_report, sun_report, metric_system, wind_unit):
        self.__report = weather_report
        self.__sun = sun_report
        self.__metric_system = metric_system
        self.__wind_unit = wind_unit

        #formatting sun data
        now = datetime.datetime.now().time()
        #FIXME: this is ugly
        self.__sunrise = self.__sun[0]
        self.__sunset = self.__sun[1]
        self.__sunrise_t = datetime.time(int(self.__sunrise.split(':')[0]), int(self.__sunrise.split(':')[1]), int(self.__sunrise.split(':')[2]))
        self.__sunset_t = datetime.time(int(self.__sunset.split(':')[0]), int(self.__sunset.split(':')[1]), int(self.__sunset.split(':')[2]))
        if now<self.__sunrise_t or now>self.__sunset_t:
            self.__night = True
        else:
			self.__night = False

    
    def isNight(self):
        return self.__night

    def isReportCorrect(self):
        return True if self.__report != None else False

    def getPureCondition(self):
        return self.__report.getWeather()

    def getCondition(self):
        #FIXME: Translation!
        return "%s: %s" % (_("Condition"), self.__report.getWeather())

    def getSkyCondition(self):
        return "%s: %s" % (_("Sky"), self.__report.getSkyConditions())

    def getPixmap(self):
        #FIXME: get pixmap name depending on the condition, time and sky
        return "weather-snow"

    def getHumidity(self):
        return "%s: %s %s" % (_("Humidity"), self.__report.getHumidity(), "%")

    def getDewPoint(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getDewPointCelsius()
            _unit  = "C"
        else:
            _value = self.__report.getDewPointFahrenheit()
            _unit  = "F"
        return "%s: %s %s" % (_("Dew Point"), _value, _unit)

    def getPressure(self):
        return "%s: %s %s" % (_("Pressure"), self.__report.getPressure(), "hPa")

    def getTemperature(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getTemperatureCelsius()
            _unit  = "C"
        else:
            _value = self.__report.getTemperatureFahrenheit()
            _unit  = "F"
        return "%s: %s %s" % (_("Temperature"), _value, _unit)

    def getVisibility(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getVisibilityKilometers()
            _unit  = _("km")
        else:
            _value = self.__report.getVisibilityMiles()
            _unit  = _("mile(s)")
        return "%s: %s %s" % (_("Visibility"), _value, _unit)

    def getWindDirection(self):
        #FIXME: return a "SW" instead of "280" degrees values
        return "%s: %s" % (_("Wind Direction"), self.__report.getWindDirection())

    def getWindSpeed(self):
        if (self.__wind_unit == WindUnits.MPS):
            _value = self.__report.getWindSpeed()
            _unit  = _("m\s")
        if (self.__wind_unit == WindUnits.MPH):
            _value = self.__report.getWindSpeedMilesPerHour()
            _unit  = _("mph")
        if (self.__wind_unit == WindUnits.BEAUFORT):
            _value = self.__report.getWindSpeedMilesPerHour()
            _unit  = ""
        if (self.__wind_unit == WindUnits.KNOTS):
            _value = self.__report.getWindSpeedMilesPerHour()
            _unit  = _("knot(s)")
        return "%s: %s %s" % (_("Wind Speed"), _value, _unit)

    def getWindChill(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getWindchill()
            _unit  = "C"
        else:
            _value = self.__report.getWindchillF()
            _unit  = "F"
        return "%s: %s %s" % (_("Wind Chill"), _value, _unit)

    def getSunrise(self):
        return "%s: %s" % (_("Sunrise"), time.strftime('%X',time.strptime(self.__sunrise,'%H:%M:%S')))

    def getSunset(self):
        return "%s: %s" % (_("Sunset"), time.strftime('%X',time.strptime(self.__sunset,'%H:%M:%S')))

class indicator_weather:
    def __init__(self):
        self.winder = appindicator.Indicator ("indicator-weather", "weather-clear", appindicator.CATEGORY_OTHER)
        self.winder.set_status (appindicator.STATUS_ACTIVE)
        self.winder.set_attention_icon ("ubuntuone-client-error")
        
        self.rate = gconfClient.get_int("/apps/indicator-weather/refresh_rate")
        self.unit = gconfClient.get_string("/apps/indicator-weather/unit")
        self.notif = gconfClient.get_string("/apps/indicator-weather/notif")
        #WIND#self.windunit = gconfClient.get_string("/apps/indicator-weather/wind")
        self.placechosen = gconfClient.get_int("/apps/indicator-weather/placechosen")
        self.labels = gconfClient.get_string("/apps/indicator-weather/places")
        self.places = gconfClient.get_string("/apps/indicator-weather/places")
        self.placesid = gconfClient.get_string("/apps/indicator-weather/placesid")
        
        if self.placechosen in (False, None):
            gconfClient.set_int("/apps/indicator-weather/placechosen", 0)
            self.placechosen = 0
        
        if self.unit in (False, None):
            gconfClient.set_string("/apps/indicator-weather/unit", 'F')
            self.unit = 'F'
            
        if self.notif in (False, None):
            gconfClient.set_string("/apps/indicator-weather/notif", 'N')
            self.notif = 'N'
        
        #if self.wind in (False, None):
            #gconfClient.set_string("/apps/indicator-weather/wind", 'mph')
            #self.windunit = 'mph'
            
        if self.rate in (False, None):
            gconfClient.set_int("/apps/indicator-weather/refresh_rate", 5)
            self.rate = self.rate = gconfClient.get_int("/apps/indicator-weather/refresh_rate")
            
        if self.places in (False, None, '[]', "['']",):
            self.menu_noplace()
        else:
            self.places = eval(self.places)
            self.menu_normal()
            self.place = self.places[self.placechosen]
            self.update_weather()
            self.winder.set_menu(self.menu)
            
    def menu_noplace(self):
        menu_noplace = gtk.Menu()
        setup = gtk.MenuItem(_("Set Up Weather..."))
        setup.connect("activate", self.placeadding)
        setup.show()
        menu_noplace.append(setup)
        self.winder.set_menu(menu_noplace)
    
    def menu_normal(self):
        self.menu = gtk.Menu()
            
    ##City
        self.city_show = gtk.MenuItem()
        self.city_show.set_sensitive(False)
        self.menu.append(self.city_show)
        self.city_show.show()
        
    ##Condition
        self.cond_show = gtk.MenuItem()
        self.cond_show.set_sensitive(False)
        self.cond_show.show()
        self.menu.append(self.cond_show)
        
    ##Temperature        
        self.temp_show = gtk.MenuItem()
        self.temp_show.set_sensitive(False)
        self.temp_show.show()
        self.menu.append(self.temp_show)
        
    ##Humidity
        self.humid_show = gtk.MenuItem()
        self.humid_show.set_sensitive(False)
        self.humid_show.show()
        self.menu.append(self.humid_show)
        
    ##Wind
        self.wind_show = gtk.MenuItem()
        self.wind_show.set_sensitive(False)
        self.wind_show.show()
        self.menu.append(self.wind_show)
                
    ##Sunrise
        self.sunrise_show = gtk.MenuItem()
        self.sunrise_show.set_sensitive(False)
        self.sunrise_show.show()
        self.menu.append(self.sunrise_show)

    ##Sunset
        self.sunset_show = gtk.MenuItem()
        self.sunset_show.set_sensitive(False)
        self.sunset_show.show()
        self.menu.append(self.sunset_show)
        ###WORKAROUND For new places registration
        #oldplace = gconfClient.get_string("/apps/indicator-weather/place")
        #newplaces = gconfClient.get_string("/apps/indicator-weather/places")
        #if not(oldplace in (False, None)) and newplaces in (False, None):
            #self.places = gconfClient.get_string("/apps/indicator-weather/place").split('|')
            #gconfClient.set_string("/apps/indicator-weather/places", str(self.places))
        ###Workaround end.
        
    ##Cities
        if len(self.places) != 1:
            ##Breaker
            breaker = gtk.SeparatorMenuItem()
            breaker.show()
            self.menu.append(breaker)
            
            loco1 = gtk.RadioMenuItem(None, self.places[0][1])
            if self.placechosen == 0:
                loco1.set_active(True)
            loco1.connect("toggled", self.on_city_changed)
            loco1.show()
            self.menu.append(loco1)
            for place in self.places[1:]:
                loco = gtk.RadioMenuItem(loco1, place[1])
                if self.places.index(place) == self.placechosen:
                    loco.set_active(True)
                loco.connect("toggled", self.on_city_changed)
                loco.show()
                self.menu.append(loco)
        
    ##Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)
        
        ext_show = gtk.MenuItem(_("Forecast..."))
        ext_show.connect("activate", self.extforecast)
        ext_show.show()
        self.menu.append(ext_show)
    ##Preferences      
        prefs_show = gtk.MenuItem(_("Preferences..."))
        prefs_show.connect("activate", self.prefs)
        prefs_show.show()
        self.menu.append(prefs_show)
        
    def placeadding(self,widget):
        self.placeadded = ''
        self.assistant = Assistant()
        self.assistant.show()
        
    def rebuild_menu(self):
        for item in self.menu.get_children()[7:len(self.menu.get_children())]:
            item.destroy()
        
    ##Cities
        if len(self.places) != 1:
            ##Breaker
            breaker = gtk.SeparatorMenuItem()
            breaker.show()
            self.menu.append(breaker)
            
            loco1 = gtk.RadioMenuItem(None, self.places[0][1])
            if self.placechosen == 0:
                loco1.set_active(True)
            loco1.connect("toggled", self.on_city_changed)
            loco1.show()
            self.menu.append(loco1)
            for place in self.places[1:]:
                loco = gtk.RadioMenuItem(loco1, place[1])
                if self.places.index(place) == self.placechosen:
                    loco.set_active(True)
                loco.connect("toggled", self.on_city_changed)
                loco.show()
                self.menu.append(loco)
    ##Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)
        
        ext_show = gtk.MenuItem(_("Forecast..."))
        ext_show.connect("activate", self.extforecast)
        ext_show.show()
        self.menu.append(ext_show)
    ##Preferences      
        prefs_show = gtk.MenuItem(_("Preferences..."))
        prefs_show.connect("activate", self.prefs)
        prefs_show.show()
        self.menu.append(prefs_show)
        
        self.winder.set_menu(self.menu)

    def on_city_changed(self,widget):
        if widget.get_active():
            for place in self.places:
                if (place[1] == widget.get_label()):
                    self.placechosen = self.places.index(place)
                    break
            gconfClient.set_int("/apps/indicator-weather/placechosen", self.placechosen)
            self.update_weather(False)

    def update_weather(self, notif=True,widget=None):
        weather = self.get_weather(self.places[self.placechosen])
        if weather == None:
			for item in self.menu.get_children()[0:len(self.menu.get_children())]:
				item.destroy()
			self.problem_show = gtk.MenuItem(_("Connection problem"))
			self.problem_show.set_sensitive(False)
			self.problem_show.show()
			self.menu.append(self.problem_show)
			self.winder.set_icon("ubuntuone-client-error")
			return
		
        self.condition = weather.getPureCondition()
        
        print 'Update :',weather.getPureCondition(),'(every',self.rate,'min. for',self.places[self.placechosen][1]+')'

        #WTF?
        #current = self.icon

        #FIXME: move this endless if to Weather object
        if self.condition in ('chance_of_storm', 'storm'):
            self.winder.set_icon("weather-storm")
            a="weather-storm"
        elif self.condition in ('thunderstorm', 'chance_of_tstorm'):
            self.winder.set_icon("weather-severe-alert")
            a="weather-severe-alert"
        elif self.condition in ('sleet',  'snow',  'icy',  'flurries',  'chance_of_snow'):
            self.winder.set_icon("weather-snow")
            a= "weather-snow"
        elif self.condition in ('dust',  'fog',  'smoke',  'haze',  'mist'):
            self.winder.set_icon("weather-fog")
            a="weather-fog" 
        elif self.condition == 'rain':
            self.winder.set_icon("weather-showers")
            a="weather-showers"
        elif self.condition == 'chance_of_rain':
            self.winder.set_icon("weather-showers-scattered")
            a = "weather-showers-scattered"
        elif self.condition in ('sunny', 'clear'):
            if weather.isNight:
                self.winder.set_icon("weather-clear-night")
                a="weather-clear-night"
            else:
                self.winder.set_icon("weather-clear")
                a="weather-clear"
        elif self.condition in ('mostly_cloudy', 'cloudy'):
            if weather.isNight:
                self.winder.set_icon("weather-clouds-night")
                a="weather-clouds-night"
            else:
                self.winder.set_icon("weather-clouds")
                a="weather-clouds"
        elif self.condition in ('mostly_sunny',  'partly_cloudy'):
            if weather.isNight:
                self.winder.set_icon("weather-few-clouds-night")
                a="weather-few-clouds-night"
            else:    
                self.winder.set_icon("weather-few-clouds")
                a="weather-few-clouds"
        else:
            self.winder.set_icon("ubuntuone-client-error")
            a=False
        #self.city_table.attach(gtk.Label("City"), 0, 1, 0, 1)
        
        self.city_show.set_label(self.places[self.placechosen][1])
        self.cond_show.set_label(self.condition)
        self.temp_show.set_label(weather.getTemperature())
        self.humid_show.set_label(weather.getHumidity())
        self.wind_show.set_label(weather.getWindSpeed())
        self.sunrise_show.set_label(weather.getSunrise())
        self.sunset_show.set_label(weather.getSunset())
        
        if self.notif != 'N' and a != False and notif:
	        if self.condition != gconfClient.get_string("/apps/indicator-weather/current") and self.notif == 'U':
	            self.notify(self.condition, a)
	        elif current in ('thunderstorm', 'chance_of_tstorm') and self.notif == 'O':
	            self.notify(self.condition,a,severe=True)
	            
        gconfClient.set_string("/apps/indicator-weather/current",self.condition)
        
        self.rateid = gobject.timeout_add(int(self.rate) * 60000, self.update_weather)
            
    def responseToDialog(self, entry, dialog, response):
        dialog.response(response)
        
    def getText(self, replace=True):
        dialog = gtk.MessageDialog(
            None,
            gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
            gtk.MESSAGE_QUESTION,
            gtk.BUTTONS_OK,
            None)
        dialog.set_markup('Please enter your address:')
        entry = gtk.Entry()
        entry.connect("activate", self.responseToDialog, dialog, gtk.RESPONSE_OK)
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Address:"), False, 5, 5)
        hbox.pack_end(entry)
        dialog.vbox.pack_end(hbox, True, True, 0)
        dialog.show_all()
        dialog.run()
        if replace == False:
            if not (entry.get_text() in self.places):
                self.places.append(entry.get_text())
                gconfClient.set_string("/apps/indicator-weather/places", str([self.places]))
                dialog.destroy()
                return True
            else:
                dialog.destroy()
                return False
        else:
            self.places = list()
            self.places.append(entry.get_text())
            gconfClient.set_string("/apps/indicator-weather/places", str([self.places]))
        dialog.destroy()
        self.update_weather()
            
    def get_weather(self, city, firstrun=False, extended=False, onlycity=False):
        if ((len(city[0]) == 1) or (city[0] == "Enter Location")):
            return ""
        location = Location(MetricSystem.SI, WindUnits.MPS)
        if (location.find_city_by_code(city[0]) == False):
            print "location with code %s not found" % city[0]
        location.update_weather_data()
        if (location.weather.isReportCorrect() == False):
            print "report is empty";
        else:
            print "Got report";
      
        if extended == False:
            return location.weather
        else:
            #FIXME: extended report should be gathered from Google
            parsed = parseString(s)
            self.daysofweek=[]
            for day_of_week in parsed.getElementsByTagName("day_of_week"):
                self.daysofweek.append([day_of_week.attributes["data"].value][0])
            self.lowdata=[]
            for low in parsed.getElementsByTagName("low"):
                if (wi.unit == 'C' and wi.unitsystem == 'SI') or (wi.unit == 'F' and wi.unitsystem == 'US'):
                    self.lowdata.append([low.attributes["data"].value][0])
                else:
                    if wi.unit == 'C':
                        self.lowdata.append(int((((int([low.attributes["data"].value][0]))-32)*5)/9))
                    elif wi.unit == 'F':
                        self.lowdata.append(int(((int([low.attributes["data"].value][0])*9)/5)+32))
                    elif wi.unitsystem == 'SI':
                        self.lowdata.append((int([low.attributes["data"].value][0]))+273)
                    else:
                        self.lowdata.append(int(((((int([low.attributes["data"].value][0]))-32)*5)/9)+273))
            self.highdata=[]
            for high in parsed.getElementsByTagName("high"):
                if (wi.unit == 'C' and wi.unitsystem == 'SI') or (wi.unit == 'F' and wi.unitsystem == 'US'):
                    self.highdata.append([high.attributes["data"].value][0])
                else:
                    if wi.unit == 'C':
                        self.highdata.append(int((((int([high.attributes["data"].value][0]))-32)*5)/9))
                    elif wi.unit == 'F':
                        self.highdata.append(int(((int([high.attributes["data"].value][0])*9)/5)+32))
                    elif wi.unitsystem == 'SI':
                        self.highdata.append((int([high.attributes["data"].value][0]))+273)
                    else:
                        self.highdata.append(int(((((int([high.attributes["data"].value][0]))-32)*5)/9)+273))
            self.icons=[]
            for icon in parsed.getElementsByTagName("icon"):
                self.icons.append([icon.attributes["data"].value][0].split("/ig/images/weather/")[-1].split(".gif")[0])
            self.conditions=[]
            for condition in parsed.getElementsByTagName("condition"):
                self.conditions.append([condition.attributes["data"].value][0])
        
    def prefs(self, widget):
        self.prefswindow = PreferencesDialog()
        self.prefswindow.show()
        
    def extforecast(self,widget):
        forecastwd = ExtendedForecast()
        forecastwd.show()
        
    def addlocation(self,widget):
        self.getText()
        self.menu_normal()
        self.place = self.places[self.placechosen]
        self.update_weather(False)
        self.winder.set_menu(self.menu)
        
    def notify(self,conditon,icon,severe=False):
        if severe:
			n = pynotify.Notification (_("Severe weather alert"),
                self.condition,
                icon)
        else:
		    n = pynotify.Notification (self.condition,
               "",
               icon)
        n.show ()

class PreferencesDialog(gtk.Dialog):
    __gtype_name__ = "PreferencesDialog"
    def __new__(cls):
        builder = get_builder('PreferencesDialog')
        new_object = builder.get_object("preferences_dialog")
        new_object.finish_initializing(builder)
        return new_object

    def finish_initializing(self, builder):
        self.builder = builder
        if wi.unit == 'F':
            self.builder.get_object('fahrenheit').set_active(True)
        elif wi.unit == 'C':
            self.builder.get_object('celsius').set_active(True)
        else:
            self.builder.get_object('kelvin').set_active(True)
        if wi.notif == 'N':
            self.builder.get_object('nonotif').set_active(True)
        elif wi.notif == 'O':
            self.builder.get_object('notifsevere').set_active(True)
        else:
            self.builder.get_object('notifall').set_active(True)            
        
        #if wi.windunit == 'm/s':
            #self.builder.get_object('m/s').set_active(True)
        #elif wi.windunit == 'km/h':
            #self.builder.get_object('km/h').set_active(True)
        #elif wi.windunit == 'mph':
            #self.builder.get_object('mph').set_active(True)
        #elif wi.windunit == 'knots':
            #self.builder.get_object('knots').set_active(True)
        #else:
            #self.builder.get_object('Beaufort').set_active(True)
        
        self.builder.get_object('rate').set_value(wi.rate)
        end = len(wi.places)
        for place in wi.places:
            newplace = list()
            newplace.append(place[1])
            newplace.append(place[0])
            
            self.builder.get_object('citieslist').append(newplace)
            
        self.builder.connect_signals(self)
        
    def on_remove_location(self,widget):
        selection = self.builder.get_object('displaylist').get_selection()
        model, iter = selection.get_selected()
        if iter != None:
            model.remove(iter)
    
    def on_add_location(self, widget):
        self.assistant2 = Assistant2()
        self.assistant2.show()
    
    def on_wind_activate(self, widget):
        pass
    
    def on_destroy(self, widget, data=None):
        pass
        #"""Called when the WeatherIndicatorWindow is closed."""
        #gtk.main_quit()
    #def on_city_edited(self,widget,path,value):
        ###CHECK AVAILABILITY
        #self.builder.get_object('citieslist').set_value(self.builder.get_object('citieslist').get_iter_from_string(path), 0, value)
    
    def ok(self, widget, data=None):
        """The user has selected to save the changes.

        Called before the dialog returns gtk.RESONSE_OK from run().
        """
        needupdate = False
        ##Temperature##
        for button in self.builder.get_object('fahrenheit').get_group():
            if button.get_active() == True and button.get_label()[0] != wi.unit:
                gconfClient.set_string("/apps/indicator-weather/unit", button.get_label()[0])
                wi.unit = button.get_label()[0]
                needupdate = True
                print 'Unit changed :', wi.unit
                
        for button in self.builder.get_object('nonotif').get_group():
            if button.get_active() == True and button.get_label()[0] != wi.notif:
                gconfClient.set_string("/apps/indicator-weather/notif", button.get_label()[0])
                wi.notif = button.get_label()[0]
                print 'Notifications changed :', wi.notif
                
        ##Rate
        if int(self.builder.get_object('rate').get_value()) != wi.rate:
            gconfClient.set_int("/apps/indicator-weather/refresh_rate", int(self.builder.get_object('rate').get_value()))
            wi.rate = int(self.builder.get_object('rate').get_value())
            gobject.source_remove(wi.rateid)
            wi.rateid = gobject.timeout_add(int(wi.rate) * 60000, wi.update_weather)
            print 'Rate changed :',wi.rate
            
        ##places
        newplaces = list()
        item = self.builder.get_object('citieslist').get_iter_first()
        while ( item != None ):
            newplace = list()
            newplace.append(self.builder.get_object('citieslist').get_value (item, 1))
            newplace.append(self.builder.get_object('citieslist').get_value (item, 0))
            newplaces.append(newplace)
            item = self.builder.get_object('citieslist').iter_next(item)
        if newplaces != wi.places:
            wi.places = newplaces
            if len(wi.places) >= 1:
                gconfClient.set_string("/apps/indicator-weather/places", str(wi.places))
                if wi.place in wi.places:
                    wi.placechosen = wi.places.index(wi.place)
                else:
                    wi.placechosen = 0
                gconfClient.set_int("/apps/indicator-weather/placechosen", wi.placechosen)
                wi.rebuild_menu()
                needupdate = True
            else:
                wi.placechosen = 0
                gconfClient.set_int("/apps/indicator-weather/placechosen", wi.placechosen)
                gconfClient.set_string("/apps/indicator-weather/places", str([wi.places]))
                wi.winder.set_icon("weather-clear")
                wi.menu_noplace()
                needupdate = False
            
        ##Wind
        #for button in self.builder.get_object('m/s').get_group():
            #if button.get_active() == True and button.get_label() != wi.windunit:
                #gconfClient.set_string("/apps/indicator-weather/wind", button.get_label())
                #wi.windunit = button.get_label()
                #needupdate = True
                #print 'Wind changed :', wi.windunit
        
        if needupdate:
            wi.update_weather(False)
        
        # Make any updates to self._preferences here. e.g.
        #self._preferences["preference1"] = "value2"
        #self._save_preferences()
        self.destroy()

    def cancel(self, widget, data=None):
        """The user has elected cancel changes.

        Called before the dialog returns gtk.RESPONSE_CANCEL for run()
        """
        # Restore any changes to self._preferences here.
        self.destroy()
        
class ExtendedForecast(gtk.Window):
    __gtype_name__ = "ExtendedForecast"
    def __new__(cls):
        builder = get_builder('ExtendedForecast')
        new_object = builder.get_object("extended_forecast")
        new_object.finish_initializing(builder)
        return new_object
        
    def finish_initializing(self, builder):
        self.builder = builder
        self.builder.connect_signals(self)
        
        self.builder.get_object('extended_forecast').set_title(_('Weather Forecast for ')+wi.places[wi.placechosen][1])
        wi.get_weather(wi.places[wi.placechosen],False,True)
        
        self.builder.get_object('day1lbl').set_label('<big>'+wi.daysofweek[0].capitalize()+'</big>')
        self.builder.get_object('day2lbl').set_label('<big>'+wi.daysofweek[1].capitalize()+'</big>')
        self.builder.get_object('day3lbl').set_label('<big>'+wi.daysofweek[2].capitalize()+'</big>')
        self.builder.get_object('day4lbl').set_label('<big>'+wi.daysofweek[3].capitalize()+'</big>')
        i=0
        for icon in wi.icons[1:]:
            i=i+1
            if icon in ('chance_of_storm', 'storm', 'thunderstorm', 'chance_of_tstorm'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-storm',gtk.ICON_SIZE_BUTTON)
            elif icon in ('sleet',  'snow',  'icy',  'flurries',  'chance_of_snow'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-snow',gtk.ICON_SIZE_BUTTON)
            elif icon in ('dust',  'fog',  'smoke',  'haze',  'mist'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-fog',gtk.ICON_SIZE_BUTTON)
            elif icon in ('rain'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-showers',gtk.ICON_SIZE_BUTTON)
            elif icon in ('chance_of_rain'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-showers-scattered',gtk.ICON_SIZE_BUTTON)
            elif icon in ('sunny', 'clear'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-clear',gtk.ICON_SIZE_BUTTON)
            elif icon in ('mostly_cloudy', 'cloudy'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-overcast',gtk.ICON_SIZE_BUTTON)
            elif icon in ('mostly_sunny',  'partly_cloudy'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-few-clouds',gtk.ICON_SIZE_BUTTON)
            else:
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('window-close',gtk.ICON_SIZE_BUTTON)
        i=0
        for condition in wi.conditions[1:]:
            i=i+1
            self.builder.get_object('day%scond' % str(i)).set_label(condition)
        i=0
        if wi.unit == 'C':
            tempunit = '°C'
        elif wi.unit == 'F':
            tempunit = '°F'
        else:
            tempunit = '°K'
        for high in wi.highdata:
            i=i+1
            self.builder.get_object('day%stemphigh' % str(i)).set_label((_('High: ')+'%s%s') % (high,tempunit))
        i=0
        for low in wi.lowdata:
            i=i+1
            self.builder.get_object('day%stemplow' % str(i)).set_label((_('Low: ')+'%s%s') % (low,tempunit))
        
    
    def close(self, widget, data=None):
        self.destroy()
    
    def on_destroy(self, widget, data=None):
        pass
        
#class EditPlace(gtk.MessageDialog):
    #__gtype_name__ = "EditPlace"
    #def __new__(cls):
        #builder = get_builder('EditPlace')
        #new_object = builder.get_object("edit_place")
        #new_object.finish_initializing(builder)
        #return new_object
        
    #def finish_initializing(self, builder):
        #self.builder = builder
        #self.builder.connect_signals(self)
    
    #def ok(self, widget, data=None):
        #self.destroy()
        #if self.builder.get_object("entry").get_text() != '':
            #return self.builder.get_object("entry").get_text()
        #else:
            #return False
        ###APPLY CHANGES
        
    #def cancel(self, widget, data=None):
        #"""The user has elected cancel changes.

        #Called before the dialog returns gtk.RESPONSE_CANCEL for run()
        #"""
        ## Restore any changes to self._preferences here.
        #self.destroy()
        #return False

class Assistant(gtk.Assistant):
    __gtype_name__ = "Assistant"
    def __new__(cls):
        builder = get_builder('Assistant')
        new_object = builder.get_object("assistant")
        new_object.finish_initializing(builder)
        return new_object
        
    def finish_initializing(self, builder):
        self.builder = builder
        self.builder.connect_signals(self)
        self.builder.get_object("assistant").set_page_complete(self.builder.get_object("chooseunit"),True)
        self.builder.get_object("assistant").set_page_complete(self.builder.get_object("label"),True)
        self.builder.get_object("assistant").set_page_complete(self.builder.get_object("review"),True)
        self.builder.get_object("assistant").set_forward_page_func(self.get_city)
        
    def on_find_location(self,widget):
        def get_my_ip_address():
            whatismyip = 'http://www.whatismyip.com/automation/n09230945.asp'
            return urllib2.urlopen(whatismyip).readlines()[0]

        response = urllib2.urlopen('http://api.hostip.info/get_html.php?ip=%s' % get_my_ip_address()).read()
        m = re.search('City: (.*)', response)
        if m:
            self.builder.get_object("entry").set_text(m.group(1))
                
    def on_entry_edited(self,widget):
        if widget.get_text() == '':
            self.builder.get_object("assistant").set_page_complete(self.builder.get_object("placeinput"),False)
        else:
            self.builder.get_object("assistant").set_page_complete(self.builder.get_object("placeinput"),True)
    
    def get_city(self,current_page):
        if self.builder.get_object("assistant").get_current_page() == 1:
            self.city_name = self.builder.get_object("entry").get_text()
            #FIXME: Use new switches - metric system and Wind Units
            print "City name "+self.city_name
            self.location = Location(MetricSystem.SI, WindUnits.MPS)
            self.location.find_city_by_name(self.city_name)
            if self.location.found:
                print "city was found"
                self.builder.get_object("lblplace").set_label('<big>%s</big>' % self.location.get_full_city_name())
                self.builder.get_object("assistant").set_page_complete(self.builder.get_object("confirmplace"),True)
                return 3
            else:
                print "city not found"
                return 2
        elif self.builder.get_object("assistant").get_current_page() == 4:
            lbl = self.builder.get_object("entrylbl").get_text()
            if lbl == '':
                self.location.set_label(self.city_name)
                self.builder.get_object("lbl3").set_label('')
            else:
                self.location.set_label(self.builder.get_object("entrylbl").get_text())
                self.builder.get_object("lbl3").set_label('Label:')

            self.builder.get_object("labellbl").set_label('<b>%s</b>' % self.location.label)
            for button in self.builder.get_object('fahrenheit').get_group():
                if button.get_active() == True:
                    self.builder.get_object("unitlbl").set_label('<b>'+button.get_label()+'</b>')
            self.builder.get_object("placelbl").set_label('<b>'+self.city_name+'</b>')
            
        return self.builder.get_object("assistant").get_current_page() + 1
            
    def on_cancel(self,widget):
        self.destroy()
        
    def on_apply(self,widget):
        newplace = list()
        newplace.append(self.location.code)
        newplace.append(self.location.label)

        wi.placeadded = self.location.label
        wi.places = list()
        wi.places.append(newplace)

        newlocation = list()
        newlocation.append(self.location)
        wi.locations = list()
        wi.locations.append(newlocation)

        for button in self.builder.get_object('fahrenheit').get_group():
            if button.get_active() == True and button.get_label()[0] != wi.unit:
                gconfClient.set_string("/apps/indicator-weather/unit", button.get_label()[0])
                wi.unit = button.get_label()[0]
        
        self.hide()
        gconfClient.set_string("/apps/indicator-weather/places", str(wi.places))
        wi.menu_normal()
        wi.place = wi.places[wi.placechosen]
        wi.update_weather(False)
        wi.winder.set_menu(wi.menu)
        
class Assistant2(gtk.Assistant):
    __gtype_name__ = "Assistant2"
    def __new__(cls):
        builder = get_builder('Assistant2')
        new_object = builder.get_object("assistant2")
        new_object.finish_initializing(builder)
        return new_object
        
    def finish_initializing(self, builder):
        self.builder = builder
        self.builder.connect_signals(self)
        self.builder.get_object("assistant2").set_page_complete(self.builder.get_object("label"),True)
        self.builder.get_object("assistant2").set_forward_page_func(self.get_city)
        
    def on_find_location(self,widget):
        def get_my_ip_address():
            whatismyip = 'http://www.whatismyip.com/automation/n09230945.asp'
            return urllib2.urlopen(whatismyip).readlines()[0]
        response = urllib2.urlopen('http://api.hostip.info/get_html.php?ip=%s' % get_my_ip_address()).read()
        m = re.search('City: (.*)', response)
        if m:
            self.builder.get_object("entry").set_text(m.group(1))

    def on_entry_edited(self,widget):
        if widget.get_text() == '':
            self.builder.get_object("assistant2").set_page_complete(self.builder.get_object("placeinput"),False)
        else:
            self.builder.get_object("assistant2").set_page_complete(self.builder.get_object("placeinput"),True)
    
    def get_city(self,current_page):
        if self.builder.get_object("assistant2").get_current_page() == 0:
            self.city_name = self.builder.get_object("entry").get_text()
            #FIXME: Use new switches - metric system and Wind Units
            print "City name "+self.city_name
            self.location = Location(MetricSystem.SI, WindUnits.MPS)
            self.location.find_city_by_name(self.city_name)
            if self.location.found:
                print "city was found"
                self.builder.get_object("lblplace").set_label('<big>%s</big>' % self.location.get_full_city_name())
                self.builder.get_object("assistant2").set_page_complete(self.builder.get_object("confirmplace"),True)
                return 2
            else:
                print "city was not found"
                return 1
        return self.builder.get_object("assistant2").get_current_page() + 1
            
    def on_cancel(self,widget):
        self.destroy()
        
    def on_apply(self,widget):
        #FIXME: might be an empty label?
        self.location.set_label(self.builder.get_object("entrylbl").get_text())
        newplace = list()
        newplace.append(self.location.label)
        newplace.append(self.location.code)
        wi.prefswindow.builder.get_object('citieslist').append(newplace)
        self.hide()
        #newlocation = list()
        #newlocation.append(self.location)
        #wi.prefswindow.builder.get_object('locationslist').append(newlocation)

def main():
    gtk.main()
    return 0

if __name__ == "__main__":
    wi = indicator_weather()
    main()
