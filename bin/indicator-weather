#!/usr/bin/python
# -*- coding: utf-8 -*-
### BEGIN LICENSE
# Copyright (C) 2010 Sebastian MacDonald Sebas310@gmail.com
# Copyright (C) 2010 Mehdi Rejraji mehd36@gmail.com
# This program is free software: you can redistribute it and/or modify it 
# under the terms of the GNU General Public License version 3, as published 
# by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranties of 
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
# PURPOSE.  See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along 
# with this program.  If not, see <http://www.gnu.org/licenses/>.
### END LICENSE

import sys
import os
import gtk
import pygtk
pygtk.require('2.0')
import gobject
import appindicator
import gconf
import urllib2
import re
import datetime
import locale
import pynotify
from xml.dom.minidom import parseString
import time
import math
import commands
import threading

import gettext
from gettext import gettext as _
gettext.textdomain('indicator-weather')

from gweather.I_KNOW_THIS_IS_UNSTABLE import gweather
import pymetar as metar

# Add project root directory (enable symlink, and trunk execution).
PROJECT_ROOT_DIRECTORY = os.path.abspath(
    os.path.dirname(os.path.dirname(os.path.realpath(sys.argv[0]))))

if (os.path.exists(os.path.join(PROJECT_ROOT_DIRECTORY, 'indicator_weather'))
    and PROJECT_ROOT_DIRECTORY not in sys.path):
    sys.path.insert(0, PROJECT_ROOT_DIRECTORY)
    os.putenv('PYTHONPATH', PROJECT_ROOT_DIRECTORY) # for subprocesses

from indicator_weather.helpers import get_builder

gconfClient = gconf.client_get_default()

class Location:
    """
    Data object which contains the name of a city (label), its GWeather object "location"
    """

    #Initialize an object with a label
    def __init__(self, metric_system, wind_units):
        self.__metric_system = metric_system
        self.__wind_units = wind_units
        self.__found = False
        self.__lat = None
        self.__lon = None

    #Replace chars with HTML-safe equivalents
    def html_decode(self, value):
        htmlCodes = (
            ('&', '&amp;'),
            ('<', '&lt;'),
            ('>', '&gt;'),
            ('"', '&quot;'),
            ("'", '&#39;'),
        )
        for code in htmlCodes:
            value = value.replace(code[0], code[1])
        return value

    # Get a full city name
    def get_full_city_name(self):
        # We're getting a parent here, as 'location' here is actually a weather station
        self.__city = self.__location.get_parent()
        self.__full_city_name = ""
        while (self.__city.get_parent().get_parent() != None):
            self.__full_city_name += "%s, " % self.__city.get_name()
            self.__city = self.__city.get_parent()
        self.__full_city_name += "%s" % self.__city.get_name()
        return self.html_decode(self.__full_city_name)

    #Get short city name
    def get_short_city_name(self):
        return self.html_decode(self.__location.get_parent().get_name())

    #Internal proc - iterate by known locations to find a city by its name
    def __find_city_by_name (self, node, city_name):
        if (node.get_name() == city_name):
            #FIXME: City may have several weather stations - we're selecting the first one only
            if (node.get_children() != None):
                return node.get_children()[0];
        else:
            for obj in node.get_children():
                possible_city = self.__find_city_by_name(obj, city_name)
                if (possible_city != None):
                    return possible_city;
    
    #Internal proc - iterate by known locations to find city by its code
    def __find_city_by_code (self, node, city_code):
        if (node.get_code() == city_code):
            return node;
        else:
            for obj in node.get_children():
                possible_city = self.__find_city_by_code(obj, city_code)
                if (possible_city != None):
                    return possible_city;

    #Fill in location attribute, looking up by location name
    def find_city_by_name (self, city_name):
        location = self.__find_city_by_name(gweather.location_new_world(True), city_name)
        self.prepare_location(location)

    #Fill in location attribute, looking up by location code
    def find_city_by_code (self, city_code):
        location = self.__find_city_by_code(gweather.location_new_world(True), city_code)
        self.prepare_location(location)

    #Prepare metar reporter for the location
    def prepare_location(self, location):
        if (location != None):
            self.__location = location
            self.__code = location.get_code()
            self.__lat = location.get_coords()[0]
            self.__lon = location.get_coords()[1]
            self.__report_fetcher = metar.ReportFetcher(self.__code)
            self.__found = True
        else:
            self.__found = False

    #Get continent name for radar map
    def getContinent(self):
        if (self.__location != None):
            self.__city = self.__location
            self.__continent_name = ""
            self.__city = self.__city.get_parent()
            while (self.__city.get_parent().get_parent() != None):
                self.__city = self.__city.get_parent()
            self.__continent_name = self.__city.get_name()
            return self.__continent_name
        
    def set_label(self, value):
        self.__label = value

    @property
    def code(self):
        return self.__code

    @property
    def found(self):
        return self.__found

    @property
    def label(self):
        return self.__label

    @property
    def weather(self):
        return self.__weather

    #Get sun status
    def get_sun_data(self):
        #return ("00:00:00", "00:00:00", "00:00:00")
        if (self.found):
            now = datetime.datetime.now()
            url = 'http://www.earthtools.org/sun/%s/%s/%s/%s/99/1' % (self.__lat,self.__lon,now.day,now.month)
            try:
                f = urllib2.urlopen(url)
                s=f.read()
                parsed = parseString(s)
                sunrise = parsed.getElementsByTagName("morning")[0].getElementsByTagName("civil")[0].firstChild.nodeValue
                sunset  = parsed.getElementsByTagName("evening")[0].getElementsByTagName("civil")[0].firstChild.nodeValue
            #sunrise = parsed.getElementsByTagName("sunrise")[0].firstChild.nodeValue
            #sunset = parsed.getElementsByTagName("sunset")[0].firstChild.nodeValue
                timezone = parsed.getElementsByTagName("timezone")[0].firstChild.nodeValue
                return (sunrise, sunset, timezone)
            except urllib2.URLError:
                print "error reaching url %s" % url
                return ("00:00:00", "00:00:00", "00:00:00")
        else:
            print "Can't gather sun data on empty location"

    #Update weather data and store weather object
    def update_weather_data(self):
        if (self.__report_fetcher != None):
            try:
                self.__fetched_report = self.__report_fetcher.FetchReport()
                self.__weather_report = metar.ReportParser(self.__fetched_report).ParseReport()
                self.__sun_report = self.get_sun_data();
                self.__weather = Weather(self.__weather_report, self.__sun_report, self.__metric_system, self.__wind_units)
            except urllib2.URLError:
                self.__found = False
                print "error fetching report"

    #Get and store forecast data - use Google
    def prepare_forecast_data(self):
        import locale
        localebad = locale.getlocale()[0]
        locale = localebad.split ('_')
        #Here we generate a string, compiled of latitude and longitude for location
        self.coord_string = (",,,%.6f,%.6f" % (self.__lat, self.__lon)).replace(".","")
        url = "http://www.google.com/ig/api?weather=" + self.coord_string + "&hl=" + locale[0]
        print "url:%s" % url
        try:
            f = urllib2.urlopen(url)
            s = f.read()
            encoding = f.headers['content-type'].split('charset=')[-1]
            s = unicode(s, encoding).encode('utf-8').replace("&#39;", "'")
            self.unitsystem = s.split("<unit_system data=\"")[-1].split("\"")[0]
            self.__parsedforecast = parseString(s)
        except urllib2.URLError:
            print "error reaching url %s" % url
        #FIXME: check for errors here

    #Parse a list of days of week with forecast data
    def get_forecast_daysofweek(self):
        self.daysofweek = []
        for day_of_week in self.__parsedforecast.getElementsByTagName("day_of_week"):
                self.daysofweek.append([day_of_week.attributes["data"].value][0])
        return self.daysofweek

    #Parse high values for forecast data
    def get_forecast_highdata(self):
        self.highdata = []
        if ((self.unitsystem == 'SI') and (self.__metric_system == MetricSystem.SI)) or ((self.unitsystem == 'US') and (self.__metric_system == MetricSystem.IMPERIAL)):
            #correct scale selected
            for high in self.__parsedforecast.getElementsByTagName("high"):
                self.highdata.append([high.attributes["data"].value][0])
        elif ((self.unitsystem == 'SI') and (self.__metric_system == MetricSystem.IMPERIAL)):
            #convert from SI to imperial
            for high in self.__parsedforecast.getElementsByTagName("high"):
                self.highdata.append(int(((int([high.attributes["data"].value][0])*9)/5)+32))
        elif ((self.unitsystem == 'US') and (self.__metric_system == MetricSystem.SI)):
            #convert from imperial to SI
            for high in self.__parsedforecast.getElementsByTagName("high"):
                self.highdata.append(int((((int([high.attributes["data"].value][0]))-32)*5)/9))
        return self.highdata

    #Parse low values for forecast data
    def get_forecast_lowdata(self):
        self.lowdata = []
        if ((self.unitsystem == 'SI') and (self.__metric_system == MetricSystem.SI)) or ((self.unitsystem == 'US') and (self.__metric_system == MetricSystem.IMPERIAL)):
            #correct scale selected
            for low in self.__parsedforecast.getElementsByTagName("low"):
                self.lowdata.append([low.attributes["data"].value][0])
        elif ((self.unitsystem == 'SI') and (self.__metric_system == MetricSystem.IMPERIAL)):
            #convert from SI to imperial
            for low in self.__parsedforecast.getElementsByTagName("low"):
                self.lowdata.append(int(((int([low.attributes["data"].value][0])*9)/5)+32))
        elif ((self.unitsystem == 'US') and (self.__metric_system == MetricSystem.SI)):
            #convert from imperial to SI
            for low in parsed.getElementsByTagName("low"):
                self.lowdata.append(int((((int([low.attributes["data"].value][0]))-32)*5)/9))
        return self.lowdata

    #Parse icons for forecast data
    def get_forecast_icons(self):
        self.icons = []
        for icon in self.__parsedforecast.getElementsByTagName("icon"):
                self.icons.append([icon.attributes["data"].value][0].split("/ig/images/weather/")[-1].split(".gif")[0])
        return self.icons

    #Parse conditions for forecast data
    def get_forecast_conditions(self):
        self.conditions = []
        for condition in self.__parsedforecast.getElementsByTagName("condition"):
            self.conditions.append([condition.attributes["data"].value][0])
        return self.conditions
        
class MetricSystem:
    SI = 1
    IMPERIAL = 2

class WindUnits:
    MPS = 1
    MPH = 2
    BEAUFORT = 3
    #KNOTS = 4

class Weather:
    """
    Data object to parse metar weather object and convert units
    """
    
    #Available conditions and their icons
    # The following format is used:
    # pymetar name: (translated name, day icon name, night icon name, is severe) 
    _WeatherConditions = {
        #FIXME: Do we really have to copypaste these key values?

        #Clear
        "sunny"                   : ( _("Sunny"),          "weather-clear", False),
        "mostly sunny"            : ( _("Mostly sunny"),   "weather-clear", False),
        "partly sunny"            : ( _("Partly sunny"),   "weather-clear", False),
        "clear"                   : ( _("Clear"),          "weather-clear", False),
        "clear sky"               : ( _("Clear sky"),      "weather-clear", False),
        "becoming sunny"          : ( _("Becoming sunny"), "weather-clear", False),

        #Clouds
        "mostly cloudy"           : ( _("Mostly cloudy"),     "weather-clouds",   False),
        "increasing clouds"       : ( _("Increasing clouds"), "weather-clouds",   False),
        "decreasing clouds"       : ( _("Decreasing clouds"), "weather-clouds",   False),
        "broken clouds"           : ( _("Broken clouds"),     "weather-clouds",   False),
        "scattered clouds"        : ( _("Scattered clouds"),  "weather-overcast", False),
        "overcast"                : ( _("Overcast"),          "weather-overcast", False),

        #Few clouds
        "few clouds"              : ( _("Few clouds"),       "weather-few-clouds", False),
        "partly cloudy"           : ( _("Partly cloudy"),    "weather-few-clouds", False),
        "becoming cloudy"         : ( _("Becoming cloudy"),  "weather-few-clouds", False),
        "clearing"                : ( _("Clearing"),         "weather-few-clouds", False),
        "gradual clearing"        : ( _("Gradual clearing"), "weather-few-clouds", False),
        "clearing late"           : ( _("Clearing late"),    "weather-few-clouds", False),

        #Fog
        "fog"                     : ( _("Fog"),                  "weather-fog", False),
        "patchy fog"              : ( _("Patchy fog"),           "weather-fog", False),
        "dense fog"               : ( _("Dense fog"),            "weather-fog", False),
        "areas fog"               : ( _("Areas fog"),            "weather-fog", False),
        "blowing dust"            : ( _("Blowing dust"),         "weather-fog", False),
        "blowing sand"            : ( _("Blowing sand"),         "weather-fog", False),
        "patchy haze"             : ( _("Patchy haze"),          "weather-fog", False),
        "areas haze"              : ( _("Areas haze"),           "weather-fog", False),
        "haze"                    : ( _("Haze"),                 "weather-fog", False),
        "patchy ice fog"          : ( _("Patchy ice fog"),       "weather-fog", False),
        "areas ice fog"           : ( _("Areas ice fog"),        "weather-fog", False),
        "ice fog"                 : ( _("Ice fog"),              "weather-fog", False),
        "patchy freezing fog"     : ( _("Patchy freezing fog"),  "weather-fog", False),
        "areas freezing fog"      : ( _("Areas freezing fog"),   "weather-fog", False),
        "freezing fog"            : ( _("Freezing fog"),         "weather-fog", False),
        "freezing spray"          : ( _("Freezing spray"),       "weather-fog", False),
        "patchy smoke"            : ( _("Patchy smoke"),         "weather-fog", False),
        "areas smoke"             : ( _("Areas smoke"),          "weather-fog", False),
        "smoke"                   : ( _("Smoke"),                "weather-fog", False),
        "patchy ash"              : ( _("Patchy ash"),           "weather-fog", False),
        "areas ash"               : ( _("Areas ash"),            "weather-fog", False),
        "ash"                     : ( _("Ash"),                  "weather-fog", False),
        "volcanic ash"            : ( _("Volcanic ash"),         "weather-fog", False),
        

        #Snow
        "light snow"                 : ( _("Light snow"),                 "weather-snow", False),
        "blowing snow"               : ( _("Blowing snow"),               "weather-snow", False),
        "blizzard"                   : ( _("Blizzard"),                   "weather-snow", False),
        "patchy ice crystals"        : ( _("Patchy ice crystals"),        "weather-snow", False),
        "areas ice crystals"         : ( _("Areas ice crystals"),         "weather-snow", False),
        "ice crystals"               : ( _("Ice crystals"),               "weather-snow", False),
        "patchy frost"               : ( _("Patchy frost"),               "weather-snow", False),
        "areas frost"                : ( _("Areas frost"),                "weather-snow", False),
        "frost"                      : ( _("Frost"),                      "weather-snow", False),
        "slight chance snow showers" : ( _("Slight chance snow showers"), "weather-snow", False),
        "chance snow showers"        : ( _("Chance snow showers"),        "weather-snow", False),
        "snow showers likely"        : ( _("Snow showers likely"),        "weather-snow", False),
        "snow showers"               : ( _("Snow showers"),               "weather-snow", False),
        "slight chance snow/rain"    : ( _("Slight chance snow/rain"),    "weather-snow", False),
        "chance snow/rain"           : ( _("Chance snow/rain"),           "weather-snow", False),
        "snow/rain likely"           : ( _("Snow/rain likely"),           "weather-snow", False),
        "snow/rain"                  : ( _("Snow/rain"),                  "weather-snow", False),
        "slight chance wintry mix"   : ( _("Slight chance wintry mix"),   "weather-snow", False),
        "chance wintry mix"          : ( _("Chance wintry mix"),          "weather-snow", False),
        "wintry mix likely"          : ( _("Wintry mix likely"),          "weather-snow", False),
        "wintry mix"                 : ( _("Wintry mix"),                 "weather-snow", False),
        "slight chance snow/sleet"   : ( _("Slight chance snow/sleet"),   "weather-snow", False),
        "chance snow/sleet"          : ( _("Chance snow/sleet"),          "weather-snow", False),
        "snow/sleet likely"          : ( _("Snow/sleet likely"),          "weather-snow", False),
        "snow/sleet"                 : ( _("Snow/sleet"),                 "weather-snow", False),

        #Rain
        "slight chance sleet"              : ( _("Slight chance sleet"),              "weather-showers", False),
        "chance sleet"                     : ( _("Chance sleet"),                     "weather-showers", False),
        "sleet likely"                     : ( _("Sleet likely"),                     "weather-showers", False),
        "sleet"                            : ( _("Sleet"),                            "weather-showers", False),
        "slight chance rain showers"       : ( _("Slight chance rain showers"),       "weather-showers", False),
        "chance rain showers"              : ( _("Chance rain showers"),              "weather-showers", False),
        "rain showers likely"              : ( _("Rain showers likely"),              "weather-showers", False),
        "rain showers"                     : ( _("Rain showers"),                     "weather-showers", False),
        "slight chance rain"               : ( _("Slight chance rain"),               "weather-showers", False),
        "chance rain"                      : ( _("Chance rain"),                      "weather-showers", False),
        "rain likely"                      : ( _("Rain likely"),                      "weather-showers", False),
        "rain"                             : ( _("Rain"),                             "weather-showers", False),
        "heavy rain"                       : ( _("Heavy rain"),                       "weather-showers", False),
        "slight chance drizzle"            : ( _("Slight chance drizzle"),            "weather-showers", False),
        "chance drizzle"                   : ( _("Chance drizzle"),                   "weather-showers", False),
        "drizzle likely"                   : ( _("Drizzle likely"),                   "weather-showers", False),
        "drizzle"                          : ( _("Drizzle"),                          "weather-showers", False),
        "slight chance freezing rain"      : ( _("Slight chance freezing rain"),      "weather-showers", False),
        "chance freezing rain"             : ( _("Chance freezing rain"),             "weather-showers", False),
        "freezing rain likely"             : ( _("Freezing rain likely"),             "weather-showers", False),
        "freezing rain"                    : ( _("Freezing rain"),                    "weather-showers", False),
        "slight chance freezing drizzle"   : ( _("Slight chance freezing drizzle"),   "weather-showers", False),
        "chance freezing drizzle"          : ( _("Chance freezing drizzle"),          "weather-showers", False),
        "freezing drizzle likely"          : ( _("Freezing drizzle likely"),          "weather-showers", False),
        "freezing drizzle"                 : ( _("Freezing drizzle"),                 "weather-showers", False),
        "slight chance rain/freezing rain" : ( _("Slight chance rain/freezing rain"), "weather-showers", False), 
        "chance rain/freezing rain"        : ( _("Chance rain/freezing rain"),        "weather-showers", False),
        "rain/freezing rain likely"        : ( _("Rain/freezing rain likely"),        "weather-showers", False),
        "rain/freezing rain"               : ( _("Rain/freezing rain"),               "weather-showers", False),

        #Storms
        "storm"                           : ( _("Storm"),                       "weather-storm", True),
        "isolated thunderstorms"          : ( _("Isolated thunderstorms"),      "weather-storm", True),
        "slight chance thunderstorms"     : ( _("Slight chance thunderstorms"), "weather-storm", True),
        "chance thunderstorms"            : ( _("Chance thunderstorms"),        "weather-storm", True),
        "thunderstorms likely"            : ( _("Thunderstorms likely"),        "weather-storm", True),
        "thunderstorm"                    : ( _("Thunderstorms"),               "weather-storm", True),
        "severe thunderstorms"            : ( _("Severe thunderstorms"),        "weather-storm", True),
        "water spout"                     : ( _("Water spout"),                 "weather-storm", True)
    }

    # Night icons for weather conditions
    _Night_Icons = {
        "weather-storm"      : "weather-storm",
        "weather-showers"    : "weather-showers",
        "weather-snow"       : "weather-snow",
        "weather-fog"        : "weather-fog",
        "weather-few-clouds" : "weather-few-clouds-night",
        "weather-overcast"   : "weather-overcast",
        "weather-clouds"     : "weather-clouds-night",
        "weather-clear"      : "weather-clear-night"
    }

    def __init__(self, weather_report, sun_report, metric_system, wind_unit):
        self.__report = weather_report
        self.__sun = sun_report
        self.__metric_system = metric_system
        self.__wind_unit = wind_unit
        self.__current_condition = None

        self.__get_weather_conditions = self.__report.getWeather()
        self.__get_conditions = self.__report.getConditions()
        self.__get_sky_conditions = self.__report.getSkyConditions()
        print "getWeather: '%s'" % self.__get_weather_conditions
        print "getConditions: "   , self.__get_conditions
        print "getSkyConditions: ", self.__get_sky_conditions
        if ((self.__report.getWeather() != None) and (self._WeatherConditions.get(self.__report.getWeather().lower()) != None)):
            self.__current_condition = self._WeatherConditions.get(self.__report.getWeather().lower())
        elif ((self.__report.getConditions()[0] != None) and (self._WeatherConditions.get(self.__report.getConditions()[0].lower()) != None)):
            self.__current_condition = self._WeatherConditions.get(self.__report.getConditions()[0].lower())
        elif ((self.__report.getSkyConditions() != None) and (self._WeatherConditions.get(self.__report.getSkyConditions().lower()) != None)):
            self.__current_condition = self._WeatherConditions.get(self.__report.getSkyConditions().lower())

        print "condition:", self.__current_condition

        #formatting sun data
        now = datetime.datetime.now().time()
        #FIXME: this is ugly
        self.__sunrise = self.__sun[0]
        print "Sunrise time " + self.__sun[0]
        self.__sunset = self.__sun[1]
        self.__sunrise_t = datetime.time(int(self.__sunrise.split(':')[0]), int(self.__sunrise.split(':')[1]), int(self.__sunrise.split(':')[2]))
        self.__sunset_t = datetime.time(int(self.__sunset.split(':')[0]), int(self.__sunset.split(':')[1]), int(self.__sunset.split(':')[2]))
        if now<self.__sunrise_t or now>self.__sunset_t:
            self.__night = True
        else:
			self.__night = False
    
    def isNight(self):
        return self.__night

    def isReportCorrect(self):
        return True if self.__report != None else False

    def isSevereCondition(self):
        if self.__current_condition != None:
            return self.__current_condition[2]
        else:
            print "BUG: Severe condition is empty!"
            return False;

    def getPureCondition(self):
        if self.__current_condition != None:
            return self.__current_condition[0]
        else:
            print "BUG: Condition name is empty!"
            return "BUG: Condition name is empty!";

    def getCondition(self):
        return "%s: %s" % (_("Condition"), self.getPureCondition())

    def getSkyCondition(self):
        return "%s: %s" % (_("Sky"), self.__report.getSkyConditions())

    def getPixmap(self):
        if self.__current_condition != None:
            if self.isNight:
                return self._Night_Icons.get(self.__current_condition[1])
            else:
                return self.__current_condition[1]
        else:
            print "BUG: Cannot get icon for weather condition"
            return "ubuntuone-client-offline"

    def getHumidity(self):
        return "%s: %s %s" % (_("Humidity"), self.__report.getHumidity(), "%")

    def getDewPoint(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getDewPointCelsius()
            _unit  = "C"
        else:
            _value = self.__report.getDewPointFahrenheit()
            _unit  = "F"
        return "%s: %s %s" % (_("Dew Point"), _value, _unit)

    def getPressure(self):
        return "%s: %s %s" % (_("Pressure"), self.__report.getPressure(), "hPa")

    def getPureTemperature(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getTemperatureCelsius()
            _unit  = "C"
        else:
            _value = self.__report.getTemperatureFahrenheit()
            _unit  = "F"
        return "%0.1f %s" % (_value, _unit)

    def getTemperature(self):
        return "%s: %s" % (_("Temperature"), self.getPureTemperature())

    def getHumidex(self):
        self.vapour_pressure = 6.11 * math.exp(5417.7530 * ( (1/273.16) - (1/(self.__report.getDewPointCelsius()+273.16))))
        self.humidex = self.__report.getTemperatureCelsius() + (0.5555)*(self.vapour_pressure  - 10.0);
        return "%s: %0.1f" % (_("Humidex"), self.humidex)

    def getVisibility(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getVisibilityKilometers()
            _unit  = _("km")
        else:
            _value = self.__report.getVisibilityMiles()
            _unit  = _("mile(s)")
        return "%s: %s %s" % (_("Visibility"), _value, _unit)

    def getWindDirection(self):
        #FIXME: return a "SW" instead of "280" degrees values
        return "%s: %s" % (_("Wind Direction"), self.__report.getWindDirection())

    def getWindSpeed(self):
        if (self.__wind_unit == WindUnits.MPS):
            _value = self.__report.getWindSpeed()
            _unit  = _("mps")
        if (self.__wind_unit == WindUnits.MPH):
            _value = self.__report.getWindSpeedMilesPerHour()
            _unit  = _("mph")
        if (self.__wind_unit == WindUnits.BEAUFORT):
            _value = self.__report.getWindSpeedBeaufort()
            _unit  = ""
        #if (self.__wind_unit == WindUnits.KNOTS):
        #    _value = self.__report.getWindSpeedKnots()
        #    _unit  = _("knot(s)")
        return "%s: %0.1f %s" % (_("Wind Speed"), _value, _unit)

    def getWindChill(self):
        if (self.__metric_system == MetricSystem.SI):
            _value = self.__report.getWindchill()
            _unit  = "C"
        else:
            _value = self.__report.getWindchillF()
            _unit  = "F"
        return "%s: %s %s" % (_("Wind Chill"), _value, _unit)

    def getSunrise(self):
        return "%s: %s" % (_("Sunrise"), time.strftime('%X',time.strptime(self.__sunrise,'%H:%M:%S')))

    def getSunset(self):
        return "%s: %s" % (_("Sunset"), time.strftime('%X',time.strptime(self.__sunset,'%H:%M:%S')))

class indicator_weather(threading.Thread):
    
    def __init__(self):
        threading.Thread.__init__(self)

    def __init__(self):
        self.winder = appindicator.Indicator ("indicator-weather", "weather-clear", appindicator.CATEGORY_OTHER)
        self.winder.set_status (appindicator.STATUS_ACTIVE)
        self.winder.set_attention_icon ("ubuntuone-client-error")
        
        self.rate = gconfClient.get_int("/apps/indicator-weather/refresh_rate")
        self.unit = gconfClient.get_string("/apps/indicator-weather/unit")
        self.notif = gconfClient.get_string("/apps/indicator-weather/notif")
        self.wind = gconfClient.get_string("/apps/indicator-weather/wind")
        self.placechosen = gconfClient.get_int("/apps/indicator-weather/placechosen")
        self.places = gconfClient.get_string("/apps/indicator-weather/places")

        #Setting default values
        self.metric_system = MetricSystem.SI
        self._wind_unit = WindUnits.MPH
        self.place = None
        self.menu = None
        
        if self.placechosen in (False, None):
            gconfClient.set_int("/apps/indicator-weather/placechosen", 0)
            self.placechosen = 0
        
        if self.unit in (False, None):
            gconfClient.set_string("/apps/indicator-weather/unit", 'S')
            self.unit = 'S'
        else:
            if (self.unit == 'S'):
                self.metric_system = MetricSystem.SI
            else:
                self.metric_system = MetricSystem.IMPERIAL
            
        if self.notif in (False, None):
            gconfClient.set_string("/apps/indicator-weather/notif", 'N')
            self.notif = 'N'
        
        if self.wind in (False, None):
            gconfClient.set_string("/apps/indicator-weather/wind", 'mph')
            self._wind_unit = WindUnits.MPH
        else:
            if (self.wind == 'mph'):
                self._wind_unit = WindUnits.MPH
            elif (self.wind == 'mps'):
                self._wind_unit = WindUnits.MPS
            elif (self.wind == 'beaufort'):
                self._wind_unit = WindUnits.BEAUFORT
            #elif (self.wind == 'knots'):
            #    self._wind_unit = WindUnits.KNOTS
            
        if self.rate in (False, None):
            gconfClient.set_int("/apps/indicator-weather/refresh_rate", 15)
            self.rate = self.rate = gconfClient.get_int("/apps/indicator-weather/refresh_rate")
            
        if self.places in (False, None, '', '[]', "['']",):
            self.menu_noplace()
        else:
            self.places = eval(self.places)
            self.menu_normal()
            self.place = self.places[self.placechosen]
            self.update_weather()
            self.winder.set_menu(self.menu)
            
    def menu_noplace(self):
        menu_noplace = gtk.Menu()
        setup = gtk.MenuItem(_("Set Up Weather..."))
        setup.connect("activate", self.prefs)
        setup.show()
        menu_noplace.append(setup)

        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        menu_noplace.append(quit)

        self.winder.set_menu(menu_noplace)
    
    def menu_normal(self):
        self.menu = gtk.Menu()
            
    ##City
        self.city_show = gtk.MenuItem()
        self.city_show.set_sensitive(True)
        self.menu.append(self.city_show)
        self.city_show.show()
        
    ##Condition
        self.cond_show = gtk.MenuItem()
        self.cond_show.set_sensitive(True)
        self.cond_show.show()
        self.menu.append(self.cond_show)
        
    ##Temperature        
        self.temp_show = gtk.MenuItem()
        self.temp_show.set_sensitive(True)
        self.temp_show.show()
        self.menu.append(self.temp_show)

    ##Humidex        
        self.humidex_show = gtk.MenuItem()
        self.humidex_show.set_sensitive(True)
        self.humidex_show.show()
        self.menu.append(self.humidex_show)
        
    ##Humidity
        self.humid_show = gtk.MenuItem()
        self.humid_show.set_sensitive(True)
        self.humid_show.show()
        self.menu.append(self.humid_show)
        
    ##Wind
        self.wind_show = gtk.MenuItem()
        self.wind_show.set_sensitive(True)
        self.wind_show.show()
        self.menu.append(self.wind_show)
                
    ##Sunrise
        self.sunrise_show = gtk.MenuItem()
        self.sunrise_show.set_sensitive(True)
        self.sunrise_show.show()
        self.menu.append(self.sunrise_show)

    ##Sunset
        self.sunset_show = gtk.MenuItem()
        self.sunset_show.set_sensitive(True)
        self.sunset_show.show()
        self.menu.append(self.sunset_show)
        
    ##Cities
        if len(self.places) != 1:
            ##Breaker
            breaker = gtk.SeparatorMenuItem()
            breaker.show()
            self.menu.append(breaker)
            
            loco1 = gtk.RadioMenuItem(None, self.places[0][1])
            if self.placechosen == 0:
                loco1.set_active(True)
            loco1.connect("toggled", self.on_city_changed)
            loco1.show()
            self.menu.append(loco1)
            for place in self.places[1:]:
                loco = gtk.RadioMenuItem(loco1, place[1])
                if self.places.index(place) == self.placechosen:
                    loco.set_active(True)
                loco.connect("toggled", self.on_city_changed)
                loco.show()
                self.menu.append(loco)
        
    ##Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)

        refresh_show = gtk.MenuItem(_("Refresh"))
        refresh_show.connect("activate", self.update_weather)
        refresh_show.show()
        self.menu.append(refresh_show)
        
        ext_show = gtk.MenuItem(_("Forecast"))
        ext_show.connect("activate", self.extforecast)
        ext_show.show()
        self.menu.append(ext_show)

    ##Preferences      
        prefs_show = gtk.MenuItem(_("Preferences..."))
        prefs_show.connect("activate", self.prefs)
        prefs_show.show()
        self.menu.append(prefs_show)

    ##Quit
        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        self.menu.append(quit)

        self.winder.set_menu(self.menu)
        if (hasattr(self.winder, 'set_label')):
            self.winder.set_label("")
        
    def on_city_changed(self,widget):
        if widget.get_active():
            for place in self.places:
                if (place[1] == widget.get_label()):
                    self.placechosen = self.places.index(place)
                    break
            gconfClient.set_int("/apps/indicator-weather/placechosen", self.placechosen)
            self.update_weather(False)

    def update_weather(self, notif=True,widget=None):
        weather = self.get_weather(self.places[self.placechosen])
        if weather == None:
            for item in self.menu.get_children()[0:len(self.menu.get_children())]:
                item.destroy()

            self.menu = gtk.Menu()
            self.problem_show = gtk.MenuItem(_("Connection problem"))
            self.problem_show.set_sensitive(False)
            self.problem_show.show()
            self.menu.append(self.problem_show)

            self.refresh_show = gtk.MenuItem(_("Refresh"))
            self.refresh_show.connect("activate", self.update_weather)
            self.refresh_show.show()
            self.menu.append(self.refresh_show)

            self.quit_menu = gtk.ImageMenuItem(gtk.STOCK_QUIT)
            self.quit_menu.connect("activate", self.quit)
            self.quit_menu.show()
            self.menu.append(self.quit_menu)

            self.winder.set_icon("ubuntuone-client-error")
            if (hasattr(self.winder, 'set_label')):
                self.winder.set_label("")
            self.winder.set_menu(self.menu)

            self.rateid = gobject.timeout_add(60000, self.update_weather)
            return
		
        self.condition = weather.getPureCondition()
        self.icon = weather.getPixmap()
        if (self.icon == False):
			self.winder.set_icon("ubuntuone-client-error")
        else:
        	self.winder.set_icon(self.icon)
        
        print 'Update :',weather.getPureCondition(),'(every',self.rate,'min. for',self.places[self.placechosen][1]+')'

        #self.city_table.attach(gtk.Label("City"), 0, 1, 0, 1)

        self.menu_normal()
        self.city_show.set_label(self.places[self.placechosen][1])
        self.cond_show.set_label(self.condition)
        self.temp_show.set_label(weather.getTemperature())
        self.humidex_show.set_label(weather.getHumidex())
        self.humid_show.set_label(weather.getHumidity())
        self.wind_show.set_label(weather.getWindSpeed())
        self.sunrise_show.set_label(weather.getSunrise())
        self.sunset_show.set_label(weather.getSunset())
        if (hasattr(self.winder, 'set_label')):
            self.winder.set_label(weather.getPureTemperature())
        
        if self.notif != 'N' and weather.isSevereCondition():
	        if self.condition != gconfClient.get_string("/apps/indicator-weather/current") and self.notif == 'U':
	            self.notify(self.condition, self.icon)
            #FIXME: Fix notitfications on severe events
            #elif current in ('thunderstorm', 'chance_of_tstorm') and self.notif == 'O':
	        #    self.notify(self.condition, self.icon, severe=True)
	            
        gconfClient.set_string("/apps/indicator-weather/current",self.condition)
        self.rateid = gobject.timeout_add(int(self.rate) * 60000, self.update_weather)
                
    def responseToDialog(self, entry, dialog, response):
        dialog.response(response)
            
    def get_weather(self, city, firstrun=False, extended=False, onlycity=False):
        self.current_location = Location(self.metric_system, self._wind_unit)
        if (self.current_location.find_city_by_code(city[0]) == False):
            print "location with code %s not found" % city[0]    
        if extended == False:
            self.current_location.update_weather_data()
            if (self.current_location.found == False) or (self.current_location.weather.isReportCorrect() == False):
                print "report is empty";
                return None;
            else:
                return self.current_location.weather
        else:
            self.current_location.prepare_forecast_data()
            self.daysofweek = self.current_location.get_forecast_daysofweek()
            self.lowdata    = self.current_location.get_forecast_lowdata()
            self.highdata   = self.current_location.get_forecast_highdata()
            self.icons      = self.current_location.get_forecast_icons()
            self.conditions = self.current_location.get_forecast_conditions()
        
    def prefs(self, widget):
        self.prefswindow = PreferencesDialog()
        self.prefswindow.show()
        
    def extforecast(self, widget):
        forecastwd = ExtendedForecast()
        forecastwd.show()
        
    def notify(self,conditon,icon,severe=False):
        if severe:
			n = pynotify.Notification (_("Severe weather alert"),
                self.condition,
                icon)
        else:
		    n = pynotify.Notification (self.condition,"",icon)
        n.show ()

    def quit(self, widget, data=None):
        gtk.main_quit()

class PreferencesDialog(gtk.Dialog):
    __gtype_name__ = "PreferencesDialog"
    def __new__(cls):
        builder = get_builder('PreferencesDialog')
        new_object = builder.get_object("preferences_dialog")
        new_object.finish_initializing(builder)
        return new_object

    def finish_initializing(self, builder):
        self.builder = builder
        if wi.unit == 'S':
            self.builder.get_object('si').set_active(True)
        elif wi.unit == 'I':
            self.builder.get_object('imperial').set_active(True)
        if wi.notif == 'N':
            self.builder.get_object('nonotif').set_active(True)
        elif wi.notif == 'O':
            self.builder.get_object('notifsevere').set_active(True)
        else:
            self.builder.get_object('notifall').set_active(True)            
        
        if wi.wind == 'mps':
            self.builder.get_object('mps').set_active(True)
        elif wi.wind == 'mph':
            self.builder.get_object('mph').set_active(True)
        #elif wi.wind == 'knots':
        #    self.builder.get_object('knots').set_active(True)
        else:
            self.builder.get_object('beaufort').set_active(True)
        
        self.builder.get_object('rate').set_value(wi.rate)
        if wi.places != None:
            for place in wi.places:
                newplace = list()
                newplace.append(place[1])
                newplace.append(place[0])
            
                self.builder.get_object('citieslist').append(newplace)
            self.builder.get_object('button1').set_sensitive(True)
            
        self.builder.connect_signals(self)
        
    def on_remove_location(self, widget):
        selection = self.builder.get_object('displaylist').get_selection()
        model, iter = selection.get_selected()
        if iter != None:
            model.remove(iter)

        if (self.builder.get_object('citieslist').get_iter_first() == None):
            self.builder.get_object('button1').set_sensitive(False)

    def on_add_location(self, widget):
        self.assistant = Assistant()
        self.assistant.show()
       
    def on_destroy(self, widget, data=None):
        pass
        #"""Called when the WeatherIndicatorWindow is closed."""
        #gtk.main_quit()
    #def on_city_edited(self,widget,path,value):
        ###CHECK AVAILABILITY
        #self.builder.get_object('citieslist').set_value(self.builder.get_object('citieslist').get_iter_from_string(path), 0, value)
    
    def ok(self, widget, data=None):
        """The user has selected to save the changes.

        Called before the dialog returns gtk.RESONSE_OK from run().
        """
        needupdate = False
        # Metric System
        metric_systems = [('si',       "S", MetricSystem.SI),
                          ('imperial', "I", MetricSystem.IMPERIAL)]

        for metric_system in metric_systems:
            if self.builder.get_object(metric_system[0]).get_active():
                new_unit = metric_system[1]
                new_metric_system = metric_system[2]

        if (wi.unit != new_unit):
            wi.unit = new_unit
            wi.metric_system = new_metric_system
            gconfClient.set_string("/apps/indicator-weather/unit", wi.unit)
            needupdate = True
            print 'Unit changed :', wi.unit

        # Wind Units
        wind_systems = [('mps',      "mps",      WindUnits.MPS),
                        ('mph',      "mph",      WindUnits.MPH),
                        ('beaufort', "beaufort", WindUnits.BEAUFORT)]
                        #('knots',    "knots",    WindUnits.KNOTS)]

        for wind_system in wind_systems:
            if self.builder.get_object(wind_system[0]).get_active():
                new_wind_unit   = wind_system[1]
                new_wind_system = wind_system[2]

        if (wi.wind != new_wind_unit):
            wi.wind = new_wind_unit
            wi._wind_unit = new_wind_system
            gconfClient.set_string("/apps/indicator-weather/wind", wi.wind)
            needupdate = True
            print 'Wind Unit changed :', wi.wind

        # Notifications
        notifications = [('nonotif',     "N"),
                         ('notifsevere', "O"),
                         ('notifall',    "U")]
        for notification in notifications:
            if self.builder.get_object(notification[0]).get_active():
                new_notification  = notification[1]

        if (wi.notif != new_notification):
            wi.notif = new_notification
            gconfClient.set_string("/apps/indicator-weather/notif", wi.notif)
            needupdate = True
            print 'Notifications changed :', wi.notif

        ##Rate
        if int(self.builder.get_object('rate').get_value()) != wi.rate:
            gconfClient.set_int("/apps/indicator-weather/refresh_rate", int(self.builder.get_object('rate').get_value()))
            wi.rate = int(self.builder.get_object('rate').get_value())
            gobject.source_remove(wi.rateid)
            wi.rateid = gobject.timeout_add(int(wi.rate) * 60000, wi.update_weather)
            print 'Rate changed :',wi.rate
            
        ##places
        newplaces = list()
        item = self.builder.get_object('citieslist').get_iter_first()
        while ( item != None ):
            newplace = list()
            newplace.append(self.builder.get_object('citieslist').get_value (item, 1))
            newplace.append(self.builder.get_object('citieslist').get_value (item, 0))
            newplaces.append(newplace)
            item = self.builder.get_object('citieslist').iter_next(item)
        if newplaces != wi.places:
            wi.places = newplaces
            if len(wi.places) >= 1:
                gconfClient.set_string("/apps/indicator-weather/places", str(wi.places))
                if (type(wi.place) != None) and (wi.place in wi.places):
                    wi.placechosen = wi.places.index(wi.place)
                else:
                    wi.placechosen = 0
                gconfClient.set_int("/apps/indicator-weather/placechosen", wi.placechosen)
                wi.menu_normal()
                wi.winder.set_menu(wi.menu)
                needupdate = True
            else:
                wi.placechosen = 0
                gconfClient.set_int("/apps/indicator-weather/placechosen", wi.placechosen)
                gconfClient.set_string("/apps/indicator-weather/places", str([wi.places]))
                wi.winder.set_icon("weather-clear")
                wi.menu_noplace()
                needupdate = False
            
        ##Wind
        #for button in self.builder.get_object('m/s').get_group():
            #if button.get_active() == True and button.get_label() != wi.windunit:
                #gconfClient.set_string("/apps/indicator-weather/wind", button.get_label())
                #wi.windunit = button.get_label()
                #needupdate = True
                #print 'Wind changed :', wi.windunit
        
        if needupdate:
            wi.update_weather(False)
        
        # Make any updates to self._preferences here. e.g.
        #self._preferences["preference1"] = "value2"
        #self._save_preferences()
        self.destroy()

    def cancel(self, widget, data=None):
        """The user has elected cancel changes.

        Called before the dialog returns gtk.RESPONSE_CANCEL for run()
        """
        # Restore any changes to self._preferences here.
        self.destroy()
        
class ExtendedForecast(gtk.Window):
    __gtype_name__ = "ExtendedForecast"
    def __new__(cls):
        builder = get_builder('ExtendedForecast')
        new_object = builder.get_object("extended_forecast")
        new_object.finish_initializing(builder)
        return new_object
        
    def finish_initializing(self, builder):
        self.builder = builder
        self.builder.connect_signals(self)
        
        self.builder.get_object('extended_forecast').set_title(_('Weather Forecast for ')+wi.places[wi.placechosen][1])
        wi.get_weather(wi.places[wi.placechosen],False,True)
        
        self.builder.get_object('day1lbl').set_label('<big>%s</big>' % wi.daysofweek[0].capitalize())
        self.builder.get_object('day2lbl').set_label('<big>%s</big>' % wi.daysofweek[1].capitalize())
        self.builder.get_object('day3lbl').set_label('<big>%s</big>' % wi.daysofweek[2].capitalize())
        self.builder.get_object('day4lbl').set_label('<big>%s</big>' % wi.daysofweek[3].capitalize())
        i=0
        for icon in wi.icons[1:]:
            i=i+1
            if icon in ('chance_of_storm', 'storm', 'thunderstorm', 'chance_of_tstorm'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-storm',gtk.ICON_SIZE_BUTTON)
            elif icon in ('sleet',  'snow',  'icy',  'flurries',  'chance_of_snow'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-snow',gtk.ICON_SIZE_BUTTON)
            elif icon in ('dust',  'fog',  'smoke',  'haze',  'mist'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-fog',gtk.ICON_SIZE_BUTTON)
            elif icon in ('rain'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-showers',gtk.ICON_SIZE_BUTTON)
            elif icon in ('chance_of_rain'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-showers-scattered',gtk.ICON_SIZE_BUTTON)
            elif icon in ('sunny', 'clear'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-clear',gtk.ICON_SIZE_BUTTON)
            elif icon in ('mostly_cloudy', 'cloudy'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-overcast',gtk.ICON_SIZE_BUTTON)
            elif icon in ('mostly_sunny',  'partly_cloudy'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-few-clouds',gtk.ICON_SIZE_BUTTON)
            else:
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('window-close',gtk.ICON_SIZE_BUTTON)
        i=0
        for condition in wi.conditions[1:]:
            i=i+1
            self.builder.get_object('day%scond' % str(i)).set_label(condition)
        i=0
        if wi.unit == 'S':
            tempunit = '°C'
        elif wi.unit == 'I':
            tempunit = '°F'
        for high in wi.highdata:
            i=i+1
            self.builder.get_object('day%stemphigh' % str(i)).set_label((_('High: ')+'%s%s') % (high,tempunit))
        i=0
        for low in wi.lowdata:
            i=i+1
            self.builder.get_object('day%stemplow' % str(i)).set_label((_('Low: ')+'%s%s') % (low,tempunit))
        
    
    def close(self, widget, data=None):
        self.destroy()
    
    def on_destroy(self, widget, data=None):
        pass
        
#class EditPlace(gtk.MessageDialog):
    #__gtype_name__ = "EditPlace"
    #def __new__(cls):
        #builder = get_builder('EditPlace')
        #new_object = builder.get_object("edit_place")
        #new_object.finish_initializing(builder)
        #return new_object
        
    #def finish_initializing(self, builder):
        #self.builder = builder
        #self.builder.connect_signals(self)
    
    #def ok(self, widget, data=None):
        #self.destroy()
        #if self.builder.get_object("entry").get_text() != '':
            #return self.builder.get_object("entry").get_text()
        #else:
            #return False
        ###APPLY CHANGES
        
    #def cancel(self, widget, data=None):
        #"""The user has elected cancel changes.

        #Called before the dialog returns gtk.RESPONSE_CANCEL for run()
        #"""
        ## Restore any changes to self._preferences here.
        #self.destroy()
        #return False

class Assistant(gtk.Assistant):
    __gtype_name__ = "Assistant"
    
    def __new__(cls):
        builder = get_builder('Assistant')
        new_object = builder.get_object("assistant")
        new_object.finish_initializing(builder)  
        return new_object

    # Generate a treeview model for gweather data
    def generate_treeview(self):
        #FIXME: Move this to WI object
        self.__all_locations_store = gtk.TreeStore(str, str, bool, str)
        node = gweather.location_new_world(True)
        self.parse_gweather_locations(node, None)
        return self.__all_locations_store

    # Recursevly parse locations
    def parse_gweather_locations(self, node, parent):
        children = node.get_children()
        if len(children) > 0:
            for i in children:
                timezone = i.get_timezone().get_tzid() if i.get_timezone() is not None else None
                is_city = i.get_level() is gweather.LOCATION_CITY
                if (i.get_level() is gweather.LOCATION_WEATHER_STATION) or (len(i.get_children())>0):
                    node_iter = self.__all_locations_store.append(parent, (i.get_name(), timezone, is_city, i.get_code()))
                    # Iterate through children
                    self.parse_gweather_locations(i, node_iter)

        #elif (node.get_level() is gweather.LOCATION_COUNTRY) and (len(node.get_children())>0):
        #    for i in node.get_timezones():
        #        if (i.get_name() is not None):
        #            self.__all_locations_store.append(parent, (i.get_name(), i.get_tzid(), False, None))

    # Finish UI initialization - fill in tree
    def finish_initializing(self, builder):
        self.builder = builder
        self.builder.connect_signals(self)
        self.assistant = self.builder.get_object("assistant")
        self.assistant.set_page_complete(self.builder.get_object("label"),True)
        self.assistant.set_page_complete(self.builder.get_object("review"),True)
        self.assistant.set_page_complete(self.builder.get_object("confirmplace"),True)
        # Fill in tree
        self.__all_locations_view = self.builder.get_object("treeview-locations")
        column = gtk.TreeViewColumn("Location", gtk.CellRendererText(), text=0)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
        self.__all_locations_view.append_column(column)
        self.__all_locations_view.set_fixed_height_mode(True)

        self.__all_locations_store = gtk.TreeStore(str, str, bool, str)
        self.__all_locations_store.set_sort_column_id(0, gtk.SORT_ASCENDING)
        self.generate_treeview()
        self.__all_locations_view.set_model(self.__all_locations_store)
        self.__all_locations_selection = self.__all_locations_view.get_selection()
        self.__all_locations_selection.connect("changed", self.on_selection_changed)

        self.assistant.set_forward_page_func(self.get_city)

    #Callback for row selection
    def on_selection_changed(self,selection):
        self.assistant.set_page_complete(self.builder.get_object("placeinput"),False)
        if selection.count_selected_rows() != 0:
            select_iter = selection.get_selected()[1]
            if self.is_location_and_leaf_node(select_iter):
                self.assistant.set_page_complete(self.builder.get_object("placeinput"),True)

    #Check, that selected row is a leaf and enable "next" button    
    def is_location_and_leaf_node(self, iter):
        row = self.__all_locations_store[iter]
        is_leaf_node = not self.__all_locations_store.iter_has_child(iter)
        return row[0] is not None and row[1] is not None and is_leaf_node

    # Create a location out of a tree
    def get_city(self,current_page):
        if self.assistant.get_current_page() == 1:
            select_iter = self.__all_locations_selection.get_selected()[1]
            city_iter = self.__all_locations_store[select_iter]
            self.city_code = city_iter[3]
            self.location = Location(wi.metric_system, wi._wind_unit)
            self.location.find_city_by_code(self.city_code)
            if self.location.found:
                print "city was found " + self.location.get_full_city_name()
                self.builder.get_object("lblplace").set_label('<big>%s</big>' % self.location.get_full_city_name())
                self.builder.get_object("entrylbl").set_text(self.location.get_short_city_name())
            else:
                print "BUG: city with code '%s' not found" % self.city_code 
        elif self.assistant.get_current_page() == 2:
            lbl = self.builder.get_object("entrylbl").get_text()
            if lbl == '':
                self.location.set_label(self.location.get_full_city_name())
                self.builder.get_object("lbl3").set_label('')
            else:
                self.location.set_label(self.builder.get_object("entrylbl").get_text())
                self.builder.get_object("lbl3").set_label('Label:')

            self.builder.get_object("labellbl").set_label('<b>%s</b>' % self.location.label)
            self.builder.get_object("placelbl").set_label('<b>'+self.location.get_full_city_name()+'</b>')
            
        return self.assistant.get_current_page() + 1
            
    def on_cancel(self,widget):
        self.destroy()
        
    def on_apply(self,widget):
        newplace = list()
        newplace.append(self.location.label)
        newplace.append(self.location.code)
        wi.prefswindow.builder.get_object('citieslist').append(newplace)
        wi.prefswindow.builder.get_object('button1').set_sensitive(True)
        self.hide()

class singleinstance(object):
    '''
    singleinstance - based on Windows version by Dragan Jovelic this is a Linux
                     version that accomplishes the same task: make sure that
                     only a single instance of an application is running.

    '''
                        
    def __init__(self, pidPath):
        '''
        pidPath - full path/filename where pid for running application is to be
                  stored.  Often this is ./var/<pgmname>.pid
        '''
        self.pidPath=pidPath
        #
        # See if pidFile exists
        #
        if os.path.exists(pidPath):
            #
            # Make sure it is not a "stale" pidFile
            #
            pid=open(pidPath, 'r').read().strip()
            #
            # Check list of running pids, if not running it is stale so
            # overwrite
            #
            pidRunning=commands.getoutput('ls /proc | grep %s' % pid)
            if pidRunning:
                self.lasterror=True

            else:
                self.lasterror=False

        else:
            self.lasterror=False

        if not self.lasterror:
            #
            # Write my pid into pidFile to keep multiple copies of program from
            # running.
            #
            fp=open(pidPath, 'w')
            fp.write(str(os.getpid()))
            fp.close()

    def alreadyrunning(self):
        return self.lasterror

    def __del__(self):
        if not self.lasterror:
            os.unlink(self.pidPath)

def main():
    gtk.main()
    return 0

if __name__ == "__main__":
    #
    # do this at beginnig of your application
    #
    myapp = singleinstance("/tmp/weather-indicator.pid")
    #
    # check is another instance of same program running
    #
    if myapp.alreadyrunning():
        sys.exit(_("Another instance of this program is already running"))
        
    #
    # not running, safe to continue...
    #
    gtk.gdk.threads_init()
    gtk.gdk.threads_enter()
    wi = indicator_weather()
    main()
    gtk.gdk.threads_leave()
