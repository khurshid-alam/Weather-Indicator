#!/usr/bin/python
# -*- coding: utf-8 -*-
### BEGIN LICENSE
# Copyright (C) 2010 Sebastian MacDonald Sebas310@gmail.com
# Copyright (C) 2010 Mehdi Rejraji mehd36@gmail.com
# This program is free software: you can redistribute it and/or modify it 
# under the terms of the GNU General Public License version 3, as published 
# by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranties of 
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
# PURPOSE.  See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along 
# with this program.  If not, see <http://www.gnu.org/licenses/>.
### END LICENSE

import sys
import os
import gtk
import pygtk
pygtk.require('2.0')
import gobject
import appindicator
import urllib2
import re
import locale
import pynotify
from xml.dom.minidom import parseString
import datetime
import math
import commands
import threading
import logging
import logging.handlers
import tempfile
import couchdb
from gweather.I_KNOW_THIS_IS_UNSTABLE import gweather
import pymetar as metar
from desktopcouch.records.server import CouchDatabase
from desktopcouch.records.record import Record as CouchRecord
import time
import pywapi

import gettext
from gettext import gettext as _
gettext.textdomain('indicator-weather')

# Add project root directory (enable symlink, and trunk execution).
PROJECT_ROOT_DIRECTORY = os.path.abspath(
    os.path.dirname(os.path.dirname(os.path.realpath(sys.argv[0]))))

if (os.path.exists(os.path.join(PROJECT_ROOT_DIRECTORY, 'indicator_weather'))
    and PROJECT_ROOT_DIRECTORY not in sys.path):
    sys.path.insert(0, PROJECT_ROOT_DIRECTORY)
    os.putenv('PYTHONPATH', PROJECT_ROOT_DIRECTORY) # for subprocesses

from indicator_weather.helpers import get_builder

class Settings:
    db = None

    def prepare_settings_store(self):
        log.debug("Settings: preparing settings store")
        self.db = CouchDatabase("weatherindicator", create = True)

        self.settings_design_doc = "settings"
        self.settings_view = "function(doc) {if (doc.record_type == '%s') {emit(doc.name, doc);}}" % self.settings_design_doc
        self.db.add_view("get_setting", self.settings_view, None, self.settings_design_doc)

        self.weather_design_doc = "weather"
        self.weather_view = "function(doc) {if (doc.record_type == '%s') {emit(doc.location, doc)} ;}" % self.weather_design_doc
        self.db.add_view("get_weather", self.weather_view, None, self.weather_design_doc)

        self.location_design_doc = "location"
        self.location_view = "function(doc) {if (doc.record_type == '%s') {emit(doc.location, doc)} ;}" % self.location_design_doc
        self.db.add_view("get_location", self.location_view, None, self.location_design_doc)

    def get_value(self, setting, return_id = False):
        log.debug("Setting: getting value for %s" % setting)
        view = self.db.execute_view("get_setting", self.settings_design_doc)[setting]
        if hasattr(view, 'rows') and len(view.rows) > 0:
            if return_id:
                return str(view.rows[0].value['_id'])
            else:
                return str(view.rows[0].value['value'])
        else:
            log.debug("Setting: can't find value for %s" % setting)

    def set_value(self, setting, value):
        log.debug("Setting: setting '%s'='%s'" % (setting, value))
        self.record = {
            "name" : setting,
            "value": value
        }
        old_doc_id = self.get_value(setting, return_id=True)
        if old_doc_id != None:
            log.debug("Setting: setting '%s' was updated" % setting)
            self.db.update_fields(old_doc_id, self.record)
        else:
            log.debug("Setting: setting '%s' was created" % setting)
            self.db.put_record(CouchRecord(self.record, self.settings_design_doc))
 
    def get_weather(self, location_code, return_id = False):
        log.debug("Setting: getting cached weather for %s" % location_code)
        view = self.db.execute_view("get_weather", self.weather_design_doc)[location_code]
        if hasattr(view, 'rows') and len(view.rows) > 0:
            if return_id:
                return str(view.rows[0].value['_id'])
            else:
                return str(view.rows[0].value['data'])
        else:
            return None
            log.debug("Setting: can't find cached weather for %s" % setting)

    def save_weather(self, weather, location_code):
        log.debug("Setting: Saving cached weather data")
        self.record = {
          "location" : location_code,
          "data"      : {
            "label"    : weather.getPureTemperature(),
            "condition": weather.getCondition(),
            "icon"     : weather.getPixmap(),
            "temper"   : weather.getTemperature(),
            "humidex"  : weather.getHumidex(),
            "humidity" : weather.getHumidity(),
            "wind"     : weather.getWindSpeed(),
            "sunrise"  : weather.getSunrise(),
            "sunset"   : weather.getSunset()
          }
        }
        old_doc_id = self.get_weather(location_code, return_id=True)
        if old_doc_id != None:
            self.db.update_fields(old_doc_id, self.record)
        else:    
            self.db.put_record(CouchRecord(self.record, self.weather_design_doc))

    def get_location_details(self, location_code, return_id = False):
        log.debug("Setting: getting location details for %s" % location_code)
        view = self.db.execute_view("get_location", self.location_design_doc)[location_code]
        if hasattr(view, 'rows') and len(view.rows) > 0:
            if return_id:
                return str(view.rows[0].value['_id'])
            else:
                return str(view.rows[0].value['data'])
        else:
            return None
            log.debug("Setting: can't find location details for %s" % setting)

    def save_location_details(self, location_details, location_code):
        log.debug("Setting: Saving location details data")
        self.record = {
          "location" : location_code,
          "data"      : {
            "label"    : location_details['label'],
            "full name": location_details['full_name'],
            "latitude" : location_details['latitude'],
            "longitude": location_details['longitude'],
            "google id": location_details['google id'],
            "yahoo id" : location_details['yahoo id'],
            "noaa id"  : location_details['noaa id'],
          }
        }
        old_doc_id = self.get_location_details(location_code, return_id=True)
        if old_doc_id != None:
            self.db.update_fields(old_doc_id, self.record)
        else:    
            self.db.put_record(CouchRecord(self.record, self.location_design_doc))

class MetricSystem:
    SI = 1
    IMPERIAL = 2

class WindUnits:
    MPS = 1
    MPH = 2
    BEAUFORT = 3
    KPH = 4
    KNOTS = 5

class WeatherDataSource:
    GOOGLE = 1
    YAHOO = 2

class Location:
    """
    Data object which contains the name of a city (label), its GWeather object "location"
    """

    #Initialize an object with a label
    def __init__(self, metric_system, wind_units, location_details):
        self.metric_system = metric_system
        self.wind_units = wind_units
        self.full_name = location_details['full name']
        self.lat = location_details['latitude']
        self.lon = location_details['longitude']
        self.google_id = location_details['google id']
        self.yahoo_id = location_details['yahoo id']
        self.noaa_id = location_details['noaa id']
        self.label = location_details['label']
        self.location_details = location_details

    #FIXME: Update with PyWAPI
    #def find_city_by_code(self, location_id):
    #    #Find location details from GeoNames
    #    url = "http://api.geonames.org/get?geonameId=625144&username=indicatorweather&style=full"
    #    try:
    #        f = urllib2.urlopen(url)
    #        s=f.read()
    #        parsed = parseString(s)
    #        self.__code = location_id
    #        self.__lat = parsed.getElementsByTagName("lat")[0].firstChild.nodeValue
    #        self.__lon = parsed.getElementsByTagName("lng")[0].firstChild.nodeValue
    #        city_name = parsed.getElementsByTagName("name")[0].firstChild.nodeValue
    #        country_name = parsed.getElementsByTagName("countryName")[0].firstChild.nodeValue
    #        self.__full_name = "%s, %s" % (city_name, country_name)
    #        self.__found = True
    #        return True
    #    except urllib2.URLError:
    #        print "error reaching url %s" % url
    #        self.__found = False
    #        return False

    #Update weather data and store weather object
    def update_weather_data(self):
        #self.weather = Weather(self.google_id, WeatherDataSource.GOOGLE, self.metric_system, self.wind_units, self.lat, self.lon)
        self.weather = Weather(self.yahoo_id, WeatherDataSource.YAHOO, self.metric_system, self.wind_units, self.lat, self.lon)

class Forecast:

    def __init__ (self, units, source, location, locale):
        self.metric_system = units
        self.source = source
        self.location = location
        self.locale = locale

    #Get and store forecast data - use Google
    def prepare_forecast_data(self):
        self.daysofweek = []
        self.icons = []
        self.conditions = []
        try:
            #Correcting lat and lon for google
            lat = self.location.lat
            lon = self.location.lon
            self.forecast = pywapi.get_weather_from_google (",,,%s,%s" % (lat, lon), hl = self.locale)
            self.unitsystem = self.forecast['forecast_information']['unit_system']

            for forecast in self.forecast['forecasts']:
                self.daysofweek.append(forecast["day_of_week"])
                self.icons.append(forecast["icon"].split("/ig/images/weather/")[-1].split(".gif")[0])
                self.conditions.append(forecast["condition"])
        except urllib2.URLError:
            print "error reaching url %s" % url

    #Parse high values for forecast data
    def get_forecast_data(self):
        self.highdata = []
        self.lowdata = []

        if ((self.unitsystem == 'SI') and (self.metric_system == MetricSystem.SI)) or ((self.unitsystem == 'US') and (self.metric_system == MetricSystem.IMPERIAL)):
            #correct scale selected
            for forecast in self.forecast['forecasts']:
                self.highdata.append(forecast["high"])
                self.lowdata.append(forecast["low"])

        elif ((self.unitsystem == 'SI') and (self.metric_system == MetricSystem.IMPERIAL)):
            #convert from SI to imperial
            for forecast in self.forecast['forecasts']:
                self.highdata.append(int(((int(forecast["high"])*9)/5)+32))
                self.lowdata.append(int(((int(forecast["low"])*9)/5)+32))

        elif ((self.unitsystem == 'US') and (self.metric_system == MetricSystem.SI)):
            #convert from imperial to SI
            for forecast in self.forecast['forecasts']:
                self.highdata.append(int((((int(forecast["high"]))-32)*5)/9))
                self.lowdata.append(int((((int(forecast["low"]))-32)*5)/9))

        return (self.highdata, self.lowdata)

    #Parse a list of days of week with forecast data
    def get_forecast_daysofweek(self):
        return self.daysofweek

    #Parse icons for forecast data
    def get_forecast_icons(self):
        return self.icons

    #Parse conditions for forecast data
    def get_forecast_conditions(self):
        return self.conditions

class Weather:
    """
    Data object to parse metar weather object and convert units
    """

    #Available conditions and their icons (basing on Google or Yahoo icons
    #Formats: Google/Yahoo name: (gweather icon for day, icon for night, severe weather condition
    _WeatherConditions = {
        #Google conditions
        "sunny"            : ( "weather-clear",      "weather-clear-night",      False),
        "mostly_sunny"     : ( "weather-clear",      "weather-clear-night",      False),
        "partly_cloudy"    : ( "weather-few-clouds", "weather-few-clouds-night", False),
        "mostly_cloudy"    : ( "weather-overcast",   "weather-overcast",         False),
        "cloudy"           : ( "weather-clouds",     "weather-clouds-night",     False),
        "rain"             : ( "weather-showers",    "weather-showers",          False),
        "chance_of_rain"   : ( "weather-showers",    "weather-showers",          False),
        "sleet"            : ( "weather-snow",       "weather-snow",             False),
        "snow"             : ( "weather-snow",       "weather-snow",             False),
        "chance_of_snow"   : ( "weather-snow",       "weather-snow",             False),
        "icy"              : ( "weather-snow",       "weather-snow",             False),
        "dust"             : ( "weather-fog",        "weather-fog",              False),
        "fog"              : ( "weather-fog",        "weather-fog",              False),
        "mist"             : ( "weather-fog",        "weather-fog",              False),
        "smoke"            : ( "weather-fog",        "weather-fog",              False),
        "haze"             : ( "weather-fog",        "weather-fog",              False),
        "flurries"         : ( "weather-storm",      "weather-storm",            False),
        "chance_of_storm"  : ( "weather-storm",      "weather-storm",            True),
        "storm"            : ( "weather-storm",      "weather-storm",            True),
        "thunderstorm"     : ( "weather-stoom",      "weather-storm",            True),
        "chance_of_tstorm" : ( "weather-storm",      "weather-storm",            True),
    }

    _WeatherCodes = {
        #Yahoo conditions by code
        '0' : ("weather-storm",             "weather-storm",            True,  _("Tornado")),
        '1' :	("weather-storm",             "weather-storm",            True,  _("Tropical storm")),
        '2' :	("weather-storm",             "weather-storm",            True,  _("Hurricane")),
        '3' :	("weather-storm",             "weather-storm",            True,  _("Severe thunderstorms")),
        '4' :	("weather-storm",             "weather-storm",            True,  _("Thunderstorms")),
        '5' :	("weather-snow",              "weather-snow",             False, _("Mixed rain and snow")),
        '6' :	("weather-showers",           "weather-showers",          False, _("Mixed rain and sleet")),
        '7' :	("weather-snow",              "weather-snow",             False, _("Mixed snow and sleet")),
        '8' :	("weather-showers",           "weather-showers",          False, _("Freezing drizzle")),
        '9' :	("weather-showers",           "weather-showers",          False, _("Drizzle")),
        '10':	("weather-snow",              "weather-snow",             False, _("Freezing rain")),
        '11':	("weather-showers",           "weather-showers",          False, _("Showers")),
        '12':	("weather-showers",           "weather-showers",          False, _("Showers")),
        '13':	("weather-snow",              "weather-snow",             False, _("Snow flurries")),
        '14':	("weather-snow",              "weather-snow",             False, _("Light snow showers")),
        '15':	("weather-snow",              "weather-snow",             False, _("Blowing snow")),
        '16':	("weather-snow",              "weather-snow",             False, _("Snow")),
        '17':	("weather-showers",           "weather-showers",          False, _("Hail")),
        '18':	("weather-snow",              "weather-snow",             False, _("Sleet")),
        '19':	("weather-fog",               "weather-fog",              False, _("Dust")),
        '20':	("weather-fog",               "weather-fog",              False, _("Foggy")),
        '21':	("weather-fog",               "weather-fog",              False,  _("Haze")),
        '22':	("weather-fog",               "weather-fog",              False, _("Smoky")),
        '23':	("weather-clear",             "weather-clear-night",      False, _("Blustery")),
        '24':	("weather-clear",             "weather-clear-night",      False, _("Windy")),
        '25':	("weather-clear",             "weather-clear-night",      False, _("Cold")),
        '26':	("weather-clouds",            "weather-clouds-night",     False, _("Cloudy")),
        '27':	("weather-clouds",            "weather-clouds-night",     False, _("Mostly cloudy")),
        '28':	("weather-clouds",            "weather-clouds-night",     False, _("Mostly cloudy")),
        '29':	("weather-few-clouds",        "weather-few-clouds-night", False, _("Partly cloudy")),
        '30':	("weather-few-clouds",        "weather-few-clouds-night", False, _("Partly cloudy")),
        '31':	("weather-clear",             "weather-clear-night",      False, _("Clear")),
        '32':	("weather-clear",             "weather-clear-night",      False, _("Sunny")),
        '33':	("weather-clear",             "weather-clear-night",      False, _("Fair")),
        '34':	("weather-clear",             "weather-clear-night",      False, _("Fair")),
        '35':	("weather-showers-scattered", "weather-showers-scattered",False, _("Mixed rain and hail")),
        '36':	("weather-clear",             "weather-clear-night",      False, _("Hot")),
        '37':	("weather-storm",             "weather-storm",            True,  _("Isolated thunderstorms")),
        '38':	("weather-storm",             "weather-storm",            True,  _("Scattered thunderstorms")),
        '39':	("weather-storm",             "weather-storm",            True,  _("Scattered thunderstorms")),
        '40':	("weather-showers-scattered", "weather-showers-scattered",False, _("Scattered showers")),
        '41':	("weather-snow",              "weather-snow",             False, _("Heavy snow")),
        '42':	("weather-snow",              "weather-snow",             False, _("Scattered snow showers")),
        '43':	("weather-snow",              "weather-snow",             False, _("Heavy snow")),
        '44':	("weather-few-clouds",        "weather-few-clouds-night", False, _("Partly cloudy")),
        '45':	("weather-storm",             "weather-storm",            True,  _("Thundershowers")),
        '46':	("weather-snow",              "weather-snow",             False, _("Snow showers")),
        '47':	("weather-storm",             "weather-storm",            True,  _("Isolated thundershowers"))
    }

    def __init__(self, location_id, weather_datasource, metric_system, wind_unit, lat, lon):
        self.__weather_datasource = weather_datasource
        self.__metric_system = metric_system
        self.__wind_unit = wind_unit
        self.__current_condition = None
        self.__lat = lat
        self.__lon = lon

        if self.__weather_datasource == WeatherDataSource.GOOGLE:
            self.__report = pywapi.get_weather_from_google (location_id, hl = 'en')
            locale_name = locale.getlocale()[0].split('_')[0]
            self.__localized_report = pywapi.get_weather_from_google (location_id, hl = locale_name)
            icon_name = self.__report['current_conditions']['icon'].replace('/ig/images/weather/', '').replace('.gif', '')
            self.__current_condition = self._WeatherConditions.get(icon_name)

        if self.__weather_datasource == WeatherDataSource.YAHOO:
            self.__report = pywapi.get_weather_from_yahoo (location_id, 'imperial')
            self.__localized_report = self.__report
            icon_name = self.__report['condition']['code']
            self.__current_condition = self._WeatherCodes.get(icon_name)
        log.debug("Weather: current condition: '%s', '%s'" % (icon_name, str(self.__current_condition)))
        self.get_sun_data()

    #Get sun status
    def get_sun_data(self):
        if self.__weather_datasource == WeatherDataSource.GOOGLE:
            now = datetime.datetime.now() 
            url = 'http://www.earthtools.org/sun/%s/%s/%s/%s/99/1' % (self.__lat, self.__lon, now.day, now.month)
            try:
                f = urllib2.urlopen(url)
                s=f.read()
                parsed = parseString(s)
                sunrise = parsed.getElementsByTagName("morning")[0].getElementsByTagName("sunrise")[0].firstChild.nodeValue
                sunset  = parsed.getElementsByTagName("evening")[0].getElementsByTagName("sunset")[0].firstChild.nodeValue
                timezone = parsed.getElementsByTagName("timezone")[0].firstChild.nodeValue
                self.__sunrise_t = datetime.datetime.strptime(sunrise, '%H:%M:%S').time()
                self.__sunset_t = datetime.datetime.strptime(sunset, '%H:%M:%S').time()
            except urllib2.URLError:
                print "error reaching url %s" % url

        if self.__weather_datasource == WeatherDataSource.YAHOO:
            sunrise = self.__report['astronomy']['sunrise']
            sunset = self.__report['astronomy']['sunset']
            locale.setlocale(locale.LC_ALL, 'C')
            self.__sunrise_t = datetime.datetime.strptime(sunrise, "%I:%M %p").time()
            self.__sunset_t = datetime.datetime.strptime(sunset, "%I:%M %p").time()
            locale.resetlocale()

        now = datetime.datetime.now().time()
        if now<self.__sunrise_t or now>self.__sunset_t:
            self.__night = True
        else:
            self.__night = False
        log.debug("Weather: got sunrise '%s', sunset '%s', night = %s" % (self.__sunrise_t, self.__sunset_t, self.__night))

    def isNight(self):
        return self.__night

    #FIXME: Update with PyWAPI
    def isReportCorrect(self):
        return True 

    def isSevereCondition(self):
        if self.__current_condition != None:
            log.debug("Weather: got severe condition '%s'" % self.__current_condition[2])
            return self.__current_condition[2]
        else:
            log.error("Weather: got empty severe condition")
            return False;

    def getPixmap(self):
        if self.__current_condition != None:
            if self.__night:
                log.error("Weather: night, show '%s' icon" % self.__current_condition[1])
                return self.__current_condition[1]
            else:
                log.error("Weather: day, show '%s' icon" % self.__current_condition[0])
                return self.__current_condition[0]
        else:
            log.error("Weather: return 'offline' icon due to empty condition")
            return False

    def getCondition(self):
        if self.__weather_datasource == WeatherDataSource.GOOGLE:
            pureCondition = self.__localized_report['current_conditions']['condition']
        if self.__weather_datasource == WeatherDataSource.YAHOO:
            pureCondition = self.__current_condition[3]
        return pureCondition

    def getHumidity(self):
        if self.__weather_datasource == WeatherDataSource.GOOGLE:
            humidity = self.__localized_report['current_conditions']['humidity']
        if self.__weather_datasource == WeatherDataSource.YAHOO:
            humidity = "%s: %s%%" % (_("Humidity"), self.__localized_report['atmosphere']['humidity'])
        return humidity

    #FIXME: Update with PyWAPI
    def getDewPoint(self):
        if self.__weather_datasource == WeatherDataSource.GOOGLE:
            #Can't be calculated in Google
            return None
        if self.__weather_datasource == WeatherDataSource.YAHOO:
            #Can't be calculated in Yahoo 
            return None
        #if (self.__metric_system == MetricSystem.SI):
        #    _value = "---"
        #    _unit  = "C"
        #else:
        #    _value = "--"
        #    _unit  = "F"
        #return "%s: %s %s" % (_("Dew Point"), _value, _unit)

    #FIXME: Update with PyWAPI
    def getPressure(self):
        if self.__weather_datasource == WeatherDataSource.GOOGLE:
            value = "---"
            unit = ""
        if self.__weather_datasource == WeatherDataSource.YAHOO:
            value = self.__localized_report['atmosphere']['pressure']
            unit = self.__localized_report['units']['pressure']
        return "%s: %s %s" % (_("Pressure"), value, units)

    def getPureTemperature(self):
        if self.__weather_datasource == WeatherDataSource.GOOGLE:
            if (self.__metric_system == MetricSystem.SI):
                _value = self.__report['current_conditions']['temp_c']
                _unit  = "C"
            else:
                _value = self.__report['current_conditions']['temp_f']
                _unit  = "F"
        if self.__weather_datasource == WeatherDataSource.YAHOO:
            if (self.__metric_system == MetricSystem.SI):
                _value = "%.1f" % ((float(self.__report['condition']['temp']) - 32) * 5/9)
                _unit  = "C"
            else:
                _value = self.__report['condition']['temp']
                _unit  = "F"
        return ("%s %s" % (_value, _unit)).replace(".0", "")

    def getTemperature(self):
        return "%s: %s" % (_("Temperature"), self.getPureTemperature())

    def getHumidex(self):
        if self.__weather_datasource == WeatherDataSource.GOOGLE:
            #Empty for Google
            return None
        if self.__weather_datasource == WeatherDataSource.YAHOO:
            #Empty for Yahoo
            return None
        #dewPoint=2
        #temp_c = 1
        #self.vapour_pressure = 6.11 * math.exp(5417.7530 * ( (1/273.16) - (1/(dewPoint+273.16))))
        #self.humidex = temp_c + (0.5555)*(self.vapour_pressure  - 10.0);
        #return ("%s: %.1f" % (_("Humidex"), self.humidex)).replace(".0", "")

    def convertWindDirection(self, degrees):
        try:
            degrees = int(degrees)
        except ValueError:
            return ''
    
        if degrees < 23 or degrees >= 338:
            #Short wind direction - north
            return _('N')
        elif degrees < 68:
            return _('NE')
        elif degrees < 113:
            return _('E')
        elif degrees < 158:
            return _('SE')
        elif degrees < 203:
            return _('S')
        elif degrees < 248:
            return _('SW')
        elif degrees < 293:
            return _('W')
        elif degrees < 338:
            return _('NW')

    def getWindSpeed(self):
        if self.__weather_datasource == WeatherDataSource.GOOGLE:
            localized_wind_info = self.__localized_report['current_conditions']['wind_condition'].split(' ')
            wind_direction = localized_wind_info[1]
            wind_info = self.__report['current_conditions']['wind_condition'].split(' ')
            wind_speed = wind_info[3]

        if self.__weather_datasource == WeatherDataSource.YAHOO:
            wind_direction = self.__localized_report['wind']['direction']
            wind_speed = self.__localized_report['wind']['speed']
            wind_units = self.__localized_report['units']['speed']
            localized_wind_info = [_("Wind") + ":", self.convertWindDirection(wind_direction), ',', wind_speed, wind_units] 

        #Parse Wind_direction - convert to selected scale
        if (self.__wind_unit == WindUnits.MPH):
            _value = float(wind_speed)
            _unit  = _("mph")
        if (self.__wind_unit == WindUnits.MPS):
            _value = float(wind_speed) * 0.44704
            _unit  = _("m/s")
        if (self.__wind_unit == WindUnits.BEAUFORT):
            _value = self.getBeufortFromMPH(float(wind_speed))
            _unit  = ""
        if (self.__wind_unit == WindUnits.KPH):
            _value = float(wind_speed) * 1.609344
            _unit  = _("km/h")
        if (self.__wind_unit == WindUnits.KNOTS):
            _value = float(wind_speed) * 0.868976241900648
            _unit  = _("knot(s)")
        localized_wind_info[len(localized_wind_info)-1] = _unit
        localized_wind_info[len(localized_wind_info)-2] = ("%0.1f" % _value).replace(".0", "")
        return ' '.join(localized_wind_info)

    #FIXME: fiill in with data
    def getBeufortFromMPH(self, value):
        if value < 1:
            return 0
        elif value < 4:
            return 1
        elif value < 8:
            return 2
        elif value < 13:
            return 3
        elif value < 18:
            return 4
        elif value < 25:
            return 5
        elif value < 27:
            return 6
        elif value < 39:
            return 7
        elif value < 47:
            return 8
        elif value < 89:
            return 9
        elif value < 64:
            return 10
        elif value < 73:
            return 11
        elif value >= 73:
            return 12

    def getSunrise(self):
        return "%s: %s" % (_("Sunrise"), self.__sunrise_t.strftime('%X'))

    def getSunset(self):
        return "%s: %s" % (_("Sunset"), self.__sunset_t.strftime('%X'))

class indicator_weather(threading.Thread):
    last_update_time = None

    def __init__(self):
        log.debug("Indicator: creating")
        threading.Thread.__init__(self)
        self.main_icon = os.path.join
        self.winder = appindicator.Indicator ("indicator-weather", "weather-indicator", appindicator.CATEGORY_OTHER)
        self.winder.set_status (appindicator.STATUS_ACTIVE)
        self.winder.set_attention_icon ("weather-indicator-error")

        log.debug("Indicator: reading settings")
        self.settings = Settings()
        self.settings.prepare_settings_store()      
        self.rate  = self.settings.get_value("refresh_rate")
        self.unit  = self.settings.get_value("unit")
        self.notif = self.settings.get_value("notif")
        self.wind  = self.settings.get_value("wind")
        self.placechosen = self.settings.get_value("placechosen")
        self.places = self.settings.get_value("places")

        log.debug("Preferences: got settings: rate=%s, unit=%s, notif=%s, wind=%s, placechosen=%s, places=%s" %
                (self.rate, self.unit, self.notif, self.wind, self.placechosen, self.places))

        #Setting default values
        self.metric_system = MetricSystem.SI
        self._wind_unit = WindUnits.MPH
        self.place = None
        self.menu = None
               
        if self.unit in (False, None):
            log.debug("Indicator: could not parse unit, setting to S")
            self.settings.set_value("unit", 'S')
            self.unit = 'S'
            self.metric_system = MetricSystem.SI
        else:
            if (self.unit == 'S'):
                self.metric_system = MetricSystem.SI
            else:
                self.metric_system = MetricSystem.IMPERIAL
            
        if self.notif in (False, None):
            log.debug("Indicator: could not parse notif, setting to N")
            self.settings.set_value("notif", 'N')
            self.notif = 'N'
        
        if self.wind in (False, None):
            log.debug("Indicator: could not parse notif, setting to mph")
            self.settings.set_value("wind", 'mph')
            self._wind_unit = WindUnits.MPH
        else:
            if (self.wind == 'mph'):
                self._wind_unit = WindUnits.MPH
            elif (self.wind == 'mps'):
                self._wind_unit = WindUnits.MPS
            elif (self.wind == 'beaufort'):
                self._wind_unit = WindUnits.BEAUFORT
            elif (self.wind == 'kph'):
                self._wind_unit = WindUnits.KPH
            elif (self.wind == 'knots'):
                self._wind_unit = WindUnits.KNOTS
            
        if self.rate in (False, None):
            log.debug("Indicator: could not parse rate, setting to 15")
            self.settings.set_value("refresh_rate", 15)
            self.rate = 15

        if self.placechosen == None:
            log.debug("Indicator: could not parse placechosen, setting to 0")
            self.settings.set_value("placechosen", 0)
            self.placechosen = 0
        else:
            self.placechosen = int(self.placechosen)
            
        if self.places in (False, None, '', '[]', "['']"):
            log.debug("Indicator: could not parse places")
            self.menu_noplace()
        else:
            self.places = eval(self.places)
            self.place = self.places[self.placechosen]
            self.location_details = self.settings.get_location_details(self.place[0])
            if self.location_details in (False, None, '', '[]', "['']"):
                log.debug("Indicator: could not parse location details")
                self.menu_noplace()
            else:
                self.location_details = eval(self.location_details)
                self.menu_normal()
                self.update_weather()
                self.winder.set_menu(self.menu)

    def update_label(self, label):
      if (hasattr(self.winder, 'set_label')):
        log.debug("Indicator: update_label: setting label to '%s'" % label)
        self.winder.set_label(label)
        self.winder.set_status(appindicator.STATUS_ATTENTION)
        self.winder.set_status(appindicator.STATUS_ACTIVE)

    def menu_noplace(self):
        log.debug("Indicator: making a menu for no places")
        menu_noplace = gtk.Menu()
        setup = gtk.MenuItem(_("Set Up Weather..."))
        setup.connect("activate", self.prefs)
        setup.show()
        menu_noplace.append(setup)

        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        menu_noplace.append(quit)

        self.winder.set_status(appindicator.STATUS_ATTENTION)
        self.winder.set_status(appindicator.STATUS_ACTIVE)
        self.winder.set_menu(menu_noplace)
    
    def menu_normal(self):
        log.debug("Indicator: menu_normal: filling in a menu for found places")
        self.menu = gtk.Menu()
            
    ##City
        self.city_show = gtk.MenuItem()
        self.city_show.set_sensitive(True)
        self.menu.append(self.city_show)
        self.city_show.show()
        
    ##Condition
        self.cond_show = gtk.MenuItem()
        self.cond_show.set_sensitive(True)
        self.cond_show.show()
        self.menu.append(self.cond_show)
        
    ##Temperature        
        self.temp_show = gtk.MenuItem()
        self.temp_show.set_sensitive(True)
        self.temp_show.show()
        self.menu.append(self.temp_show)

    ##Humidex        
        self.humidex_show = gtk.MenuItem()
        self.humidex_show.set_sensitive(True)
        self.humidex_show.show()
        self.menu.append(self.humidex_show)
        
    ##Humidity
        self.humid_show = gtk.MenuItem()
        self.humid_show.set_sensitive(True)
        self.humid_show.show()
        self.menu.append(self.humid_show)
        
    ##Wind
        self.wind_show = gtk.MenuItem()
        self.wind_show.set_sensitive(True)
        self.wind_show.show()
        self.menu.append(self.wind_show)
                
    ##Sunrise
        self.sunrise_show = gtk.MenuItem()
        self.sunrise_show.set_sensitive(True)
        self.sunrise_show.show()
        self.menu.append(self.sunrise_show)

    ##Sunset
        self.sunset_show = gtk.MenuItem()
        self.sunset_show.set_sensitive(True)
        self.sunset_show.show()
        self.menu.append(self.sunset_show)
        
    ##Cities
        if len(self.places) != 1:
            ##Breaker
            breaker = gtk.SeparatorMenuItem()
            breaker.show()
            self.menu.append(breaker)

            log.debug("Indicator: menu_normal: adding first location menu item '%s'" % self.places[0][1])
            loco1 = gtk.RadioMenuItem(None, self.places[0][1])
            if self.placechosen == 0:
                loco1.set_active(True)
            loco1.connect("toggled", self.on_city_changed)
            loco1.show()
            self.menu.append(loco1)
            for place in self.places[1:]:
                log.debug("Indicator: menu_normal: adding location menu item '%s'" % place[1])
                loco = gtk.RadioMenuItem(loco1, place[1])
                if self.places.index(place) == self.placechosen:
                    loco.set_active(True)
                loco.connect("toggled", self.on_city_changed)
                loco.show()
                self.menu.append(loco)
        
    ##Breaker
        breaker = gtk.SeparatorMenuItem()
        breaker.show()
        self.menu.append(breaker)

        self.refresh_show = gtk.MenuItem("%s (%s)" % (_("Refresh"), _("refreshed just now")))
        self.refresh_show.connect("activate", self.update_weather)
        self.refresh_show.show()
        self.menu.append(self.refresh_show)
        
        ext_show = gtk.MenuItem(_("Forecast"))
        ext_show.connect("activate", self.extforecast)
        ext_show.show()
        self.menu.append(ext_show)

    ##Preferences      
        prefs_show = gtk.MenuItem(_("Preferences..."))
        prefs_show.connect("activate", self.prefs)
        prefs_show.show()
        self.menu.append(prefs_show)

    ##Quit
        quit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        quit.connect("activate", self.quit)
        quit.show()
        self.menu.append(quit)

        self.winder.set_menu(self.menu)
        self.update_label("")
    
    def on_city_changed(self,widget):
        if widget.get_active():
            for place in self.places:
                if (place[1] == widget.get_label()):
                    log.debug("Indicator: new location selected: %s" % self.places.index(place))
                    self.placechosen = self.places.index(place)
                    break
            self.settings.set_value("placechosen", self.placechosen)
            self.update_weather(False)

    def update_refresh_label(self):
        """ Calculate number minutes since last update and show this value in Refresh label"""
        self.refreshed_minutes_ago += 1
        log.debug("Indicator: updating refresh label, %s min. ago" % self.refreshed_minutes_ago)
        refresh_label = "%s (%s)" % (_("Refresh"), _("last refreshed %s min. ago") % self.refreshed_minutes_ago)
        self.refresh_show.set_label(refresh_label)
        self.winder.set_menu(self.menu)
        self.refresh_id = gobject.timeout_add(60000, self.update_refresh_label)

    def show_cached_weather(self):
        cached_weather = self.settings.get_weather(self.places[self.placechosen][0])
        if cached_weather != None:
            cached_weather = eval(cached_weather)
            log.debug("Indicator: loading weather from cache for %s" % self.places[self.placechosen])
            self.menu_normal()
            self.icon = cached_weather['icon']
            if (self.icon == False):
              self.winder.set_icon("weather-indicator-unknown")
            else:
              self.winder.set_icon(self.icon)

            self.city_show.set_label(self.places[self.placechosen][1])
            self.cond_show.set_label(cached_weather['condition'])
            self.temp_show.set_label(cached_weather['temper'])
            if cached_weather['humidex'] != None:
                self.humidex_show.set_label(cached_weather['humidex'])
            else:
                self.humidex_show.destroy()
            self.humid_show.set_label(cached_weather['humidity'])
            self.wind_show.set_label(cached_weather['wind'])
            self.sunrise_show.set_label(cached_weather['sunrise'])
            self.sunset_show.set_label(cached_weather['sunset'])
            self.update_label(cached_weather['label'])
            self.refresh_show.set_label("%s" % (_("Refreshing, please wait")))
            self.winder.set_menu(self.menu)
            self.winder.set_status(appindicator.STATUS_ATTENTION)
            self.winder.set_status(appindicator.STATUS_ACTIVE)           

    def get_new_weather_data(self, notif = True):
        weather = self.get_weather()
        if weather == None:
            log.debug("Indicator: updateWeather: could not get weather")
            for item in self.menu.get_children()[0:len(self.menu.get_children())]:
                item.destroy()

            self.menu = gtk.Menu()
            self.problem_show = gtk.MenuItem(_("Connection problem"))
            self.problem_show.set_sensitive(False)
            self.problem_show.show()
            self.menu.append(self.problem_show)

            self.refresh_show = gtk.MenuItem(_("Refresh"))
            self.refresh_show.connect("activate", self.update_weather)
            self.refresh_show.show()
            self.menu.append(self.refresh_show)

            self.quit_menu = gtk.ImageMenuItem(gtk.STOCK_QUIT)
            self.quit_menu.connect("activate", self.quit)
            self.quit_menu.show()
            self.menu.append(self.quit_menu)

            self.winder.set_icon("weather-indicator-error")
            self.update_label("")
            self.winder.set_menu(self.menu)

            log.debug("Indicator: updateWeather: setting rate to one minute")
            self.rateid = gobject.timeout_add(60000, self.update_weather)
            return

        #Refresh label update interval is 1 min
        if hasattr(self, 'refresh_id'):
          gobject.source_remove(self.refresh_id)
        self.refreshed_minutes_ago = 0
        self.refresh_id = gobject.timeout_add(60000, self.update_refresh_label)

        self.condition = weather.getCondition()
        self.icon = weather.getPixmap()
        log.debug("Indicator: updateWeather: got condition '%s', icon '%s'" % (self.condition, self.icon))
        log.debug("Indicator: fill in menu with params: city='%s', temp='%s', humidex='%s', humid='%s', wind='%s', sunrise='%s', sunset='%s', puretemp=%s" % (self.places[self.placechosen][1], weather.getTemperature(), weather.getHumidex(), weather.getHumidity(), weather.getWindSpeed(), weather.getSunrise(), weather.getSunset(), weather.getPureTemperature()))
        #self.menu_normal()
        self.city_show.set_label(self.places[self.placechosen][1])
        self.cond_show.set_label(self.condition)
        self.temp_show.set_label(weather.getTemperature())
        if (weather.getHumidex() != None):
            self.humidex_show.set_label(weather.getHumidex())
        else:
            self.humidex_show.destroy()
        self.humid_show.set_label(weather.getHumidity())
        self.wind_show.set_label(weather.getWindSpeed())
        self.sunrise_show.set_label(weather.getSunrise())
        self.sunset_show.set_label(weather.getSunset())
        self.update_label(weather.getPureTemperature())
        self.refresh_show.set_label("%s (%s)" % (_("Refresh"), _("last refreshed just now")))
        self.winder.set_menu(self.menu)

        #Saving cached data, unless correct icon is supplied
        if (self.icon == False):
            self.winder.set_icon("weather-indicator-unknown")
        else:
            self.winder.set_icon(self.icon)
            self.settings.save_weather(weather, self.places[self.placechosen][0])
        self.winder.set_status(appindicator.STATUS_ATTENTION)
        self.winder.set_status(appindicator.STATUS_ACTIVE)

        if self.condition != self.settings.get_value("current") and self.notif == 'U':
            log.debug("Indicator: updateWeather: weather has changed, notify")
            self.notify(self.condition, self.icon)
        if self.notif == 'S' and weather.isSevereCondition():
            log.debug("Indicator: updateWeather: severe condition notification")
            self.notify(self.condition, self.icon, severe=True)

        self.settings.set_value("current", self.condition)
        log.debug("Indicator: updateWeather: setting rate to %s" % self.rate)
        self.rateid = gobject.timeout_add(int(self.rate) * 60000, self.update_weather)

    def update_weather(self, notif=True, widget=None):
        log.debug("Indicator: updateWeather: updating weather for %s" % self.places[self.placechosen])
        #First, display cached data
        threading.Thread(target=self.show_cached_weather).start()
        #Then, start a new thread with real data pickup
        threading.Thread(target=self.get_new_weather_data).start()

    def get_weather(self):
        log.debug("Indicator: getWeather for location '%s'" % self.location_details['full name'])  
        self.current_location = Location(self.metric_system, self._wind_unit, self.location_details)
        #if (self.current_location.find_city_by_code(city_code, self.placechosen) == False):
        #    log.error("Indicator: getWeather: location with code %s not found" % city_code)
        log.debug("Indicator: getWeather: updating weather report")  
        self.current_location.update_weather_data()
        return self.current_location.weather

    def prefs(self, widget):
        log.debug("Indicator: open Preferences")  
        self.prefswindow = PreferencesDialog()
        self.prefswindow.show()
        
    def extforecast(self, widget):
        log.debug("Indicator: open Forecast")  
        forecastwd = ExtendedForecast()
        forecastwd.show()
        
    def notify(self,conditon,icon,severe=False):
        log.debug("Indicator: Notify on weather condition, severe=%s, condition=%s, icon=%s" % (severe, self.condition, icon))  
        if severe:
			n = pynotify.Notification (_("Severe weather alert"),
                self.condition,
                icon)
        else:
		    n = pynotify.Notification (self.condition,"",icon)
        n.show ()

    def quit(self, widget, data=None):
        log.debug("Indicator: Quitting")  
        gtk.main_quit()

class PreferencesDialog(gtk.Dialog):
    __gtype_name__ = "PreferencesDialog"
    def __new__(cls):
        log.debug("Preferences: creating")
        builder = get_builder('PreferencesDialog')
        new_object = builder.get_object("preferences_dialog")
        new_object.finish_initializing(builder)
        return new_object

    def finish_initializing(self, builder):
        log.debug("Preferences: finishing initialization")
        log.debug("Preferences: got settings: unit=%s, notif=%s, wind=%s, rate=%s" %
                (wi.unit, wi.notif, wi.wind, wi.rate))
        self.builder = builder
        #Refactor this
        if wi.unit == 'S':
            self.builder.get_object('si').set_active(True)
        elif wi.unit == 'I':
            self.builder.get_object('imperial').set_active(True)
        if wi.notif == 'N':
            self.builder.get_object('nonotif').set_active(True)
        elif wi.notif == 'O':
            self.builder.get_object('notifsevere').set_active(True)
        else:
            self.builder.get_object('notifall').set_active(True)            
        if wi.wind == 'mps':
            self.builder.get_object('mps').set_active(True)
        elif wi.wind == 'mph':
            self.builder.get_object('mph').set_active(True)
        elif wi.wind == 'kph':
            self.builder.get_object('kph').set_active(True)
        elif wi.wind == 'knots':
            self.builder.get_object('knots').set_active(True)
        else:
            self.builder.get_object('beaufort').set_active(True)
        
        self.builder.get_object('rate').set_value(float(wi.rate))

        log.debug("Preferences: Loading places")
        if wi.places != None:
            for place in wi.places:
                log.debug("Preferences: Places: got (%s, %s)" % (place[1], place[0]))
                newplace = list()
                newplace.append(place[1])
                newplace.append(place[0])
            
                self.builder.get_object('citieslist').append(newplace)
            self.builder.get_object('button1').set_sensitive(True)
            
        self.builder.connect_signals(self)
        
    def on_remove_location(self, widget):
        selection = self.builder.get_object('displaylist').get_selection()
        model, iter = selection.get_selected()
        log.debug("Preferences: Removing location %s (code %s)" % (model[iter][0], model[iter][1]))
        if iter != None:
            model.remove(iter)

        if (self.builder.get_object('citieslist').get_iter_first() == None):
            self.builder.get_object('button1').set_sensitive(False)

    def on_add_location(self, widget):
        log.debug("Preferences: Add location clicked")
        self.assistant = Assistant()
        self.assistant.show()
       
    def on_destroy(self, widget, data=None):
        pass
    
    def ok(self, widget, data=None):
        """The user has selected to save the changes.

        Called before the dialog returns gtk.RESONSE_OK from run().
        """
        log.debug("Preferences: Saving settings")
        needupdate = False
        # Metric System
        metric_systems = [('si',       "S", MetricSystem.SI),
                          ('imperial', "I", MetricSystem.IMPERIAL)]

        for metric_system in metric_systems:
            if self.builder.get_object(metric_system[0]).get_active():
                new_unit = metric_system[1]
                new_metric_system = metric_system[2]

        if (wi.unit != new_unit):
            wi.unit = new_unit
            wi.metric_system = new_metric_system
            wi.settings.set_value("unit", wi.unit)
            needupdate = True
            log.debug("Preferences: Unit changed to '%s'" % wi.unit)

        # Wind Units
        wind_systems = [('mps',      "mps",      WindUnits.MPS),
                        ('mph',      "mph",      WindUnits.MPH),
                        ('kph',      "kph",      WindUnits.KPH),
                        ('beaufort', "beaufort", WindUnits.BEAUFORT),
                        ('knots',    "knots",    WindUnits.KNOTS)]

        for wind_system in wind_systems:
            if self.builder.get_object(wind_system[0]).get_active():
                new_wind_unit   = wind_system[1]
                new_wind_system = wind_system[2]

        if (wi.wind != new_wind_unit):
            wi.wind = new_wind_unit
            wi._wind_unit = new_wind_system
            wi.settings.set_value("wind", wi.wind)
            needupdate = True
            log.debug("Preferences: Wind Unit changed to '%s'" % wi.wind)

        # Notifications
        notifications = [('nonotif',     "N"),
                         ('notifsevere', "O"),
                         ('notifall',    "U")]
        for notification in notifications:
            if self.builder.get_object(notification[0]).get_active():
                new_notification  = notification[1]

        if (wi.notif != new_notification):
            wi.notif = new_notification
            wi.settings.set_value("notif", wi.notif)
            needupdate = True
            log.debug("Preferences: Notifications changed to '%s'" % wi.notif)

        ##Rate
        if int(self.builder.get_object('rate').get_value()) != wi.rate:
            wi.settings.set_value("refresh_rate", int(self.builder.get_object('rate').get_value()))
            wi.rate = int(self.builder.get_object('rate').get_value())
            if hasattr(wi, "rateid"):
                gobject.source_remove(wi.rateid)
            wi.rateid = gobject.timeout_add(int(wi.rate) * 60000, wi.update_weather)
            log.debug("Preferences: Rate changed to '%s'" % wi.rate)
            
        ##places
        newplaces = list()
        item = self.builder.get_object('citieslist').get_iter_first()
        while ( item != None ):
            newplace = list()
            newplace.append(self.builder.get_object('citieslist').get_value (item, 1))
            newplace.append(self.builder.get_object('citieslist').get_value (item, 0))
            newplaces.append(newplace)
            item = self.builder.get_object('citieslist').iter_next(item)
        if newplaces != wi.places:
            wi.places = newplaces
            log.debug("Preferences: Places changed to '%s'" % str(wi.places))
            wi.settings.set_value("places", str(wi.places))
            if (type(wi.place) != None) and (wi.place in wi.places):
                wi.placechosen = wi.places.index(wi.place)
            else:
                wi.placechosen = 0
            log.debug("Preferences: Place Chosen changed to '%s'" % wi.placechosen)
            wi.settings.set_value("placechosen", wi.placechosen)
            wi.menu_normal()
            wi.winder.set_menu(wi.menu)
            needupdate = True
        
        if needupdate:
            wi.update_weather(False)
        
        self.destroy()

    def cancel(self, widget, data=None):
        """The user has elected cancel changes.

        Called before the dialog returns gtk.RESPONSE_CANCEL for run()
        """
        # Restore any changes to self._preferences here.
        log.debug("Preferences: Cancelling")
        self.destroy()
        
class ExtendedForecast(gtk.Window):
    __gtype_name__ = "ExtendedForecast"
    def __new__(cls):
        log.debug("ExtendedForecast: creating")
        builder = get_builder('ExtendedForecast')
        new_object = builder.get_object("extended_forecast")
        new_object.finish_initializing(builder)
        return new_object
        
    def finish_initializing(self, builder):
        log.debug("ExtendedForecast: finishing initialization")
        self.builder = builder
        self.builder.connect_signals(self)

        log.debug("ExtendedForecast: chosen place: %s (code %s)" % (wi.places[wi.placechosen][1], wi.places[wi.placechosen][0]))
        self.builder.get_object('extended_forecast').set_title(_('Weather Forecast for ')+wi.places[wi.placechosen][1])
        log.debug("ExtendedForecast: getting forecast data")
        locale_name = locale.getlocale()[0].split('_')[0]
        forecast = Forecast(source = WeatherDataSource.GOOGLE, location = wi.current_location, units = wi.metric_system, locale = locale_name)
        forecast.prepare_forecast_data()
        daysofweek = forecast.get_forecast_daysofweek()
        (highdata, lowdata) = forecast.get_forecast_data()
        icons      = forecast.get_forecast_icons()
        conditions = forecast.get_forecast_conditions()

        log.debug("ExtendedForecast: parsing forecast data")
        self.builder.get_object('day1lbl').set_label('<big>%s</big>' % daysofweek[0].capitalize())
        self.builder.get_object('day2lbl').set_label('<big>%s</big>' % daysofweek[1].capitalize())
        self.builder.get_object('day3lbl').set_label('<big>%s</big>' % daysofweek[2].capitalize())
        self.builder.get_object('day4lbl').set_label('<big>%s</big>' % daysofweek[3].capitalize())

        #FIXME: Refactor this
        i=0
        for icon in icons[1:]:
            i=i+1
            if icon in ('chance_of_storm', 'storm', 'thunderstorm', 'chance_of_tstorm'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-storm',gtk.ICON_SIZE_BUTTON)
            elif icon in ('sleet',  'snow',  'icy',  'flurries',  'chance_of_snow'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-snow',gtk.ICON_SIZE_BUTTON)
            elif icon in ('dust',  'fog',  'smoke',  'haze',  'mist'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-fog',gtk.ICON_SIZE_BUTTON)
            elif icon in ('rain'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-showers',gtk.ICON_SIZE_BUTTON)
            elif icon in ('chance_of_rain'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-showers-scattered',gtk.ICON_SIZE_BUTTON)
            elif icon in ('sunny', 'clear'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-clear',gtk.ICON_SIZE_BUTTON)
            elif icon in ('mostly_cloudy', 'cloudy'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-overcast',gtk.ICON_SIZE_BUTTON)
            elif icon in ('mostly_sunny',  'partly_cloudy'):
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('weather-few-clouds',gtk.ICON_SIZE_BUTTON)
            else:
                self.builder.get_object('day%simage' % str(i)).set_from_icon_name('window-close',gtk.ICON_SIZE_BUTTON)
        i=0
        for condition in conditions[1:]:
            i=i+1
            self.builder.get_object('day%scond' % str(i)).set_label(condition)
        i=0
        #Refactor this
        if wi.metric_system == MetricSystem.SI:
            tempunit = 'C'
        elif unit == 'I':
            tempunit = 'F'
        for high in highdata:
            i=i+1
            self.builder.get_object('day%stemphigh' % str(i)).set_label((_('High: ')+'%s%s') % (high,tempunit))
        i=0
        for low in lowdata:
            i=i+1
            self.builder.get_object('day%stemplow' % str(i)).set_label((_('Low: ')+'%s%s') % (low,tempunit))
        
    def close(self, widget, data=None):
        log.debug("ExtendedForecast: closing window")
        self.destroy()
    
    def on_destroy(self, widget, data=None):
        pass
        
#class EditPlace(gtk.MessageDialog):
    #__gtype_name__ = "EditPlace"
    #def __new__(cls):
        #builder = get_builder('EditPlace')
        #new_object = builder.get_object("edit_place")
        #new_object.finish_initializing(builder)
        #return new_object
        
    #def finish_initializing(self, builder):
        #self.builder = builder
        #self.builder.connect_signals(self)
    
    #def ok(self, widget, data=None):
        #self.destroy()
        #if self.builder.get_object("entry").get_text() != '':
            #return self.builder.get_object("entry").get_text()
        #else:
            #return False
        ###APPLY CHANGES
        
    #def cancel(self, widget, data=None):
        #"""The user has elected cancel changes.

        #Called before the dialog returns gtk.RESPONSE_CANCEL for run()
        #"""
        ## Restore any changes to self._preferences here.
        #self.destroy()
        #return False

class Assistant(gtk.Assistant):
    __gtype_name__ = "Assistant"
    
    def __new__(cls):
        log.debug("Assistant: creating new Assistance instance")
        builder = get_builder('Assistant')
        new_object = builder.get_object("assistant")
        new_object.finish_initializing(builder)  
        return new_object

    # Generate a treeview model for gweather data
    def generate_treeview(self):
        log.debug("Assistant: generating treeview")
        #FIXME: Move this to WI object
        self.__all_locations_store = gtk.TreeStore(str, str, bool, str)
        node = gweather.location_new_world(True)
        self.parse_gweather_locations(node, None)
        return self.__all_locations_store

    # Recursevly parse locations
    def parse_gweather_locations(self, node, parent):
        children = node.get_children()
        if len(children) > 0:
            for i in children:
                timezone = i.get_timezone().get_tzid() if i.get_timezone() is not None else None
                is_city = i.get_level() is gweather.LOCATION_CITY
                #Unless it is a weather station or a country without children, iterate through children
                if (i.get_level() is gweather.LOCATION_WEATHER_STATION) or (len(i.get_children())>0):
                    node_iter = self.__all_locations_store.append(parent, (i.get_name(), timezone, is_city, i.get_code()))
                    self.parse_gweather_locations(i, node_iter)

    # Finish UI initialization - fill in tree
    def finish_initializing(self, builder):
        log.debug("Assistant: finishing initialization")
        self.builder = builder
        self.builder.connect_signals(self)
        self.assistant = self.builder.get_object("assistant")
        self.assistant.set_page_complete(self.builder.get_object("label"),True)
        self.assistant.set_page_complete(self.builder.get_object("review"),True)
        self.assistant.set_page_complete(self.builder.get_object("confirmplace"),True)
        # Fill in tree
        log.debug("Assistant: setting up treeview")
        self.__all_locations_view = self.builder.get_object("treeview-locations")
        column = gtk.TreeViewColumn("Location", gtk.CellRendererText(), text=0)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
        self.__all_locations_view.append_column(column)
        self.__all_locations_view.set_fixed_height_mode(True)

        self.__all_locations_store = gtk.TreeStore(str, str, bool, str)
        self.__all_locations_store.set_sort_column_id(0, gtk.SORT_ASCENDING)
        self.generate_treeview()
        self.__all_locations_view.set_model(self.__all_locations_store)
        self.__all_locations_selection = self.__all_locations_view.get_selection()
        self.__all_locations_selection.connect("changed", self.on_selection_changed)

        self.assistant.set_forward_page_func(self.get_city)

    #Callback for row selection
    def on_selection_changed(self,selection):
        self.assistant.set_page_complete(self.builder.get_object("placeinput"),False)
        if selection.count_selected_rows() != 0:
            select_iter = selection.get_selected()[1]
            log.debug("Assistant: Page 0: Tree: selected '%s', code %s" %
                    (self.__all_locations_store[select_iter][0], self.__all_locations_store[select_iter][3]))
            if self.is_location_and_leaf_node(select_iter):
                log.debug("Assistant: Page 0: Enabling 'Next' button")
                self.assistant.set_page_complete(self.builder.get_object("placeinput"),True)

    #Check, that selected row is a leaf and enable "next" button    
    def is_location_and_leaf_node(self, iter):
        row = self.__all_locations_store[iter]
        is_leaf_node = not self.__all_locations_store.iter_has_child(iter)
        return row[0] is not None and row[1] is not None and is_leaf_node

    # Create a location out of a tree
    def get_city(self,current_page):
        log.debug("Assistant: moved to page %s" % current_page)
        if self.assistant.get_current_page() == 1:
            select_iter = self.__all_locations_selection.get_selected()[1]
            city_iter = self.__all_locations_store[select_iter]
            self.city_code = city_iter[3]
            log.debug("Assistant: Page %s: got location with code %s" % (current_page, self.city_code))
            self.location = Location(wi.metric_system, wi._wind_unit)
            self.location.find_city_by_code(self.city_code)
            if self.location.found:
                log.debug("Assistant: Page %s: City %s found, full name - %s" %
                        (current_page, self.location.get_short_city_name(), self.location.get_full_city_name()))
                self.builder.get_object("lblplace").set_label('<big>%s</big>' % self.location.get_full_city_name())
                self.builder.get_object("entrylbl").set_text(self.location.get_short_city_name())
            else:
                log.error("Assistant: Page %s: City with code %s was NOT found" % (current_page, self.city_code))
        elif self.assistant.get_current_page() == 2:
            lbl = self.builder.get_object("entrylbl").get_text()
            log.debug("Assistant: Page %s: City label is %s" % (current_page, lbl))
            if lbl == '':
                log.debug("Assistant: Page %s: Empty label found, setting lbl to short name - %s label is %s" %
                    (current_page, self.location.get_short_city_name()))
                lbl = self.location.get_short_city_name()
            self.location.set_label(lbl)
            self.builder.get_object("lbl3").set_label('Label:')
            self.builder.get_object("labellbl").set_label('<b>%s</b>' % self.location.label)
            self.builder.get_object("placelbl").set_label('<b>'+self.location.get_full_city_name()+'</b>')
            
        return self.assistant.get_current_page() + 1
            
    def on_cancel(self,widget):
        log.debug("Assistant: Cancelled")
        self.destroy()
        
    def on_apply(self,widget):
        log.debug("Assistant: Apply: adding location ('%s', '%s')" % (self.location.label, self.location.code))
        newplace = list()
        newplace.append(self.location.label)
        newplace.append(self.location.code)
        wi.prefswindow.builder.get_object('citieslist').append(newplace)
        wi.prefswindow.builder.get_object('button1').set_sensitive(True)
        self.hide()

class singleinstance(object):
    '''
    singleinstance - based on Windows version by Dragan Jovelic this is a Linux
                     version that accomplishes the same task: make sure that
                     only a single instance of an application is running.
    '''
    def __init__(self, pidPath):
        '''
        pidPath - full path/filename where pid for running application is to be
                  stored.  Often this is ./var/<pgmname>.pid
        '''
        self.pidPath=pidPath
        # See if pidFile exists
        if os.path.exists(pidPath):
            log.debug("SingleInstance: pid file %s exists" % pidPath)
            # Make sure it is not a "stale" pidFile
            pid=open(pidPath, 'r').read().strip()
            # Check list of running pids, if not running it is stale so
            # overwrite
            pidRunning=commands.getoutput('ls /proc | grep %s' % pid)
            log.debug("SingleInstance: pid running %s" % pidRunning)
            if pidRunning:
                self.lasterror=True
            else:
                self.lasterror=False
        else:
            self.lasterror=False

        if not self.lasterror:
            log.debug("SingleInstance: writing new pid %s" % str(os.getpid()))
            # Write my pid into pidPath to keep multiple copies of program from
            # running.
            (fp, temp_path)=tempfile.mkstemp()
            try:
              os.fdopen(fp, "w+b").write(str(os.getpid()))
              os.rename(temp_path, pidPath)
            except Exception as e:
              log.error("SingleInstance: exception while renaming '%s' to '%s':\n %s" % (temp_path, pidPath, str(e)))  

    def alreadyrunning(self):
        return self.lasterror

    def __del__(self):
        if not self.lasterror:
            log.debug("SingleInstance: deleting %s" % self.pidPath)
            os.unlink(self.pidPath)

def main():
    gtk.main()
    return 0

if __name__ == "__main__":
    #Enable and configure logs
    log_filename = os.path.join(os.path.expanduser("~/.cache"), "indicator-weather.log")
    log = logging.getLogger('IndicatorWeather')
    log.setLevel(logging.DEBUG)
    log_handler = logging.handlers.RotatingFileHandler(log_filename, maxBytes=1024*1024, backupCount=5)
    log_formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    log_handler.setFormatter(log_formatter)
    log.addHandler(log_handler)

    log.info("------------------------------")
    log.info("Started Weather Indicator from %s" % PROJECT_ROOT_DIRECTORY)

    # Single instance stuff for weather indicator
    myapp = singleinstance("/tmp/weather-indicator.pid")
    # check is another instance of same program running
    if myapp.alreadyrunning():
        log.info("Another instance of this program is already running")
        sys.exit(_("Another instance of this program is already running"))
        
    # not running, safe to continue...
    gtk.gdk.threads_init()
    gtk.gdk.threads_enter()
    wi = indicator_weather()
    main()
    gtk.gdk.threads_leave()
